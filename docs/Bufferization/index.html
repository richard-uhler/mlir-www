<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Bufferization on MLIR - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Bufferization/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Bufferization on MLIR</h1><p>The general task of bufferization is to move SSA values (like tensors) into
allocated memory buffers that have to be freed when they are no longer needed.
This also involves the placement of copies to clone contents of allocated
memory buffers at specific locations (similar to register allocation). On the
one hand, these copies are needed to ensure the right behavior of a program, on
the other hand, introducing several aliases for a certain buffer could lead to
a wrong freeing of buffers. Therefore, we have to take care of them and the
program structure. The introduction of copies solves this problem. Several
unnecessary introduced copies during this process can be eliminated afterwards.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@func_on_tensors</span><span class=p>(</span><span class=nv>%source</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> mhlo<span class=p>.</span>exp <span class=nv>%source</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
  <span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@func_on_buffers</span><span class=p>(</span><span class=nv>%source</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%target</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
  lmhlo<span class=p>.</span>exp <span class=nv>%source</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  lmhlo<span class=p>.</span>copy <span class=nv>%0</span><span class=p>,</span> <span class=nv>%target</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>In general, Bufferization is split into three separate phases: a preparation
phase, a bufferization phase and a post-processing phase. The assignment
process happens during dialect conversion and allocates buffers for each value
that should be moved into a memory buffer. This has to be implemented by each
dialect using the following tools and patterns. Thereby, all operations on
memory buffers have to be changed to <code>memref&lt;T></code> types (see Preparation Phase).
Afterwards, the placement transformation (see BufferDeallocation) adds all
required deallocation operations, temporary buffers and copy operations
automatically.</p><h2 id=preparation-phase>Preparation Phase&nbsp;<a class=headline-hash href=#preparation-phase>¶</a></h2><p>In order to apply the BufferDeallocation code transformation, the input MLIR
program needs to leverage allocations (buffers in general) and <code>memref&lt;T></code>
types(as outlined above). If your input program does not work on buffers, you
need to perform this preparation step in order to port it to the “buffer
world”. This is a user-defined preparation step that is intended to be applied
during dialect conversion. The user has to take care for the right conversion
by providing conversion patterns relying on a type converter to assign buffers.</p><p>A necessary step is to apply type and function signature conversion.
Furthermore, after changing all function signatures, the associated return and
call operations must comply with the new corresponding function signatures. For
this purpose, three operation conversion patterns are introduced:</p><ul><li>BufferizeFuncOpConverter</li><li>BufferizeReturnOpConverter</li><li>BufferizeCallOpConverter</li></ul><p>In order to use these conversion patterns, the user needs to define a custom
BufferizeTypeConverter implementation.</p><h3 id=bufferizetypeconverter>BufferizeTypeConverter&nbsp;<a class=headline-hash href=#bufferizetypeconverter>¶</a></h3><p>The BufferizeTypeConverter is an extension to the TypeConverter class that
provides additional functionality for dialect developers to decide on the
signature of a function. The extra features include:</p><ul><li><code>setResultConversionKind</code> to decide on a function result after the conversion
with a specific type to be appended to the function argument list as an output
argument or remains as a function result.</li><li>define their own callback function for type or value unwrapping.</li></ul><h3 id=resultconversionkind>ResultConversionKind&nbsp;<a class=headline-hash href=#resultconversionkind>¶</a></h3><p>ResultConversionKind is an enum with two values</p><ul><li>AppendToArgumentList</li><li>KeepAsFunctionResult</li></ul><p>that defines how BufferizeFuncOpConverter should handle function results in
order to convert the signature of the function. The other two operation
conversion patterns also use ResultConversionKind to adapt themselves with the
new function signature.</p><p><code>ResultConversionKind</code> can be set using <code>setResultConversionKind</code>, which needs
two template parameters that correspond to the types before and after type
conversion. This mapping specifies whether the resulting type should stay as a
function result or should be appended to the arguments list after the
conversion is done. Note that the default value for unspecified mappings is
<code>KeepAsFunctionResult</code>. For instance, the following command updates the
<code>BufferizeTypeConverter</code> instance that defines all MemRefType function results
(converted from <code>RankedTensorTypes</code>). These results should be appended to the
function argument list in BufferizeFuncOpConverter:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>converter<span class=p>.</span>setResultConversionKind<span class=p>&lt;</span>RankedTensorType<span class=p>,</span> MemRefType<span class=p>&gt;</span><span class=p>(</span>
        BufferizeTypeConverter<span class=p>:</span><span class=p>:</span>AppendToArgumentsList<span class=p>)</span><span class=err>;</span>
</code></pre></div><h2 id=callbacks-for-unpacking-types>Callbacks for Unpacking Types&nbsp;<a class=headline-hash href=#callbacks-for-unpacking-types>¶</a></h2><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@func_on_tensors</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i1</span><span class=p>,</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@func_on_buffers</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%target0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%target1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>BufferizeFuncOpConverter is also able to unpack the types of arguments and
results of a function during function signature conversion. In the example
above, it unwraps the tuple type and converts the type of each constituent.</p><p>For this purpose, users can provide custom callbacks by using
<code>addDecomposeTypeConversion</code> for the <code>BufferizeTypeConverter</code> instance to show
how a specific type (i.e. TupleType) can be unpacked. However, when a type
decomposition is provided, there are two additional callbacks that have to be
defined as well. They specify how to pack or unpack values of that particular
type. These two callbacks can be provided by the <code>addArgumentMaterialization</code>
(packing) <strong>and</strong> <code>addDecomposeValueConversion</code> (unpacking) functions:</p><p>The following piece of code demonstrates this functionality by flattening a
<code>TupleType</code>.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>converter<span class=p>.</span>addDecomposeTypeConversion<span class=p>(</span>
        <span class=p>[</span><span class=p>]</span><span class=p>(</span>TupleType tupleType<span class=p>,</span> SmallVectorImpl<span class=p>&lt;</span>Type<span class=p>&gt;</span> <span class=err>&amp;</span>types<span class=p>)</span> <span class=p>{</span>
          tupleType<span class=p>.</span>getFlattenedTypes<span class=p>(</span>types<span class=p>)</span><span class=err>;</span>
          <span class=kt>return</span> success<span class=p>(</span><span class=p>)</span><span class=err>;</span>
        <span class=p>}</span><span class=p>)</span><span class=err>;</span>

converter<span class=p>.</span>addArgumentMaterialization<span class=p>(</span>
        <span class=p>[</span><span class=p>]</span><span class=p>(</span>OpBuilder <span class=err>&amp;</span>builder<span class=p>,</span> TupleType resultType<span class=p>,</span> ValueRange inputs<span class=p>,</span>
           Location <span class=kt>loc</span><span class=p>)</span> <span class=p>-&gt;</span> Optional<span class=p>&lt;</span>Value<span class=p>&gt;</span> <span class=p>{</span>
          if <span class=p>(</span>inputs<span class=p>.</span>size<span class=p>(</span><span class=p>)</span> <span class=p>=</span><span class=p>=</span> <span class=m>1</span><span class=p>)</span>
            <span class=kt>return</span> llvm<span class=p>:</span><span class=p>:</span>None<span class=err>;</span>
          TypeRange <span class=nl>TypeRange =</span> inputs<span class=p>.</span>getTypes<span class=p>(</span><span class=p>)</span><span class=err>;</span>
          SmallVector<span class=p>&lt;</span>Type<span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span> types<span class=p>(</span>TypeRange<span class=p>.</span>begin<span class=p>(</span><span class=p>)</span><span class=p>,</span> TypeRange<span class=p>.</span>end<span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=err>;</span>
          TupleType <span class=nl>tuple =</span> TupleType<span class=p>:</span><span class=p>:</span>get<span class=p>(</span>types<span class=p>,</span> builder<span class=p>.</span>getContext<span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=err>;</span>
          mlir<span class=p>:</span><span class=p>:</span>Value <span class=nl>value =</span> builder<span class=p>.</span>create<span class=p>&lt;</span>MakeTupleOp<span class=p>&gt;</span><span class=p>(</span><span class=kt>loc</span><span class=p>,</span> tuple<span class=p>,</span> inputs<span class=p>)</span><span class=err>;</span>
          <span class=kt>return</span> value<span class=err>;</span>
        <span class=p>}</span><span class=p>)</span><span class=err>;</span>

converter<span class=p>.</span>addDecomposeValueConversion<span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=p>(</span>OpBuilder <span class=err>&amp;</span>builder<span class=p>,</span> Location <span class=kt>loc</span><span class=p>,</span>
                                         TupleType resultType<span class=p>,</span> Value value<span class=p>,</span>
                                         SmallVectorImpl<span class=p>&lt;</span>Value<span class=p>&gt;</span> <span class=err>&amp;</span>values<span class=p>)</span> <span class=p>{</span>
      for <span class=p>(</span>unsigned <span class=nl>i =</span> <span class=m>0</span><span class=p>,</span> <span class=nl>e =</span> resultType<span class=p>.</span>size<span class=p>(</span><span class=p>)</span><span class=err>;</span> i <span class=p>&lt;</span> e<span class=err>;</span> <span class=err>+</span><span class=err>+</span>i<span class=p>)</span> <span class=p>{</span>
        Value <span class=nl>res =</span> builder<span class=p>.</span>create<span class=p>&lt;</span>GetTupleElementOp<span class=p>&gt;</span><span class=p>(</span>
            <span class=kt>loc</span><span class=p>,</span> resultType<span class=p>.</span>getType<span class=p>(</span>i<span class=p>)</span><span class=p>,</span> value<span class=p>,</span> builder<span class=p>.</span>getI32IntegerAttr<span class=p>(</span>i<span class=p>)</span><span class=p>)</span><span class=err>;</span>
        values<span class=p>.</span>push_back<span class=p>(</span>res<span class=p>)</span><span class=err>;</span>
      <span class=p>}</span>
      <span class=kt>return</span> success<span class=p>(</span><span class=p>)</span><span class=err>;</span>
 <span class=p>}</span><span class=p>)</span><span class=err>;</span>
</code></pre></div><p>In the scope of these callback functions, the elements of a tuple value can be
decomposed using <code>GetTupleElementOp</code>. Conversely, <code>MakeTupleOp</code> is used to pack
a list of values as a single tuple type.</p><h3 id=bufferization-operation-conversion-patterns>Bufferization Operation Conversion Patterns&nbsp;<a class=headline-hash href=#bufferization-operation-conversion-patterns>¶</a></h3><p>The following conversion patterns can be used to conveniently transform the
signature of a function, the return and call operations:</p><ul><li><code>BufferizeFuncOpConverter</code></li><li><code>BufferizeReturnOpConverter</code></li><li><code>BufferizeCallOpConverter</code></li></ul><p>Any combination of these conversion patterns can be specified by the user. If
you need to apply all of these operation converters, you can use
<code>populateWithBufferizeOpConversionPatterns</code> which sets up all converters.</p><h3 id=bufferizefuncopconverter>BufferizeFuncOpConverter&nbsp;<a class=headline-hash href=#bufferizefuncopconverter>¶</a></h3><p>The BufferizeFuncOpConverter is the actual function operation converter that
applies signature conversion by using a previously defined
<code>BufferizeTypeConverter</code>.</p><p>In the following example, we configure a <code>BufferizeTypeConverter</code> instance such
that</p><ul><li>all RankedTensorTypes should be converted to MemRefTypes.</li><li>all function results that are results of type conversion from
RankedTensorTypes to MemRefTypes should be appended to the function argument
list.</li><li>all TupleTypes should be flattened and decomposed to its constituents.</li></ul><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>converter<span class=p>.</span>addConversion<span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=p>(</span>RankedTensorType type<span class=p>)</span> <span class=p>{</span>
    <span class=kt>return</span> <span class=p>(</span>Type<span class=p>)</span>MemRefType<span class=p>:</span><span class=p>:</span>get<span class=p>(</span>type<span class=p>.</span>getShape<span class=p>(</span><span class=p>)</span><span class=p>,</span> type<span class=p>.</span>getElementType<span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=err>;</span>
  <span class=p>}</span><span class=p>)</span><span class=err>;</span>
converter<span class=p>.</span>setResultConversionKind<span class=p>&lt;</span>RankedTensorType<span class=p>,</span> MemRefType<span class=p>&gt;</span><span class=p>(</span>
        BufferizeTypeConverter<span class=p>:</span><span class=p>:</span>AppendToArgumentsList<span class=p>)</span><span class=err>;</span>
converter<span class=p>.</span>addDecomposeTypeConversion<span class=p>(</span>
        <span class=p>[</span><span class=p>]</span><span class=p>(</span>TupleType tupleType<span class=p>,</span> SmallVectorImpl<span class=p>&lt;</span>Type<span class=p>&gt;</span> <span class=err>&amp;</span>types<span class=p>)</span> <span class=p>{</span>
          tupleType<span class=p>.</span>getFlattenedTypes<span class=p>(</span>types<span class=p>)</span><span class=err>;</span>
          <span class=kt>return</span> success<span class=p>(</span><span class=p>)</span><span class=err>;</span>
        <span class=p>}</span><span class=p>)</span><span class=err>;</span>
</code></pre></div><p>Consider the following signature conversion:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@on_tensors</span><span class=p>(</span><span class=nv>%arg1</span><span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i1</span><span class=p>,</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>)</span><span class=p>{</span>
 <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@on_buffers</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%out</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
 <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>Using the presented converter setup, all TupleType arguments and results are
decomposed first. The tensor&lt;5xf32> result is converted to a memref&lt;5xf32> type
and appended to the argument list. There is no conversion for the types memref,
i1, and f32. Therefore, the memref&lt;10xf32> result is kept as it is and will
also be kept as a function result since there is no ResultConversionKind
mapping from a MemRefType to a MemRefType. However, if we change the
result-conversion behavior via</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>converter<span class=p>.</span>setResultConversionKind<span class=p>&lt;</span>RankedTensorType<span class=p>,</span> MemRefType<span class=p>&gt;</span><span class=p>(</span>
        BufferizeTypeConverter<span class=p>:</span><span class=p>:</span>KeepAsFunctionResult<span class=p>)</span><span class=err>;</span>
</code></pre></div><p>the output will be:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@on_buffers</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
 <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><h3 id=bufferizereturnopconverter>BufferizeReturnOpConverter&nbsp;<a class=headline-hash href=#bufferizereturnopconverter>¶</a></h3><p>When changing the signature of a function, the return operands must match with
the results of the corresponding function if buffer-typed-results have been
configured to be appended to the function arguments list. This matching
consists of two separate steps. First, we have to remove the operands that have
been appended to the argument list as output arguments. Second, we have to
introduce additional copies for each operand. However, since each dialect has
its own dialect-dependent return and copy operations, this conversion pattern
comes with three template parameters which are the original return operation,
target return operation, and copy operation kinds.</p><p>In the following example, two conversion patterns are inserted into the pattern
list. The <code>BufferizeReturnOpConverter</code> is set to replace a standard return
operation with the same operation type.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>patterns<span class=p>-&gt;</span>insert<span class=p>&lt;</span>
  BufferizeFuncOpConverter<span class=p>,</span>
  BufferizeReturnOpConverter
    <span class=p>&lt;</span>mlir<span class=p>:</span><span class=p>:</span>ReturnOp<span class=p>,</span> mlir<span class=p>:</span><span class=p>:</span>ReturnOp<span class=p>,</span> linalg<span class=p>:</span><span class=p>:</span>CopyOp<span class=p>&gt;</span>
                <span class=p>&gt;</span><span class=p>(</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span>
</code></pre></div><p>Consider the following input/output program using a single return:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@on_tensors</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>return</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@on_buffers</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%out</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span> <span class=p>{</span>
  linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%out</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i1</span>
<span class=p>}</span>
</code></pre></div><p>Based on our previously configured <code>BufferizeTypeConverter</code> instance which
requires buffer-typed-function-results to be appended to the function argument
list, the new <code>on_buffers</code> function signature is created. The operands of the
return operation must be adapted with the new function signature. Therefore,
the buffer-typed operand is removed from the operand list of the new return
operation. Instead, a copy operation is inserted right before the return
operation to copy the content of the operand buffer to the target buffer and
yields the output as shown above.</p><h3 id=bufferizecallopconverter>BufferizeCallOpConverter&nbsp;<a class=headline-hash href=#bufferizecallopconverter>¶</a></h3><p>The BufferizeCallOpConverter is a call operation converter that transforms and
matches the operands and results of a call operation with the arguments and
results of the callee. Besides converting operand and result types, it
allocates a buffer for each buffer-based result of the called function that is
appended to the argument list (if buffer typed results have been configured to
be appended to the function arguments list).</p><p>The following piece of code shows a sample call site, based on our previously
configured <code>BufferizeTypeConversion</code>:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>

<span class=kt>func</span> <span class=nf>@caller</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%x</span> <span class=p>=</span> call <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%x</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%out</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%out</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>

<span class=kt>func</span> <span class=nf>@caller</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%out</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  call <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%out</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><h3 id=summarizing-example>Summarizing Example&nbsp;<a class=headline-hash href=#summarizing-example>¶</a></h3><p>To summarize all preparation converters, the following sample is a complete
listing of an input IR program and its output after applying all converters:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span>
<span class=p>}</span>

<span class=kt>func</span> <span class=nf>@caller</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%x</span> <span class=p>=</span> call <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%x</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span><span class=k>i1</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@callee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;test.make_tuple&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;test.get_tuple_element&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;test.get_tuple_element&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
  linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i1</span>
<span class=p>}</span>
<span class=kt>func</span> <span class=nf>@caller</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;test.make_tuple&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;test.get_tuple_element&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;test.get_tuple_element&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
  <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%4</span> <span class=p>=</span> call <span class=nf>@callee</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
  <span class=nv>%5</span> <span class=p>=</span> <span class=s>&#34;test.make_tuple&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
  <span class=nv>%6</span> <span class=p>=</span> <span class=s>&#34;test.get_tuple_element&#34;</span><span class=p>(</span><span class=nv>%5</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%7</span> <span class=p>=</span> <span class=s>&#34;test.get_tuple_element&#34;</span><span class=p>(</span><span class=nv>%5</span><span class=p>)</span> <span class=p>{</span><span class=nl>index =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>tuple<span class=p>&lt;</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
  linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%6</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>5x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%7</span> <span class=p>:</span> <span class=k>i1</span>
<span class=p>}</span>
</code></pre></div><h2 id=buffer-deallocation---internal-functionality>Buffer Deallocation - Internal Functionality&nbsp;<a class=headline-hash href=#buffer-deallocation---internal-functionality>¶</a></h2><p>This section covers the internal functionality of the BufferDeallocation
transformation. The transformation consists of several passes. The main pass
called BufferDeallocation can be applied via “-buffer-deallocation” on MLIR
programs. Currently, there are three optimization passes, that move allocs and
convert AllocOps to AllocaOps, if possible. The first and second pass can be
applied using “-buffer-hoisting” or “-buffer-loop-hoisting”, the third one
using “-promote-buffers-to-stack”. However, these optimizations must be applied
before using the BufferDeallocation pass.</p><h3 id=requirements>Requirements&nbsp;<a class=headline-hash href=#requirements>¶</a></h3><p>In order to use BufferDeallocation on an arbitrary dialect, several
control-flow interfaces have to be implemented when using custom operations.
This is particularly important to understand the implicit control-flow
dependencies between different parts of the input program. Without implementing
the following interfaces, control-flow relations cannot be discovered properly
and the resulting program can become invalid:</p><ul><li>Branch-like terminators should implement the <code>BranchOpInterface</code> to query and
manipulate associated operands.</li><li>Operations involving structured control flow have to implement the
<code>RegionBranchOpInterface</code> to model inter-region control flow.</li><li>Terminators yielding values to their parent operation (in particular in the
scope of nested regions within <code>RegionBranchOpInterface</code>-based operations),
should implement the <code>ReturnLike</code> trait to represent logical “value returns”.</li></ul><p>Example dialects that are fully compatible are the “std” and “scf” dialects
with respect to all implemented interfaces.</p><h3 id=detection-of-buffer-allocations>Detection of Buffer Allocations&nbsp;<a class=headline-hash href=#detection-of-buffer-allocations>¶</a></h3><p>The first step of the BufferDeallocation transformation is to identify
manageable allocation operations that implement the <code>SideEffects</code> interface.
Furthermore, these ops need to apply the effect <code>MemoryEffects::Allocate</code> to a
particular result value while not using the resource
<code>SideEffects::AutomaticAllocationScopeResource</code> (since it is currently reserved
for allocations, like <code>Alloca</code> that will be automatically deallocated by a
parent scope). Allocations that have not been detected in this phase will not
be tracked internally, and thus, not deallocated automatically. However,
BufferDeallocation is fully compatible with “hybrid” setups in which tracked
and untracked allocations are mixed:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@mixedAllocation</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
   <span class=nv>%0</span> <span class=p>=</span> alloca<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// aliases: %2
</span><span class=c></span>   <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// aliases: %2
</span><span class=c></span>   cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  use<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>:</span>
  use<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=p>}</span>
</code></pre></div><p>Example of using a conditional branch with alloc and alloca. BufferDeallocation
can detect and handle the different allocation types that might be intermixed.</p><p>Note: the current version does not support allocation operations returning
multiple result buffers.</p><h3 id=conversion-from-allocop-to-allocaop>Conversion from AllocOp to AllocaOp&nbsp;<a class=headline-hash href=#conversion-from-allocop-to-allocaop>¶</a></h3><p>The PromoteBuffersToStack-pass converts AllocOps to AllocaOps, if possible. In
some cases, it can be useful to use such stack-based buffers instead of
heap-based buffers. The conversion is restricted to several constraints like:</p><ul><li>Control flow</li><li>Buffer Size</li><li>Dynamic Size</li></ul><p>If a buffer is leaving a block, we are not allowed to convert it into an
alloca. If the size of the buffer is large, we could convert it, but regarding
stack overflow, it makes sense to limit the size of these buffers and only
convert small ones. The size can be set via a pass option. The current default
value is 1KB. Furthermore, we can not convert buffers with dynamic size, since
the dimension is not known a priori.</p><h3 id=movement-and-placement-of-allocations>Movement and Placement of Allocations&nbsp;<a class=headline-hash href=#movement-and-placement-of-allocations>¶</a></h3><p>Using the buffer hoisting pass, all buffer allocations are moved as far upwards
as possible in order to group them and make upcoming optimizations easier by
limiting the search space. Such a movement is shown in the following graphs.
In addition, we are able to statically free an alloc, if we move it into a
dominator of all of its uses. This simplifies further optimizations (e.g.
buffer fusion) in the future. However, movement of allocations is limited by
external data dependencies (in particular in the case of allocations of
dynamically shaped types). Furthermore, allocations can be moved out of nested
regions, if necessary. In order to move allocations to valid locations with
respect to their uses only, we leverage Liveness information.</p><p>The following code snippets shows a conditional branch before running the
BufferHoisting pass:</p><p><img src=/includes/img/branch_example_pre_move.svg alt=branch_example_pre_move></p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranch</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>:</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// aliases: %1
</span><span class=c></span>  use<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>  <span class=c>// %1 could be %0 or %arg1
</span><span class=c></span>  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Applying the BufferHoisting pass on this program results in the following piece
of code:</p><p><img src=/includes/img/branch_example_post_move.svg alt=branch_example_post_move></p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranch</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// moved to bb0
</span><span class=c></span>  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>:</span>
   use<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
   br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>The alloc is moved from bb2 to the beginning and it is passed as an argument to
bb3.</p><p>The following example demonstrates an allocation using dynamically shaped
types. Due to the data dependency of the allocation to %0, we cannot move the
allocation out of bb2 in this case:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranchDynamicType</span><span class=p>(</span>
  <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
  <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>:</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>   <span class=c>// cannot be moved upwards to the data
</span><span class=c></span>                                   <span class=c>// dependency to %0
</span><span class=c></span>  use<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><h3 id=introduction-of-copies>Introduction of Copies&nbsp;<a class=headline-hash href=#introduction-of-copies>¶</a></h3><p>In order to guarantee that all allocated buffers are freed properly, we have to
pay attention to the control flow and all potential aliases a buffer allocation
can have. Since not all allocations can be safely freed with respect to their
aliases (see the following code snippet), it is often required to introduce
copies to eliminate them. Consider the following example in which the
allocations have already been placed:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@branch</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// aliases: %2
</span><span class=c></span>  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// resides here for demonstration purposes
</span><span class=c></span>                                <span class=c>// aliases: %2
</span><span class=c></span>  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>:</span>
  use<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=err>…</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>The first alloc can be safely freed after the live range of its post-dominator
block (bb3). The alloc in bb1 has an alias %2 in bb3 that also keeps this
buffer alive until the end of bb3. Since we cannot determine the actual
branches that will be taken at runtime, we have to ensure that all buffers are
freed correctly in bb3 regardless of the branches we will take to reach the
exit block. This makes it necessary to introduce a copy for %2, which allows us
to free %alloc0 in bb0 and %alloc1 in bb1. Afterwards, we can continue
processing all aliases of %2 (none in this case) and we can safely free %2 at
the end of the sample program. This sample demonstrates that not all
allocations can be safely freed in their associated post-dominator blocks.
Instead, we have to pay attention to all of their aliases.</p><p>Applying the BufferDeallocation pass to the program above yields the following
result:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@branch</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// temp copy for %1
</span><span class=c></span>  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// %1 can be safely freed here
</span><span class=c></span>  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>:</span>
  use<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
  <span class=nv>%4</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// temp copy for %0
</span><span class=c></span>  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=err>…</span>
  dealloc <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// free temp buffer %2
</span><span class=c></span>  dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// %0 can be safely freed here
</span><span class=c></span>  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Note that a temporary buffer for %2 was introduced to free all allocations
properly. Note further that the unnecessary allocation of %3 can be easily
removed using one of the post-pass transformations.</p><p>Reconsider the previously introduced sample demonstrating dynamically shaped
types:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranchDynamicType</span><span class=p>(</span>
  <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
  <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>:</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// aliases: %2
</span><span class=c></span>  use<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>In the presence of DSTs, we have to parameterize the allocations with
additional dimension information of the source buffers, we want to copy from.
BufferDeallocation automatically introduces all required operations to extract
dimension specifications and wires them with the associated allocations:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranchDynamicType</span><span class=p>(</span>
  <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
  <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg3</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%0</span> <span class=p>=</span> dim <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>   <span class=c>// dimension operation to parameterize
</span><span class=c></span>                                        <span class=c>// the following temp allocation
</span><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%2</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  use<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
  <span class=nv>%c0_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%4</span> <span class=p>=</span> dim <span class=nv>%3</span><span class=p>,</span> <span class=nv>%c0_0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// dimension operation to parameterize
</span><span class=c></span>                                      <span class=c>// the following temp allocation
</span><span class=c></span>  <span class=nv>%5</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// %3 can be safely freed here
</span><span class=c></span>  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%5</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%6</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%6</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%6</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// %6 can be safely freed here
</span><span class=c></span>  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>BufferDeallocation performs a fix-point iteration taking all aliases of all
tracked allocations into account. We initialize the general iteration process
using all tracked allocations and their associated aliases. As soon as we
encounter an alias that is not properly dominated by our allocation, we mark
this alias as <em>critical</em> (needs to be freed and tracked by the internal
fix-point iteration). The following sample demonstrates the presence of
critical and non-critical aliases:</p><p><img src=/includes/img/nested_branch_example_pre_move.svg alt=nested_branch_example_pre_move></p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranchDynamicTypeNested</span><span class=p>(</span>
  <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
  <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>  <span class=c>// aliases: %3, %4
</span><span class=c></span>  <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>:</span>
  br <span class=nl>^bb6</span><span class=p>(</span><span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>   <span class=c>// cannot be moved upwards due to the data
</span><span class=c></span>                                   <span class=c>// dependency to %0
</span><span class=c></span>                                   <span class=c>// aliases: %2, %3, %4
</span><span class=c></span>  use<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb3</span><span class=p>,</span> <span class=nl>^bb4
</span><span class=nl></span><span class=nl>^bb3</span><span class=p>:</span>
  br <span class=nl>^bb5</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb4</span><span class=p>:</span>
  br <span class=nl>^bb5</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb5</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>  <span class=c>// non-crit. alias of %1, since %1 dominates %2
</span><span class=c></span>  br <span class=nl>^bb6</span><span class=p>(</span><span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb6</span><span class=p>(</span><span class=nv>%3</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>  <span class=c>// crit. alias of %arg1 and %2 (in other words %1)
</span><span class=c></span>  br <span class=nl>^bb7</span><span class=p>(</span><span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb7</span><span class=p>(</span><span class=nv>%4</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>  <span class=c>// non-crit. alias of %3, since %3 dominates %4
</span><span class=c></span>  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%4</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Applying BufferDeallocation yields the following output:</p><p><img src=/includes/img/nested_branch_example_post_move.svg alt=nested_branch_example_post_move></p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@condBranchDynamicTypeNested</span><span class=p>(</span>
  <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
  <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%arg3</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg3</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span>
<span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%d0</span> <span class=p>=</span> dim <span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%5</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%d0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// temp buffer required due to alias %3
</span><span class=c></span>  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  br <span class=nl>^bb6</span><span class=p>(</span><span class=nv>%5</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  use<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
  cond_br <span class=nv>%arg0</span><span class=p>,</span> <span class=nl>^bb3</span><span class=p>,</span> <span class=nl>^bb4
</span><span class=nl></span><span class=nl>^bb3</span><span class=p>:</span>
  br <span class=nl>^bb5</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb4</span><span class=p>:</span>
  br <span class=nl>^bb5</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb5</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=nv>%c0_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%d1</span> <span class=p>=</span> dim <span class=nv>%2</span><span class=p>,</span> <span class=nv>%c0_0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%6</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%d1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// temp buffer required due to alias %3
</span><span class=c></span>  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%6</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
  br <span class=nl>^bb6</span><span class=p>(</span><span class=nv>%6</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb6</span><span class=p>(</span><span class=nv>%3</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  br <span class=nl>^bb7</span><span class=p>(</span><span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
<span class=nl>^bb7</span><span class=p>(</span><span class=nv>%4</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%4</span><span class=p>,</span> <span class=nv>%arg2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// free %3, since %4 is a non-crit. alias of %3
</span><span class=c></span>  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Since %3 is a critical alias, BufferDeallocation introduces an additional
temporary copy in all predecessor blocks. %3 has an additional (non-critical)
alias %4 that extends the live range until the end of bb7. Therefore, we can
free %3 after its last use, while taking all aliases into account. Note that %4
does not need to be freed, since we did not introduce a copy for it.</p><p>The actual introduction of buffer copies is done after the fix-point iteration
has been terminated and all critical aliases have been detected. A critical
alias can be either a block argument or another value that is returned by an
operation. Copies for block arguments are handled by analyzing all predecessor
blocks. This is primarily done by querying the <code>BranchOpInterface</code> of the
associated branch terminators that can jump to the current block. Consider the
following example which involves a simple branch and the critical block
argument %2:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  custom<span class=p>.</span>br <span class=nl>^bb1</span><span class=p>(</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span> <span class=nv>%0</span><span class=p>,</span> <span class=p>:</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  custom<span class=p>.</span>br <span class=nl>^bb1</span><span class=p>(</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=p>:</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
<span class=nl>^bb1</span><span class=p>(</span><span class=nv>%2</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>:</span>
  <span class=p>.</span><span class=p>.</span><span class=p>.</span>
</code></pre></div><p>The <code>BranchOpInterface</code> allows us to determine the actual values that will be
passed to block bb1 and its argument %2 by analyzing its predecessor blocks.
Once we have resolved the values %0 and %1 (that are associated with %2 in this
sample), we can introduce a temporary buffer and clone its contents into the
new buffer. Afterwards, we rewire the branch operands to use the newly
allocated buffer instead. However, blocks can have implicitly defined
predecessors by parent ops that implement the <code>RegionBranchOpInterface</code>. This
can be the case if this block argument belongs to the entry block of a region.
In this setting, we have to identify all predecessor regions defined by the
parent operation. For every region, we need to get all terminator operations
implementing the <code>ReturnLike</code> trait, indicating that they can branch to our
current block. Finally, we can use a similar functionality as described above
to add the temporary copy. This time, we can modify the terminator operands
directly without touching a high-level interface.</p><p>Consider the following inner-region control-flow sample that uses an imaginary
“custom.region_if” operation. It either executes the “then” or “else” region
and always continues to the “join” region. The “custom.region_if_yield”
operation returns a result to the parent operation. This sample demonstrates
the use of the <code>RegionBranchOpInterface</code> to determine predecessors in order to
infer the high-level control flow:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@inner_region_control_flow</span><span class=p>(</span>
  <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> custom<span class=p>.</span>region_if <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
   then<span class=p>(</span><span class=nv>%arg2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>  <span class=c>// aliases: %arg4, %1
</span><span class=c></span>    custom<span class=p>.</span>region_if_yield <span class=nv>%arg2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span> else<span class=p>(</span><span class=nv>%arg3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>  <span class=c>// aliases: %arg4, %1
</span><span class=c></span>    custom<span class=p>.</span>region_if_yield <span class=nv>%arg3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span> join<span class=p>(</span><span class=nv>%arg4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>  <span class=c>// aliases: %1
</span><span class=c></span>    custom<span class=p>.</span>region_if_yield <span class=nv>%arg4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p><img src=/includes/img/region_branch_example_pre_move.svg alt=region_branch_example_pre_move></p><p>Non-block arguments (other values) can become aliases when they are returned by
dialect-specific operations. BufferDeallocation supports this behavior via the
<code>RegionBranchOpInterface</code>. Consider the following example that uses an “scf.if”
operation to determine the value of %2 at runtime which creates an alias:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@nested_region_control_flow</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%2</span> <span class=p>=</span> scf<span class=p>.</span>if <span class=nv>%0</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
    scf<span class=p>.</span>yield <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>   <span class=c>// %2 will be an alias of %1
</span><span class=c></span>  <span class=p>}</span> else <span class=p>{</span>
    <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// nested allocation in a div.
</span><span class=c></span>                                                <span class=c>// branch
</span><span class=c></span>    use<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
    scf<span class=p>.</span>yield <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>   <span class=c>// %2 will be an alias of %1
</span><span class=c></span>  <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>In this example, a dealloc is inserted to release the buffer within the else
block since it cannot be accessed by the remainder of the program. Accessing
the <code>RegionBranchOpInterface</code>, allows us to infer that %2 is a non-critical
alias of %1 which does not need to be tracked.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@nested_region_control_flow</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
    <span class=nv>%0</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>index</span>
    <span class=nv>%1</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%2</span> <span class=p>=</span> scf<span class=p>.</span>if <span class=nv>%0</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
      scf<span class=p>.</span>yield <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=p>}</span> else <span class=p>{</span>
      <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
      use<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
      dealloc <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// %3 can be safely freed here
</span><span class=c></span>      scf<span class=p>.</span>yield <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=p>}</span>
    <span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Analogous to the previous case, we have to detect all terminator operations in
all attached regions of “scf.if” that provides a value to its parent operation
(in this sample via scf.yield). Querying the <code>RegionBranchOpInterface</code> allows
us to determine the regions that “return” a result to their parent operation.
Like before, we have to update all <code>ReturnLike</code> terminators as described above.
Reconsider a slightly adapted version of the “custom.region_if” example from
above that uses a nested allocation:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@inner_region_control_flow_div</span><span class=p>(</span>
  <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> custom<span class=p>.</span>region_if <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
   then<span class=p>(</span><span class=nv>%arg2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>  <span class=c>// aliases: %arg4, %1
</span><span class=c></span>    custom<span class=p>.</span>region_if_yield <span class=nv>%arg2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span> else<span class=p>(</span><span class=nv>%arg3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%2</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// aliases: %arg4, %1
</span><span class=c></span>    custom<span class=p>.</span>region_if_yield <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span> join<span class=p>(</span><span class=nv>%arg4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>  <span class=c>// aliases: %1
</span><span class=c></span>    custom<span class=p>.</span>region_if_yield <span class=nv>%arg4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span>
  <span class=kt>return</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Since the allocation %2 happens in a divergent branch and cannot be safely
deallocated in a post-dominator, %arg4 will be considered a critical alias.
Furthermore, %arg4 is returned to its parent operation and has an alias %1.
This causes BufferDeallocation to introduce additional copies:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@inner_region_control_flow_div</span><span class=p>(</span>
  <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> custom<span class=p>.</span>region_if <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span>
   then<span class=p>(</span><span class=nv>%arg2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>  <span class=c>// determine dimension extents for temp allocation
</span><span class=c></span>    <span class=nv>%2</span> <span class=p>=</span> dim <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%c1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
    <span class=nv>%3</span> <span class=p>=</span> dim <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%4</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// temp buffer required due to critic.
</span><span class=c></span>                                          <span class=c>// alias %arg4
</span><span class=c></span>    linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    custom<span class=p>.</span>region_if_yield <span class=nv>%4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span> else<span class=p>(</span><span class=nv>%arg3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%2</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>  <span class=c>// determine dimension extents for temp allocation
</span><span class=c></span>    <span class=nv>%3</span> <span class=p>=</span> dim <span class=nv>%2</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%c1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
    <span class=nv>%4</span> <span class=p>=</span> dim <span class=nv>%2</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%5</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// temp buffer required due to critic.
</span><span class=c></span>                                          <span class=c>// alias %arg4
</span><span class=c></span>    linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    dealloc <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    custom<span class=p>.</span>region_if_yield <span class=nv>%5</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span> join<span class=p>(</span><span class=nv>%arg4</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>%c0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>  <span class=c>// determine dimension extents for temp allocation
</span><span class=c></span>    <span class=nv>%2</span> <span class=p>=</span> dim <span class=nv>%arg4</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%c1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
    <span class=nv>%3</span> <span class=p>=</span> dim <span class=nv>%arg4</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=nv>%4</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// this allocation will be removed by
</span><span class=c></span>                                          <span class=c>// applying the copy removal pass
</span><span class=c></span>    linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%arg4</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    dealloc <span class=nv>%arg4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
    custom<span class=p>.</span>region_if_yield <span class=nv>%4</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
   <span class=p>}</span>
  dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// %0 can be safely freed here
</span><span class=c></span>  <span class=kt>return</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><h3 id=placement-of-deallocs>Placement of Deallocs&nbsp;<a class=headline-hash href=#placement-of-deallocs>¶</a></h3><p>After introducing allocs and copies, deallocs have to be placed to free
allocated memory and avoid memory leaks. The deallocation needs to take place
after the last use of the given value. The position can be determined by
calculating the common post-dominator of all values using their remaining
non-critical aliases. A special-case is the presence of back edges: since such
edges can cause memory leaks when a newly allocated buffer flows back to
another part of the program. In these cases, we need to free the associated
buffer instances from the previous iteration by inserting additional deallocs.</p><p>Consider the following “scf.for” use case containing a nested structured
control-flow if:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@loop_nested_if</span><span class=p>(</span>
  <span class=nv>%lb</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%ub</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%step</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%buf</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%res</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> scf<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=nv>%lb</span> to <span class=nv>%ub</span> step <span class=nv>%step</span>
    iter_args<span class=p>(</span><span class=nv>%iterBuf</span> <span class=p>=</span> <span class=nv>%buf</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
    <span class=nv>%1</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%ub</span> <span class=p>:</span> <span class=k>index</span>
    <span class=nv>%2</span> <span class=p>=</span> scf<span class=p>.</span>if <span class=nv>%1</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=c>// makes %2 a critical alias due to a
</span><span class=c></span>                                    <span class=c>// divergent allocation
</span><span class=c></span>      use<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
      scf<span class=p>.</span>yield <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=p>}</span> else <span class=p>{</span>
      scf<span class=p>.</span>yield <span class=nv>%iterBuf</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=p>}</span>
    scf<span class=p>.</span>yield <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=p>}</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%res</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>In this example, the <em>then</em> branch of the nested “scf.if” operation returns a
newly allocated buffer.</p><p>Since this allocation happens in the scope of a divergent branch, %2 becomes a
critical alias that needs to be handled. As before, we have to insert
additional copies to eliminate this alias using copies of %3 and %iterBuf. This
guarantees that %2 will be a newly allocated buffer that is returned in each
iteration. However, “returning” %2 to its alias %iterBuf turns %iterBuf into a
critical alias as well. In other words, we have to create a copy of %2 to pass
it to %iterBuf. Since this jump represents a back edge, and %2 will always be a
new buffer, we have to free the buffer from the previous iteration to avoid
memory leaks:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@loop_nested_if</span><span class=p>(</span>
  <span class=nv>%lb</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%ub</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%step</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span>
  <span class=nv>%buf</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span>
  <span class=nv>%res</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%4</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%buf</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  <span class=nv>%0</span> <span class=p>=</span> scf<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=nv>%lb</span> to <span class=nv>%ub</span> step <span class=nv>%step</span>
    iter_args<span class=p>(</span><span class=nv>%iterBuf</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
    <span class=nv>%1</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%ub</span> <span class=p>:</span> <span class=k>index</span>
    <span class=nv>%2</span> <span class=p>=</span> scf<span class=p>.</span>if <span class=nv>%1</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
      <span class=nv>%3</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// makes %2 a critical alias
</span><span class=c></span>      use<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
      <span class=nv>%5</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// temp copy due to crit. alias %2
</span><span class=c></span>      <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
      dealloc <span class=nv>%3</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
      scf<span class=p>.</span>yield <span class=nv>%5</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=p>}</span> else <span class=p>{</span>
      <span class=nv>%6</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// temp copy due to crit. alias %2
</span><span class=c></span>      <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%iterBuf</span><span class=p>,</span> <span class=nv>%6</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
      scf<span class=p>.</span>yield <span class=nv>%6</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
    <span class=p>}</span>
    <span class=nv>%7</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// temp copy due to crit. alias %iterBuf
</span><span class=c></span>    <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%7</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
    dealloc <span class=nv>%2</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
    dealloc <span class=nv>%iterBuf</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// free backedge iteration variable
</span><span class=c></span>    scf<span class=p>.</span>yield <span class=nv>%7</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=p>}</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%res</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=c>// free temp copy %0
</span><span class=c></span>  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Example for loop-like control flow. The CFG contains back edges that have to be
handled to avoid memory leaks. The bufferization is able to free the backedge
iteration variable %iterBuf.</p><h3 id=private-analyses-implementations>Private Analyses Implementations&nbsp;<a class=headline-hash href=#private-analyses-implementations>¶</a></h3><p>The BufferDeallocation transformation relies on one primary control-flow
analysis: BufferPlacementAliasAnalysis. Furthermore, we also use dominance and
liveness to place and move nodes. The liveness analysis determines the live
range of a given value. Within this range, a value is alive and can or will be
used in the course of the program. After this range, the value is dead and can
be discarded - in our case, the buffer can be freed. To place the allocs, we
need to know from which position a value will be alive. The allocs have to be
placed in front of this position. However, the most important analysis is the
alias analysis that is needed to introduce copies and to place all
deallocations.</p><h2 id=post-phase>Post Phase&nbsp;<a class=headline-hash href=#post-phase>¶</a></h2><p>In order to limit the complexity of the BufferDeallocation transformation, some
tiny code-polishing/optimization transformations are not applied on-the-fly
during placement. Currently, there is only the CopyRemoval transformation to
remove unnecessary copy and allocation operations.</p><p>Note: further transformations might be added to the post-pass phase in the
future.</p><h3 id=copyremoval-pass>CopyRemoval Pass&nbsp;<a class=headline-hash href=#copyremoval-pass>¶</a></h3><p>A common pattern that arises during placement is the introduction of
unnecessary temporary copies that are used instead of the original source
buffer. For this reason, there is a post-pass transformation that removes these
allocations and copies via <code>-copy-removal</code>. This pass, besides removing
unnecessary copy operations, will also remove the dead allocations and their
corresponding deallocation operations. The CopyRemoval pass can currently be
applied to operations that implement the <code>CopyOpInterface</code> in any of these two
situations which are</p><ul><li>reusing the source buffer of the copy operation.</li><li>reusing the target buffer of the copy operation.</li></ul><h3 id=reusing-the-source-buffer-of-the-copy-operation>Reusing the Source Buffer of the Copy Operation&nbsp;<a class=headline-hash href=#reusing-the-source-buffer-of-the-copy-operation>¶</a></h3><p>In this case, the source of the copy operation can be used instead of target.
The unused allocation and deallocation operations that are defined for this
copy operation are also removed. Here is a working example generated by the
BufferDeallocation pass that allocates a buffer with dynamic size. A deeper
analysis of this sample reveals that the highlighted operations are redundant
and can be removed.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@dynamic_allocation</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%7</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%c0_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%8</span> <span class=p>=</span> dim <span class=nv>%7</span><span class=p>,</span> <span class=nv>%c0_0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%c1_1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%9</span> <span class=p>=</span> dim <span class=nv>%7</span><span class=p>,</span> <span class=nv>%c1_1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%10</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%8</span><span class=p>,</span> <span class=nv>%9</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  linalg<span class=p>.</span>copy<span class=p>(</span><span class=nv>%7</span><span class=p>,</span> <span class=nv>%10</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  dealloc <span class=nv>%7</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%10</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@dynamic_allocation</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%7</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%c0_0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%8</span> <span class=p>=</span> dim <span class=nv>%7</span><span class=p>,</span> <span class=nv>%c0_0</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=nv>%c1_1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
  <span class=nv>%9</span> <span class=p>=</span> dim <span class=nv>%7</span><span class=p>,</span> <span class=nv>%c1_1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span> <span class=nv>%7</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>In this case, the additional copy %10 can be replaced with its original source
buffer %7. This also applies to the associated dealloc operation of %7.</p><p>To limit the complexity of this transformation, it only removes copy operations
when the following constraints are met:</p><ul><li>The copy operation, the defining operation for the target value, and the
deallocation of the source value lie in the same block.</li><li>There are no users/aliases of the target value between the defining operation
of the target value and its copy operation.</li><li>There are no users/aliases of the source value between its associated copy
operation and the deallocation of the source value.</li></ul><h3 id=reusing-the-target-buffer-of-the-copy-operation>Reusing the Target Buffer of the Copy Operation&nbsp;<a class=headline-hash href=#reusing-the-target-buffer-of-the-copy-operation>¶</a></h3><p>In this case, the target buffer of the copy operation can be used instead of
its source. The unused allocation and deallocation operations that are defined
for this copy operation are also removed.</p><p>Consider the following example where a generic linalg operation writes the
result to %temp and then copies %temp to %result. However, these two operations
can be merged into a single step. Copy removal removes the copy operation and
%temp, and replaces the uses of %temp with %result:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@reuseTarget</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%result</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>{</span>
  <span class=nv>%temp</span> <span class=p>=</span> alloc<span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  linalg<span class=p>.</span>generic <span class=p>{</span>
    <span class=nl>args_in =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span>
    <span class=nl>args_out =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span>
    <span class=nl>indexing_maps =</span> <span class=p>[</span><span class=nv>#map0</span><span class=p>,</span> <span class=nv>#map0</span><span class=p>]</span><span class=p>,</span>
    <span class=nl>iterator_types =</span> <span class=p>[</span><span class=s>&#34;parallel&#34;</span><span class=p>]</span><span class=p>}</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%temp</span> <span class=p>{</span>
  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%gen2_arg0</span><span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%gen2_arg1</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span><span class=p>:</span>
    <span class=nv>%tmp2</span> <span class=p>=</span> exp <span class=nv>%gen2_arg0</span> <span class=p>:</span> <span class=k>f32</span>
    linalg<span class=p>.</span>yield <span class=nv>%tmp2</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=p>}</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=s>&#34;linalg.copy&#34;</span><span class=p>(</span><span class=nv>%temp</span><span class=p>,</span> <span class=nv>%result</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
  dealloc <span class=nv>%temp</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Will be transformed to:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@reuseTarget</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%result</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span><span class=p>{</span>
  linalg<span class=p>.</span>generic <span class=p>{</span>
    <span class=nl>args_in =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span>
    <span class=nl>args_out =</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span>
    <span class=nl>indexing_maps =</span> <span class=p>[</span><span class=nv>#map0</span><span class=p>,</span> <span class=nv>#map0</span><span class=p>]</span><span class=p>,</span>
    <span class=nl>iterator_types =</span> <span class=p>[</span><span class=s>&#34;parallel&#34;</span><span class=p>]</span><span class=p>}</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%result</span> <span class=p>{</span>
  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%gen2_arg0</span><span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%gen2_arg1</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span><span class=p>:</span>
    <span class=nv>%tmp2</span> <span class=p>=</span> exp <span class=nv>%gen2_arg0</span> <span class=p>:</span> <span class=k>f32</span>
    linalg<span class=p>.</span>yield <span class=nv>%tmp2</span> <span class=p>:</span> <span class=k>f32</span>
  <span class=p>}</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
  <span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>Like before, several constraints to use the transformation apply:</p><ul><li>The copy operation, the defining operation of the source value, and the
deallocation of the source value lie in the same block.</li><li>There are no users/aliases of the target value between the defining operation
of the source value and the copy operation.</li><li>There are no users/aliases of the source value between the copy operation and
the deallocation of the source value.</li></ul><h2 id=known-limitations>Known Limitations&nbsp;<a class=headline-hash href=#known-limitations>¶</a></h2><p>BufferDeallocation introduces additional copies using allocations from the
“std” dialect (“std.alloc”). Analogous, all deallocations use the “std”
dialect-free operation “std.dealloc”. The actual copy process is realized using
“linalg.copy”. Furthermore, buffers are essentially immutable after their
creation in a block. Another limitations are known in the case using
unstructered control flow.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/EDSC/ title="Background: declarative builders API"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Background: declarative builders API</a>
<a class="nav nav-next" href=/docs/ConversionToLLVMDialect/ title="Conversion to the LLVM Dialect">Next - Conversion to the LLVM Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Builtin/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/AVX512/>'avx512' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmNeon/>'llvm_arm_neon' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmSve/>'llvm_arm_sve' Dialect</a></li><li><a href=/docs/Dialects/LLVMAVX512/>'llvm_avx512' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/TensorPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li class=active><a href=/docs/Bufferization/>Bufferization on MLIR</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>