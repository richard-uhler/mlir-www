<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Pattern Rewriting : Generic DAG-to-DAG Rewriting - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/PatternRewriter/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Pattern Rewriting : Generic DAG-to-DAG Rewriting</h1><p><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#defining-patterns>Defining Patterns</a><ul><li><a href=#benefit>Benefit</a></li><li><a href=#root-operation-name-optional>Root Operation Name (Optional)</a></li><li><a href=#match-and-rewrite-implementation>match and rewrite implementation</a></li><li><a href=#pattern-rewriter>Pattern Rewriter</a></li></ul></li><li><a href=#pattern-application>Pattern Application</a></li><li><a href=#common-pattern-drivers>Common Pattern Drivers</a><ul><li><a href=#dialect-conversion-driver>Dialect Conversion Driver</a></li><li><a href=#greedy-pattern-rewrite-driver>Greedy Pattern Rewrite Driver</a></li></ul></li></ul></nav><p>This document details the design and API of the pattern rewriting infrastructure
present in MLIR, a general DAG-to-DAG transformation framework. This framework
is widely used throughout MLIR for canonicalization, conversion, and general
transformation.</p><p>For an introduction to DAG-to-DAG transformation, and the rationale behind this
framework please take a look at the
<a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Rationale</a>
.</p><h2 id=introduction>Introduction&nbsp;<a class=headline-hash href=#introduction>¶</a></h2><p>The pattern rewriting framework can largely be decomposed into two parts:
Pattern Definition and Pattern Application.</p><h2 id=defining-patterns>Defining Patterns&nbsp;<a class=headline-hash href=#defining-patterns>¶</a></h2><p>Patterns are defined by inheriting from the <code>RewritePattern</code> class. This class
represents the base class of all rewrite patterns within MLIR, and is comprised
of the following components:</p><h3 id=benefit>Benefit&nbsp;<a class=headline-hash href=#benefit>¶</a></h3><p>This is the expected benefit of applying a given pattern. This benefit is static
upon construction of the pattern, but may be computed dynamically at pattern
initialization time, e.g. allowing the benefit to be derived from domain
specific information (like the target architecture). This limitation allows for
performing pattern fusion and compiling patterns into an efficient state
machine, and
<a href="https://dl.acm.org/citation.cfm?id=3179501">Thier, Ertl, and Krall</a>
have shown
that match predicates eliminate the need for dynamically computed costs in
almost all cases: you can simply instantiate the same pattern one time for each
possible cost and use the predicate to guard the match.</p><h3 id=root-operation-name-optional>Root Operation Name (Optional)&nbsp;<a class=headline-hash href=#root-operation-name-optional>¶</a></h3><p>The name of the root operation that this pattern matches against. If specified,
only operations with the given root name will be provided to the <code>match</code> and
<code>rewrite</code> implementation. If not specified, any operation type may be provided.
The root operation name should be provided whenever possible, because it
simplifies the analysis of patterns when applying a cost model. To match any
operation type, a special tag must be provided to make the intent explicit:
<code>MatchAnyOpTypeTag</code>.</p><h3 id=match-and-rewrite-implementation><code>match</code> and <code>rewrite</code> implementation&nbsp;<a class=headline-hash href=#match-and-rewrite-implementation>¶</a></h3><p>This is the chunk of code that matches a given root <code>Operation</code> and performs a
rewrite of the IR. A <code>RewritePattern</code> can specify this implementation either via
separate <code>match</code> and <code>rewrite</code> methods, or via a combined <code>matchAndRewrite</code>
method. When using the combined <code>matchAndRewrite</code> method, no IR mutation should
take place before the match is deemed successful. The combined <code>matchAndRewrite</code>
is useful when non-trivially recomputable information is required by the
matching and rewriting phase. See below for examples:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>MyPattern</span> <span class=o>:</span> <span class=k>public</span> <span class=n>RewritePattern</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// This overload constructs a pattern that only matches operations with the
</span><span class=c1></span>  <span class=c1>/// root name of `MyOp`.
</span><span class=c1></span>  <span class=n>MyPattern</span><span class=p>(</span><span class=n>PatternBenefit</span> <span class=n>benefit</span><span class=p>,</span> <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span>
      <span class=o>:</span> <span class=n>RewritePattern</span><span class=p>(</span><span class=n>MyOp</span><span class=o>:</span><span class=o>:</span><span class=n>getOperationName</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>benefit</span><span class=p>,</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>
  <span class=c1>/// This overload constructs a pattern that matches any operation type.
</span><span class=c1></span>  <span class=n>MyPattern</span><span class=p>(</span><span class=n>PatternBenefit</span> <span class=n>benefit</span><span class=p>)</span>
      <span class=o>:</span> <span class=n>RewritePattern</span><span class=p>(</span><span class=n>benefit</span><span class=p>,</span> <span class=n>MatchAnyOpTypeTag</span><span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>

  <span class=c1>/// In this section, the `match` and `rewrite` implementation is specified
</span><span class=c1></span>  <span class=c1>/// using the separate hooks.
</span><span class=c1></span>  <span class=n>LogicalResult</span> <span class=nf>match</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
    <span class=c1>// The `match` method returns `success()` if the pattern is a match, failure
</span><span class=c1></span>    <span class=c1>// otherwise.
</span><span class=c1></span>    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
  <span class=kt>void</span> <span class=nf>rewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// The `rewrite` method performs mutations on the IR rooted at `op` using
</span><span class=c1></span>    <span class=c1>// the provided rewriter. All mutations must go through the provided
</span><span class=c1></span>    <span class=c1>// rewriter.
</span><span class=c1></span>  <span class=p>}</span>

  <span class=c1>/// In this section, the `match` and `rewrite` implementation is specified
</span><span class=c1></span>  <span class=c1>/// using a single hook.
</span><span class=c1></span>  <span class=n>LogicalResult</span> <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// The `matchAndRewrite` method performs both the matching and the mutation.
</span><span class=c1></span>    <span class=c1>// Note that the match must reach a successful point before IR mutation may
</span><span class=c1></span>    <span class=c1>// take place.
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></div><h4 id=restrictions>Restrictions&nbsp;<a class=headline-hash href=#restrictions>¶</a></h4><p>Within the <code>match</code> section of a pattern, the following constraints apply:</p><ul><li>No mutation of the IR is allowed.</li></ul><p>Within the <code>rewrite</code> section of a pattern, the following constraints apply:</p><ul><li>All IR mutations, including creation, <em>must</em> be performed by the given
<code>PatternRewriter</code>. This class provides hooks for performing all of the
possible mutations that may take place within a pattern. For example, this
means that an operation should not be erased via its <code>erase</code> method. To
erase an operation, the appropriate <code>PatternRewriter</code> hook (in this case
<code>eraseOp</code>) should be used instead.</li><li>The root operation is required to either be: updated in-place, replaced, or
erased.</li></ul><h3 id=pattern-rewriter>Pattern Rewriter&nbsp;<a class=headline-hash href=#pattern-rewriter>¶</a></h3><p>A <code>PatternRewriter</code> is a special class that allows for a pattern to communicate
with the driver of pattern application. As noted above, <em>all</em> IR mutations,
including creations, are required to be performed via the <code>PatternRewriter</code>
class. This is required because the underlying pattern driver may have state
that would be invalidated when a mutation takes place. Examples of some of the
more prevalent <code>PatternRewriter</code> API is shown below, please refer to the
<a href=https://github.com/llvm/llvm-project/blob/master/mlir/include/mlir/IR/PatternMatch.h#L235>class documentation</a>
for a more up-to-date listing of the available API:</p><ul><li>Erase an Operation : <code>eraseOp</code></li></ul><p>This method erases an operation that either has no results, or whose results are
all known to have no uses.</p><ul><li>Notify why a <code>match</code> failed : <code>notifyMatchFailure</code></li></ul><p>This method allows for providing a diagnostic message within a <code>matchAndRewrite</code>
as to why a pattern failed to match. How this message is displayed back to the
user is determined by the specific pattern driver.</p><ul><li>Replace an Operation : <code>replaceOp</code>/<code>replaceOpWithNewOp</code></li></ul><p>This method replaces an operation&rsquo;s results with a set of provided values, and
erases the operation.</p><ul><li>Update an Operation in-place : <code>(start|cancel|finalize)RootUpdate</code></li></ul><p>This is a collection of methods that provide a transaction-like API for updating
the attributes, location, operands, or successors of an operation in-place
within a pattern. An in-place update transaction is started with
<code>startRootUpdate</code>, and may either be canceled or finalized with
<code>cancelRootUpdate</code> and <code>finalizeRootUpdate</code> respectively. A convenience wrapper,
<code>updateRootInPlace</code>, is provided that wraps a <code>start</code> and <code>finalize</code> around a
callback.</p><ul><li>OpBuilder API</li></ul><p>The <code>PatternRewriter</code> inherits from the <code>OpBuilder</code> class, and thus provides all
of the same functionality present within an <code>OpBuilder</code>. This includes operation
creation, as well as many useful attribute and type construction methods.</p><h2 id=pattern-application>Pattern Application&nbsp;<a class=headline-hash href=#pattern-application>¶</a></h2><p>After a set of patterns have been defined, they are collected and provided to a
specific driver for application. A driver consists of several high levels parts:</p><ul><li>Input <code>OwningRewritePatternList</code></li></ul><p>The input patterns to a driver are provided in the form of an
<code>OwningRewritePatternList</code>. This class provides a simplified API for building a
list of patterns.</p><ul><li>Driver-specific <code>PatternRewriter</code></li></ul><p>To ensure that the driver state does not become invalidated by IR mutations
within the pattern rewriters, a driver must provide a <code>PatternRewriter</code> instance
with the necessary hooks overridden. If a driver does not need to hook into
certain mutations, a default implementation is provided that will perform the
mutation directly.</p><ul><li>Pattern Application and Cost Model</li></ul><p>Each driver is responsible for defining its own operation visitation order as
well as pattern cost model, but the final application is performed via a
<code>PatternApplicator</code> class. This class takes as input the
<code>OwningRewritePatternList</code> and transforms the patterns based upon a provided
cost model. This cost model computes a final benefit for a given pattern, using
whatever driver specific information necessary. After a cost model has been
computed, the driver may begin to match patterns against operations using
<code>PatternApplicator::matchAndRewrite</code>.</p><p>An example is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>MyPattern</span> <span class=o>:</span> <span class=k>public</span> <span class=n>RewritePattern</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=n>MyPattern</span><span class=p>(</span><span class=n>PatternBenefit</span> <span class=n>benefit</span><span class=p>,</span> <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span>
      <span class=o>:</span> <span class=n>RewritePattern</span><span class=p>(</span><span class=n>MyOp</span><span class=o>:</span><span class=o>:</span><span class=n>getOperationName</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>benefit</span><span class=p>,</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Populate the pattern list.
</span><span class=c1></span><span class=kt>void</span> <span class=nf>collectMyPatterns</span><span class=p>(</span><span class=n>OwningRewritePatternList</span> <span class=o>&amp;</span><span class=n>patterns</span><span class=p>,</span> <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>patterns</span><span class=p>.</span><span class=n>insert</span><span class=o>&lt;</span><span class=n>MyPattern</span><span class=o>&gt;</span><span class=p>(</span><span class=cm>/*benefit=*/</span><span class=mi>1</span><span class=p>,</span> <span class=n>ctx</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>/// Define a custom PatternRewriter for use by the driver.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyPatternRewriter</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PatternRewriter</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=n>MyPatternRewriter</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span> <span class=o>:</span> <span class=n>PatternRewriter</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>

  <span class=c1>/// Override the necessary PatternRewriter hooks here.
</span><span class=c1></span><span class=p>}</span><span class=p>;</span>

<span class=c1>/// Apply the custom driver to `op`.
</span><span class=c1></span><span class=kt>void</span> <span class=nf>applyMyPatternDriver</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span>
                          <span class=k>const</span> <span class=n>OwningRewritePatternList</span> <span class=o>&amp;</span><span class=n>patterns</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// Initialize the custom PatternRewriter.
</span><span class=c1></span>  <span class=n>MyPatternRewriter</span> <span class=n>rewriter</span><span class=p>(</span><span class=n>op</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getContext</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Create the applicator and apply our cost model.
</span><span class=c1></span>  <span class=n>PatternApplicator</span> <span class=n>applicator</span><span class=p>(</span><span class=n>patterns</span><span class=p>)</span><span class=p>;</span>
  <span class=n>applicator</span><span class=p>.</span><span class=n>applyCostModel</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=p>(</span><span class=k>const</span> <span class=n>Pattern</span> <span class=o>&amp;</span><span class=n>pattern</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Apply a default cost model.
</span><span class=c1></span>    <span class=c1>// Note: This is just for demonstration, if the default cost model is truly
</span><span class=c1></span>    <span class=c1>//       desired `applicator.applyDefaultCostModel()` should be used
</span><span class=c1></span>    <span class=c1>//       instead.
</span><span class=c1></span>    <span class=k>return</span> <span class=n>pattern</span><span class=p>.</span><span class=n>getBenefit</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span><span class=p>)</span><span class=p>;</span>

  <span class=c1>// Try to match and apply a pattern.
</span><span class=c1></span>  <span class=n>LogicalResult</span> <span class=n>result</span> <span class=o>=</span> <span class=n>applicator</span><span class=p>.</span><span class=n>matchAndRewrite</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=n>rewriter</span><span class=p>)</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>failed</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ... No patterns were applied.
</span><span class=c1></span>  <span class=p>}</span>
  <span class=c1>// ... A pattern was successfully applied.
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h2 id=common-pattern-drivers>Common Pattern Drivers&nbsp;<a class=headline-hash href=#common-pattern-drivers>¶</a></h2><p>MLIR provides several common pattern drivers that serve a variety of different
use cases.</p><h3 id=dialect-conversion-driver>Dialect Conversion Driver&nbsp;<a class=headline-hash href=#dialect-conversion-driver>¶</a></h3><p>This driver provides a framework in which to perform operation conversions
between, and within dialects using a concept of &ldquo;legality&rdquo;. This framework
allows for transforming illegal operations to those supported by a provided
conversion target, via a set of pattern-based operation rewriting patterns. This
framework also provides support for type conversions. More information on this
driver can be found
<a href=DialectConversion.nd>here</a>
.</p><h3 id=greedy-pattern-rewrite-driver>Greedy Pattern Rewrite Driver&nbsp;<a class=headline-hash href=#greedy-pattern-rewrite-driver>¶</a></h3><p>This driver performs a post order traversal over the provided operations and
greedily applies the patterns that locally have the most benefit. The benefit of
a pattern is decided solely by the benefit specified on the pattern, and the
relative order of the pattern within the pattern list (when two patterns have
the same local benefit). Patterns are iteratively applied to operations until a
fixed point is reached, at which point the driver finishes. This driver may be
used via the following: <code>applyPatternsAndFoldGreedily</code> and
<code>applyOpPatternsAndFold</code>. The latter of which only applies patterns to the
provided operation, and will not traverse the IR.</p><p>Note: This driver is the one used by the
<a href=/docs/Canonicalization/>canonicalization</a>
<a href=/docs/Passes/#-canonicalize-canonicalize-operations>pass</a>
in MLIR.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Passes/ title=Passes><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Passes</a>
<a class="nav nav-next" href=/docs/Quantization/ title=Quantization>Next - Quantization <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Builtin/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/AVX512/>'avx512' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmNeon/>'llvm_arm_neon' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmSve/>'llvm_arm_sve' Dialect</a></li><li><a href=/docs/Dialects/LLVMAVX512/>'llvm_avx512' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/TensorPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/Bufferization/>Bufferization on MLIR</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li class=active><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>