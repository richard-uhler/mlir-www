<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'pdl_interp' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'pdl_interp' Dialect</h1><p>Interpreted pattern execution dialect
The PDL Interpreter dialect provides a lower level abstraction compared to
the PDL dialect, and is targeted towards low level optimization and
interpreter code generation. The dialect operations encapsulates
low-level pattern match and rewrite &ldquo;primitives&rdquo;, such as navigating the
IR (Operation::getOperand), creating new operations (OpBuilder::create),
etc. Many of the operations within this dialect also fuse branching control
flow with some form of a predicate comparison operation. This type of fusion
reduces the amount of work that an interpreter must do when executing.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#pdl_interpapply_constraint-mlirpdl_interpapplyconstraintop>pdl_interp.apply_constraint (::mlir::pdl_interp::ApplyConstraintOp)</a></li><li><a href=#pdl_interpapply_rewrite-mlirpdl_interpapplyrewriteop>pdl_interp.apply_rewrite (::mlir::pdl_interp::ApplyRewriteOp)</a></li><li><a href=#pdl_interpare_equal-mlirpdl_interpareequalop>pdl_interp.are_equal (::mlir::pdl_interp::AreEqualOp)</a></li><li><a href=#pdl_interpbranch-mlirpdl_interpbranchop>pdl_interp.branch (::mlir::pdl_interp::BranchOp)</a></li><li><a href=#pdl_interpcheck_attribute-mlirpdl_interpcheckattributeop>pdl_interp.check_attribute (::mlir::pdl_interp::CheckAttributeOp)</a></li><li><a href=#pdl_interpcheck_operand_count-mlirpdl_interpcheckoperandcountop>pdl_interp.check_operand_count (::mlir::pdl_interp::CheckOperandCountOp)</a></li><li><a href=#pdl_interpcheck_operation_name-mlirpdl_interpcheckoperationnameop>pdl_interp.check_operation_name (::mlir::pdl_interp::CheckOperationNameOp)</a></li><li><a href=#pdl_interpcheck_result_count-mlirpdl_interpcheckresultcountop>pdl_interp.check_result_count (::mlir::pdl_interp::CheckResultCountOp)</a></li><li><a href=#pdl_interpcheck_type-mlirpdl_interpchecktypeop>pdl_interp.check_type (::mlir::pdl_interp::CheckTypeOp)</a></li><li><a href=#pdl_interpcreate_attribute-mlirpdl_interpcreateattributeop>pdl_interp.create_attribute (::mlir::pdl_interp::CreateAttributeOp)</a></li><li><a href=#pdl_interpcreate_native-mlirpdl_interpcreatenativeop>pdl_interp.create_native (::mlir::pdl_interp::CreateNativeOp)</a></li><li><a href=#pdl_interpcreate_operation-mlirpdl_interpcreateoperationop>pdl_interp.create_operation (::mlir::pdl_interp::CreateOperationOp)</a></li><li><a href=#pdl_interpcreate_type-mlirpdl_interpcreatetypeop>pdl_interp.create_type (::mlir::pdl_interp::CreateTypeOp)</a></li><li><a href=#pdl_interperase-mlirpdl_interperaseop>pdl_interp.erase (::mlir::pdl_interp::EraseOp)</a></li><li><a href=#pdl_interpfinalize-mlirpdl_interpfinalizeop>pdl_interp.finalize (::mlir::pdl_interp::FinalizeOp)</a></li><li><a href=#pdl_interpget_attribute-mlirpdl_interpgetattributeop>pdl_interp.get_attribute (::mlir::pdl_interp::GetAttributeOp)</a></li><li><a href=#pdl_interpget_attribute_type-mlirpdl_interpgetattributetypeop>pdl_interp.get_attribute_type (::mlir::pdl_interp::GetAttributeTypeOp)</a></li><li><a href=#pdl_interpget_defining_op-mlirpdl_interpgetdefiningopop>pdl_interp.get_defining_op (::mlir::pdl_interp::GetDefiningOpOp)</a></li><li><a href=#pdl_interpget_operand-mlirpdl_interpgetoperandop>pdl_interp.get_operand (::mlir::pdl_interp::GetOperandOp)</a></li><li><a href=#pdl_interpget_result-mlirpdl_interpgetresultop>pdl_interp.get_result (::mlir::pdl_interp::GetResultOp)</a></li><li><a href=#pdl_interpget_value_type-mlirpdl_interpgetvaluetypeop>pdl_interp.get_value_type (::mlir::pdl_interp::GetValueTypeOp)</a></li><li><a href=#pdl_interpinferred_type-mlirpdl_interpinferredtypeop>pdl_interp.inferred_type (::mlir::pdl_interp::InferredTypeOp)</a></li><li><a href=#pdl_interpis_not_null-mlirpdl_interpisnotnullop>pdl_interp.is_not_null (::mlir::pdl_interp::IsNotNullOp)</a></li><li><a href=#pdl_interprecord_match-mlirpdl_interprecordmatchop>pdl_interp.record_match (::mlir::pdl_interp::RecordMatchOp)</a></li><li><a href=#pdl_interpreplace-mlirpdl_interpreplaceop>pdl_interp.replace (::mlir::pdl_interp::ReplaceOp)</a></li><li><a href=#pdl_interpswitch_attribute-mlirpdl_interpswitchattributeop>pdl_interp.switch_attribute (::mlir::pdl_interp::SwitchAttributeOp)</a></li><li><a href=#pdl_interpswitch_operand_count-mlirpdl_interpswitchoperandcountop>pdl_interp.switch_operand_count (::mlir::pdl_interp::SwitchOperandCountOp)</a></li><li><a href=#pdl_interpswitch_operation_name-mlirpdl_interpswitchoperationnameop>pdl_interp.switch_operation_name (::mlir::pdl_interp::SwitchOperationNameOp)</a></li><li><a href=#pdl_interpswitch_result_count-mlirpdl_interpswitchresultcountop>pdl_interp.switch_result_count (::mlir::pdl_interp::SwitchResultCountOp)</a></li><li><a href=#pdl_interpswitch_type-mlirpdl_interpswitchtypeop>pdl_interp.switch_type (::mlir::pdl_interp::SwitchTypeOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=pdl_interpapply_constraint-mlirpdl_interpapplyconstraintop><code>pdl_interp.apply_constraint</code> (::mlir::pdl_interp::ApplyConstraintOp)&nbsp;<a class=headline-hash href=#pdl_interpapply_constraint-mlirpdl_interpapplyconstraintop>¶</a></h3><p>Apply a constraint to a set of positional values</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.apply_constraint` $name ($constParams^)? `(` $args `:` type($args) `)` attr-dict `-&gt;`
              successors
</code></pre><p><code>pdl_interp.apply_constraint</code> operations apply a generic constraint, that
has been registered with the interpreter, with a given set of positional
values. The constraint may have any number of constant parameters. On
success, this operation branches to the true destination, otherwise the
false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Apply `myConstraint` to the entities defined by `input`, `attr`, and
</span><span class=c></span><span class=c>// `op`.
</span><span class=c></span>pdl_interp<span class=p>.</span>apply_constraint <span class=s>&#34;myConstraint&#34;</span><span class=p>[</span><span class=m>42</span><span class=p>,</span> <span class=s>&#34;abc&#34;</span><span class=p>,</span> <span class=k>i32</span><span class=p>]</span><span class=p>(</span><span class=nv>%input</span><span class=p>,</span> <span class=nv>%attr</span><span class=p>,</span> <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>attribute<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>constParams</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>args</code></td><td>Positional Value</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpapply_rewrite-mlirpdl_interpapplyrewriteop><code>pdl_interp.apply_rewrite</code> (::mlir::pdl_interp::ApplyRewriteOp)&nbsp;<a class=headline-hash href=#pdl_interpapply_rewrite-mlirpdl_interpapplyrewriteop>¶</a></h3><p>Invoke and apply an externally registered rewrite method</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.apply_rewrite` $name ($constParams^)? (`(` $args^ `:` type($args) `)`)? `on` $root
              attr-dict
</code></pre><p><code>pdl_interp.apply_rewrite</code> operations invoke an external rewriter that has
been registered with the interpreter to perform the rewrite after a
successful match. The rewrite is passed the root operation being matched, a
set of additional positional arguments generated within the matcher, and a
set of constant parameters.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Rewriter operating solely on the root operation.
</span><span class=c></span>pdl_interp<span class=p>.</span>apply_rewrite <span class=s>&#34;rewriter&#34;</span> on <span class=nv>%root</span>

<span class=c>// Rewriter operating on the root operation along with additional arguments
</span><span class=c></span><span class=c>// from the matcher.
</span><span class=c></span>pdl_interp<span class=p>.</span>apply_rewrite <span class=s>&#34;rewriter&#34;</span><span class=p>(</span><span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span> on <span class=nv>%root</span>

<span class=c>// Rewriter operating on the root operation along with additional arguments
</span><span class=c></span><span class=c>// and constant parameters.
</span><span class=c></span>pdl_interp<span class=p>.</span>apply_rewrite <span class=s>&#34;rewriter&#34;</span><span class=p>[</span><span class=m>42</span><span class=p>]</span><span class=p>(</span><span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span> on <span class=nv>%root</span>
</code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>constParams</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>root</code></td><td>mlir::pdl::OperationType</td></tr><tr><td align=center><code>args</code></td><td>Positional Value</td></tr></tbody></table><h3 id=pdl_interpare_equal-mlirpdl_interpareequalop><code>pdl_interp.are_equal</code> (::mlir::pdl_interp::AreEqualOp)&nbsp;<a class=headline-hash href=#pdl_interpare_equal-mlirpdl_interpareequalop>¶</a></h3><p>Check if two positional values are equivalent</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.are_equal` operands `:` type($lhs) attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.are_equal</code> operations compare two positional values for
equality. On success, this operation branches to the true destination,
otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>are_equal <span class=nv>%result1</span><span class=p>,</span> <span class=nv>%result2</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>Positional Value</td></tr><tr><td align=center><code>rhs</code></td><td>Positional Value</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpbranch-mlirpdl_interpbranchop><code>pdl_interp.branch</code> (::mlir::pdl_interp::BranchOp)&nbsp;<a class=headline-hash href=#pdl_interpbranch-mlirpdl_interpbranchop>¶</a></h3><p>General branch operation</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.branch` $dest attr-dict
</code></pre><p><code>pdl_interp.branch</code> operations expose general branch functionality to the
interpreter, and are generally used to branch from one pattern match
sequence to another.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>branch <span class=nl>^dest
</span></code></pre></div><h4 id=successors-2>Successors:&nbsp;<a class=headline-hash href=#successors-2>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_attribute-mlirpdl_interpcheckattributeop><code>pdl_interp.check_attribute</code> (::mlir::pdl_interp::CheckAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_attribute-mlirpdl_interpcheckattributeop>¶</a></h3><p>Check the value of an <code>Attribute</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.check_attribute` $attribute `is` $constantValue attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_attribute</code> operations compare the value of a given
attribute with a constant value. On success, this operation branches to the
true destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>check_attribute <span class=nv>%attr</span> is <span class=m>10</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>constantValue</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>attribute</code></td><td>mlir::pdl::AttributeType</td></tr></tbody></table><h4 id=successors-3>Successors:&nbsp;<a class=headline-hash href=#successors-3>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_operand_count-mlirpdl_interpcheckoperandcountop><code>pdl_interp.check_operand_count</code> (::mlir::pdl_interp::CheckOperandCountOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_operand_count-mlirpdl_interpcheckoperandcountop>¶</a></h3><p>Check the number of operands of an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.check_operand_count` `of` $operation `is` $count attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_operand_count</code> operations compare the number of operands
of a given operation value with a constant. On success, this operation
branches to the true destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>check_operand_count of <span class=nv>%op</span> is <span class=m>2</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>count</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-4>Successors:&nbsp;<a class=headline-hash href=#successors-4>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_operation_name-mlirpdl_interpcheckoperationnameop><code>pdl_interp.check_operation_name</code> (::mlir::pdl_interp::CheckOperationNameOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_operation_name-mlirpdl_interpcheckoperationnameop>¶</a></h3><p>Check the OperationName of an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.check_operation_name` `of` $operation `is` $name attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_operation_name</code> operations compare the name of a given
operation with a known name. On success, this operation branches to the true
destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>check_operation_name of <span class=nv>%op</span> is <span class=s>&#34;foo.op&#34;</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-5>Successors:&nbsp;<a class=headline-hash href=#successors-5>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_result_count-mlirpdl_interpcheckresultcountop><code>pdl_interp.check_result_count</code> (::mlir::pdl_interp::CheckResultCountOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_result_count-mlirpdl_interpcheckresultcountop>¶</a></h3><p>Check the number of results of an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.check_result_count` `of` $operation `is` $count attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_result_count</code> operations compare the number of results
of a given operation value with a constant. On success, this operation
branches to the true destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>check_result_count of <span class=nv>%op</span> is <span class=m>0</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>count</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-6>Successors:&nbsp;<a class=headline-hash href=#successors-6>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_type-mlirpdl_interpchecktypeop><code>pdl_interp.check_type</code> (::mlir::pdl_interp::CheckTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_type-mlirpdl_interpchecktypeop>¶</a></h3><p>Compare a type to a known value</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.check_type` $value `is` $type attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_type</code> operations compare a type with a statically known
type. On success, this operation branches to the true destination, otherwise
the false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>check_type <span class=nv>%type</span> is <span class=k>i32</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h4 id=successors-7>Successors:&nbsp;<a class=headline-hash href=#successors-7>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcreate_attribute-mlirpdl_interpcreateattributeop><code>pdl_interp.create_attribute</code> (::mlir::pdl_interp::CreateAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_attribute-mlirpdl_interpcreateattributeop>¶</a></h3><p>Create an interpreter handle to a constant <code>Attribute</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.create_attribute` $value attr-dict
</code></pre><p><code>pdl_interp.create_attribute</code> operations generate a handle within the
interpreter for a specific constant attribute value.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%attr</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_attribute <span class=m>10</span> <span class=p>:</span> <span class=k>i64</span>
</code></pre></div><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>attribute</code></td><td>mlir::pdl::AttributeType</td></tr></tbody></table><h3 id=pdl_interpcreate_native-mlirpdl_interpcreatenativeop><code>pdl_interp.create_native</code> (::mlir::pdl_interp::CreateNativeOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_native-mlirpdl_interpcreatenativeop>¶</a></h3><p>Call a native creation method to construct an <code>Attribute</code>, <code>Operation</code>, <code>Type</code>, or <code>Value</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.create_native` $name ($constParams^)? (`(` $args^ `:` type($args) `)`)? `:` type($result)
              attr-dict
</code></pre><p><code>pdl_interp.create_native</code> operations invoke a native C++ function, that has
been registered externally with the consumer of PDL, to create an
<code>Attribute</code>, <code>Operation</code>, <code>Type</code>, or <code>Value</code>. The native function must
produce a value of the specified return type, and may accept any number of
positional arguments and constant attribute parameters.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%ret</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_native <span class=s>&#34;myNativeFunc&#34;</span><span class=p>[</span><span class=m>42</span><span class=p>,</span> <span class=s>&#34;gt&#34;</span><span class=p>]</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>attribute
</code></pre></div><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>constParams</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>args</code></td><td>Positional Value</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>Positional Value</td></tr></tbody></table><h3 id=pdl_interpcreate_operation-mlirpdl_interpcreateoperationop><code>pdl_interp.create_operation</code> (::mlir::pdl_interp::CreateOperationOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_operation-mlirpdl_interpcreateoperationop>¶</a></h3><p>Create an instance of a specific <code>Operation</code></p><p><code>pdl_interp.create_operation</code> operations create an <code>Operation</code> instance with
the specified attributes, operands, and result types.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Create an instance of a `foo.op` operation.
</span><span class=c></span><span class=nv>%op</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span><span class=s>&#34;attrA&#34;</span> <span class=p>=</span> <span class=nv>%attr0</span><span class=p>}</span> <span class=p>-&gt;</span> <span class=nv>%type</span><span class=p>,</span> <span class=nv>%type</span>
</code></pre></div><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>attributeNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>mlir::pdl::ValueType</td></tr><tr><td align=center><code>attributes</code></td><td>mlir::pdl::AttributeType</td></tr><tr><td align=center><code>types</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h3 id=pdl_interpcreate_type-mlirpdl_interpcreatetypeop><code>pdl_interp.create_type</code> (::mlir::pdl_interp::CreateTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_type-mlirpdl_interpcreatetypeop>¶</a></h3><p>Create an interpreter handle to a constant <code>Type</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.create_type` $value attr-dict
</code></pre><p><code>pdl_interp.create_type</code> operations generate a handle within the interpreter
for a specific constant type value.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>create_type <span class=k>i64</span>
</code></pre></div><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h3 id=pdl_interperase-mlirpdl_interperaseop><code>pdl_interp.erase</code> (::mlir::pdl_interp::EraseOp)&nbsp;<a class=headline-hash href=#pdl_interperase-mlirpdl_interperaseop>¶</a></h3><p>Mark an operation as <code>erased</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.erase` $operation attr-dict
</code></pre><p><code>pdl.erase</code> operations are used to specify that an operation should be
marked as erased. The semantics of this operation correspond with the
<code>eraseOp</code> method on a <code>PatternRewriter</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>erase <span class=nv>%root</span>
</code></pre></div><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h3 id=pdl_interpfinalize-mlirpdl_interpfinalizeop><code>pdl_interp.finalize</code> (::mlir::pdl_interp::FinalizeOp)&nbsp;<a class=headline-hash href=#pdl_interpfinalize-mlirpdl_interpfinalizeop>¶</a></h3><p>Finalize a pattern match or rewrite sequence</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.finalize` attr-dict
</code></pre><p><code>pdl_interp.finalize</code> is used to denote the termination of a match or
rewrite sequence.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>finalize
</code></pre></div><h3 id=pdl_interpget_attribute-mlirpdl_interpgetattributeop><code>pdl_interp.get_attribute</code> (::mlir::pdl_interp::GetAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpget_attribute-mlirpdl_interpgetattributeop>¶</a></h3><p>Get a specified attribute value from an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.get_attribute` $name `of` $operation attr-dict
</code></pre><p><code>pdl_interp.get_attribute</code> operations try to get a specific attribute from
an operation. If the operation does not have that attribute, a null value is
returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%attr</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_attribute <span class=s>&#34;attr&#34;</span> of <span class=nv>%op</span>
</code></pre></div><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>attribute</code></td><td>mlir::pdl::AttributeType</td></tr></tbody></table><h3 id=pdl_interpget_attribute_type-mlirpdl_interpgetattributetypeop><code>pdl_interp.get_attribute_type</code> (::mlir::pdl_interp::GetAttributeTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpget_attribute_type-mlirpdl_interpgetattributetypeop>¶</a></h3><p>Get the result type of a specified <code>Attribute</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.get_attribute_type` `of` $value attr-dict
</code></pre><p><code>pdl_interp.get_attribute_type</code> operations get the resulting type of a
specific attribute.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%type</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_attribute_type of <span class=nv>%attr</span>
</code></pre></div><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::AttributeType</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h3 id=pdl_interpget_defining_op-mlirpdl_interpgetdefiningopop><code>pdl_interp.get_defining_op</code> (::mlir::pdl_interp::GetDefiningOpOp)&nbsp;<a class=headline-hash href=#pdl_interpget_defining_op-mlirpdl_interpgetdefiningopop>¶</a></h3><p>Get the defining operation of a <code>Value</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.get_defining_op` `of` $value attr-dict
</code></pre><p><code>pdl_interp.get_defining_op</code> operations try to get the defining operation
of a specific value. If the value is not an operation result, null is
returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%op</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_defining_op of <span class=nv>%value</span>
</code></pre></div><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h3 id=pdl_interpget_operand-mlirpdl_interpgetoperandop><code>pdl_interp.get_operand</code> (::mlir::pdl_interp::GetOperandOp)&nbsp;<a class=headline-hash href=#pdl_interpget_operand-mlirpdl_interpgetoperandop>¶</a></h3><p>Get a specified operand from an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.get_operand` $index `of` $operation attr-dict
</code></pre><p><code>pdl_interp.get_operand</code> operations try to get a specific operand from an
operation If the operation does not have an operand for the given index, a
null value is returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%operand</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_operand <span class=m>1</span> of <span class=nv>%op</span>
</code></pre></div><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h3 id=pdl_interpget_result-mlirpdl_interpgetresultop><code>pdl_interp.get_result</code> (::mlir::pdl_interp::GetResultOp)&nbsp;<a class=headline-hash href=#pdl_interpget_result-mlirpdl_interpgetresultop>¶</a></h3><p>Get a specified result from an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.get_result` $index `of` $operation attr-dict
</code></pre><p><code>pdl_interp.get_result</code> operations try to get a specific result from an
operation. If the operation does not have a result for the given index, a
null value is returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%result</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_result <span class=m>1</span> of <span class=nv>%op</span>
</code></pre></div><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h3 id=pdl_interpget_value_type-mlirpdl_interpgetvaluetypeop><code>pdl_interp.get_value_type</code> (::mlir::pdl_interp::GetValueTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpget_value_type-mlirpdl_interpgetvaluetypeop>¶</a></h3><p>Get the result type of a specified <code>Value</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.get_value_type` `of` $value attr-dict
</code></pre><p><code>pdl_interp.get_value_type</code> operations get the resulting type of a specific
value.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%type</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_value_type of <span class=nv>%value</span>
</code></pre></div><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h3 id=pdl_interpinferred_type-mlirpdl_interpinferredtypeop><code>pdl_interp.inferred_type</code> (::mlir::pdl_interp::InferredTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpinferred_type-mlirpdl_interpinferredtypeop>¶</a></h3><p>Generate a handle to a Type that is &ldquo;inferred&rdquo;</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.inferred_type` attr-dict
</code></pre><p><code>pdl_interp.inferred_type</code> operations generate a handle to a type that
should be inferred. This signals to other operations, such as
<code>pdl_interp.create_operation</code>, that this type should be inferred.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>inferred_type
</code></pre></div><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h3 id=pdl_interpis_not_null-mlirpdl_interpisnotnullop><code>pdl_interp.is_not_null</code> (::mlir::pdl_interp::IsNotNullOp)&nbsp;<a class=headline-hash href=#pdl_interpis_not_null-mlirpdl_interpisnotnullop>¶</a></h3><p>Check if a positional value is non-null</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.is_not_null` $value `:` type($value) attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.is_not_null</code> operations check that a positional value exists. On
success, this operation branches to the true destination. Otherwise, the
false destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>is_not_null <span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></code></pre></div><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>Positional Value</td></tr></tbody></table><h4 id=successors-8>Successors:&nbsp;<a class=headline-hash href=#successors-8>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interprecord_match-mlirpdl_interprecordmatchop><code>pdl_interp.record_match</code> (::mlir::pdl_interp::RecordMatchOp)&nbsp;<a class=headline-hash href=#pdl_interprecord_match-mlirpdl_interprecordmatchop>¶</a></h3><p>Record the metadata for a successful pattern match</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.record_match` $rewriter (`(` $inputs^ `:` type($inputs) `)`)? `:`
              `benefit` `(` $benefit `)` `,`
              (`generatedOps` `(` $generatedOps^ `)` `,`)?
              `loc` `(` `[` $matchedOps `]` `)`
              (`,` `root` `(` $rootKind^ `)`)? attr-dict `-&gt;` $dest
</code></pre><p><code>pdl_interp.record_match</code> operations record a successful pattern match with
the interpreter and branch to the next part of the matcher. The metadata
recorded by these operations correspond to a specific <code>pdl.pattern</code>, as well
as what values were used during that match that should be propagated to the
rewriter.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>record_match <span class=nf>@rewriters</span><span class=p>:</span><span class=p>:</span>myRewriter<span class=p>(</span><span class=nv>%root</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span> <span class=p>:</span> benefit<span class=p>(</span><span class=m>1</span><span class=p>)</span><span class=p>,</span> <span class=kt>loc</span><span class=p>(</span><span class=p>[</span><span class=nv>%root</span><span class=p>,</span> <span class=nv>%op1</span><span class=p>]</span><span class=p>)</span><span class=p>,</span> root<span class=p>(</span><span class=s>&#34;foo.op&#34;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^nextDest
</span></code></pre></div><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>rewriter</code></td><td align=center>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr><tr><td align=center><code>rootKind</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>generatedOps</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>benefit</code></td><td align=center>::mlir::IntegerAttr</td><td>16-bit signless integer attribute whose value is non-negative</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>Positional Value</td></tr><tr><td align=center><code>matchedOps</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-9>Successors:&nbsp;<a class=headline-hash href=#successors-9>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpreplace-mlirpdl_interpreplaceop><code>pdl_interp.replace</code> (::mlir::pdl_interp::ReplaceOp)&nbsp;<a class=headline-hash href=#pdl_interpreplace-mlirpdl_interpreplaceop>¶</a></h3><p>Mark an operation as <code>replace</code>d</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.replace` $operation `with` `(` $replValues `)` attr-dict
</code></pre><p><code>pdl_interp.replaced</code> operations are used to specify that an operation
should be marked as replaced. The semantics of this operation correspond
with the <code>replaceOp</code> method on a <code>PatternRewriter</code>. The set of replacement
values must match the number of results specified by the operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Replace root node with 2 values:
</span><span class=c></span>pdl_interp<span class=p>.</span>replace <span class=nv>%root</span> with <span class=p>(</span><span class=nv>%val0</span><span class=p>,</span> <span class=nv>%val1</span><span class=p>)</span>
</code></pre></div><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr><tr><td align=center><code>replValues</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h3 id=pdl_interpswitch_attribute-mlirpdl_interpswitchattributeop><code>pdl_interp.switch_attribute</code> (::mlir::pdl_interp::SwitchAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_attribute-mlirpdl_interpswitchattributeop>¶</a></h3><p>Switch on the value of an <code>Attribute</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.switch_attribute` $attribute `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_attribute</code> operations compare the value of a given
attribute with a set of constant attributes. If the value matches one of the
provided case values the destination for that case value is taken, otherwise
the default destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>switch_attribute <span class=nv>%attr</span> to <span class=p>[</span><span class=m>10</span><span class=p>,</span> true<span class=p>]</span><span class=p>(</span><span class=err>^</span><span class=m>10</span>Dest<span class=p>,</span> <span class=nl>^trueDest</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^defaultDest
</span></code></pre></div><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>caseValues</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>attribute</code></td><td>mlir::pdl::AttributeType</td></tr></tbody></table><h4 id=successors-10>Successors:&nbsp;<a class=headline-hash href=#successors-10>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defaultDest</code></td><td>any successor</td></tr><tr><td align=center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_operand_count-mlirpdl_interpswitchoperandcountop><code>pdl_interp.switch_operand_count</code> (::mlir::pdl_interp::SwitchOperandCountOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_operand_count-mlirpdl_interpswitchoperandcountop>¶</a></h3><p>Switch on the operand count of an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.switch_operand_count` `of` $operation `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_operand_count</code> operations compare the operand count of a
given operation with a set of potential counts. If the value matches one of
the provided case values the destination for that case value is taken,
otherwise the default destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>switch_operand_count of <span class=nv>%op</span> to <span class=p>[</span><span class=m>10</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>-&gt;</span> <span class=err>^</span><span class=m>10</span>Dest<span class=p>,</span> <span class=err>^</span><span class=m>2</span>Dest<span class=p>,</span> <span class=nl>^defaultDest
</span></code></pre></div><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>caseValues</code></td><td align=center>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr></tbody></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-11>Successors:&nbsp;<a class=headline-hash href=#successors-11>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defaultDest</code></td><td>any successor</td></tr><tr><td align=center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_operation_name-mlirpdl_interpswitchoperationnameop><code>pdl_interp.switch_operation_name</code> (::mlir::pdl_interp::SwitchOperationNameOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_operation_name-mlirpdl_interpswitchoperationnameop>¶</a></h3><p>Switch on the OperationName of an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.switch_operation_name` `of` $operation `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_operation_name</code> operations compare the name of a given
operation with a set of known names. If the value matches one of the
provided case values the destination for that case value is taken, otherwise
the default destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>switch_operation_name of <span class=nv>%op</span> to <span class=p>[</span><span class=s>&#34;foo.op&#34;</span><span class=p>,</span> <span class=s>&#34;bar.op&#34;</span><span class=p>]</span><span class=p>(</span><span class=nl>^fooDest</span><span class=p>,</span> <span class=nl>^barDest</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^defaultDest
</span></code></pre></div><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>caseValues</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-12>Successors:&nbsp;<a class=headline-hash href=#successors-12>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defaultDest</code></td><td>any successor</td></tr><tr><td align=center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_result_count-mlirpdl_interpswitchresultcountop><code>pdl_interp.switch_result_count</code> (::mlir::pdl_interp::SwitchResultCountOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_result_count-mlirpdl_interpswitchresultcountop>¶</a></h3><p>Switch on the result count of an <code>Operation</code></p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.switch_result_count` `of` $operation `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_result_count</code> operations compare the result count of a
given operation with a set of potential counts. If the value matches one of
the provided case values the destination for that case value is taken,
otherwise the default destination is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>switch_result_count of <span class=nv>%op</span> to <span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span><span class=p>(</span><span class=err>^</span><span class=m>0</span>Dest<span class=p>,</span> <span class=err>^</span><span class=m>2</span>Dest<span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^defaultDest
</span></code></pre></div><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>caseValues</code></td><td align=center>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr></tbody></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h4 id=successors-13>Successors:&nbsp;<a class=headline-hash href=#successors-13>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defaultDest</code></td><td>any successor</td></tr><tr><td align=center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_type-mlirpdl_interpswitchtypeop><code>pdl_interp.switch_type</code> (::mlir::pdl_interp::SwitchTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_type-mlirpdl_interpswitchtypeop>¶</a></h3><p>Switch on a <code>Type</code> value</p><p>Syntax:</p><pre><code>operation ::= `pdl_interp.switch_type` $value `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_type</code> operations compare a type with a set of statically
known types. If the value matches one of the provided case values the
destination for that case value is taken, otherwise the default destination
is taken.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl_interp<span class=p>.</span>switch_type <span class=nv>%type</span> to <span class=p>[</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>]</span> <span class=p>-&gt;</span> <span class=nl>^i32Dest</span><span class=p>,</span> <span class=nl>^i64Dest</span><span class=p>,</span> <span class=nl>^defaultDest
</span></code></pre></div><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>caseValues</code></td><td align=center>::mlir::ArrayAttr</td><td>type array attribute</td></tr></tbody></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h4 id=successors-14>Successors:&nbsp;<a class=headline-hash href=#successors-14>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defaultDest</code></td><td>any successor</td></tr><tr><td align=center><code>cases</code></td><td>any successor</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/PDLOps/ title="'pdl' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'pdl' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/QuantDialect/ title="'quant' Dialect">Next - 'quant' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Builtin/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/AVX512/>'avx512' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmNeon/>'llvm_arm_neon' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmSve/>'llvm_arm_sve' Dialect</a></li><li><a href=/docs/Dialects/LLVMAVX512/>'llvm_avx512' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li class=active><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/TensorPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/Bufferization/>Bufferization on MLIR</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>