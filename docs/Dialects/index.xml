<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dialects on MLIR</title><link>https://mlir.llvm.org/docs/Dialects/</link><description>Recent content in Dialects on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Dialects/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://mlir.llvm.org/docs/Dialects/Builtin/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Builtin/</guid><description>func (::mlir::FuncOp) An operation with a name containing a single SSACFG region
Operations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove. All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body.</description></item><item><title>'acc' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/OpenACCDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/OpenACCDialect/</guid><description>An OpenACC dialect for MLIR. This dialect models the construct from the OpenACC 3.1 directive language.
Operation definition acc.data (::mlir::acc::DataOp) acc.enter_data (::mlir::acc::EnterDataOp) acc.exit_data (::mlir::acc::ExitDataOp) acc.init (::mlir::acc::InitOp) acc.loop (::mlir::acc::LoopOp) acc.parallel (::mlir::acc::ParallelOp) acc.shutdown (::mlir::acc::ShutdownOp) acc.terminator (::mlir::acc::TerminatorOp) acc.update (::mlir::acc::UpdateOp) acc.wait (::mlir::acc::WaitOp) acc.yield (::mlir::acc::YieldOp) Operation definition acc.data (::mlir::acc::DataOp) data construct
Syntax:
operation ::= `acc.data` ( `if` `(` $ifCond^ `)` )? ( `copy` `(` $copyOperands^ `:` type($copyOperands) `)` )? ( `copyin` `(` $copyinOperands^ `:` type($copyinOperands) `)` )?</description></item><item><title>'affine' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Affine/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Affine/</guid><description>This dialect provides a powerful abstraction for affine operations and analyses.
Polyhedral Structures Dimensions and Symbols Restrictions on Dimensions and Symbols Affine Expressions Affine Maps Semi-affine maps Integer Sets Operations affine.apply (AffineApplyOp) affine.for (AffineForOp) affine.if (AffineIfOp) affine.load (AffineLoadOp) affine.max (AffineMaxOp) affine.min (AffineMinOp) affine.parallel (AffineParallelOp) affine.prefetch (AffinePrefetchOp) affine.store (AffineStoreOp) affine.vector_load (AffineVectorLoadOp) affine.vector_store (AffineVectorStoreOp) affine.yield (AffineYieldOp) &amp;lsquo;affine.store&amp;rsquo; operation &amp;lsquo;affine.dma_start&amp;rsquo; operation &amp;lsquo;affine.dma_wait&amp;rsquo; operation Polyhedral Structures MLIR uses techniques from polyhedral compilation to make dependence analysis and loop transformations efficient and reliable.</description></item><item><title>'arm_neon' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ArmNeon/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ArmNeon/</guid><description>Operation definition arm_neon.smull (::mlir::arm_neon::SMullOp) Operation definition arm_neon.smull (::mlir::arm_neon::SMullOp) smull roundscale op
Syntax:
operation ::= `arm_neon.smull` $a `,` $b attr-dict `:` type($a) `to` type($res) Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&amp;amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;amp;FP register.</description></item><item><title>'async' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/AsyncDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/AsyncDialect/</guid><description>Types and operations for async dialect This dialect contains operations for modeling asynchronous execution.
Type constraint definition async value type group type token type Operation definition async.add_ref (::mlir::async::AddRefOp) async.add_to_group (::mlir::async::AddToGroupOp) async.await_all (::mlir::async::AwaitAllOp) async.await (::mlir::async::AwaitOp) async.create_group (::mlir::async::CreateGroupOp) async.drop_ref (::mlir::async::DropRefOp) async.execute (::mlir::async::ExecuteOp) async.yield (::mlir::async::YieldOp) Type constraint definition async value type group type async.group represent a set of async tokens or values and allows to execute async operations on all of them together (e.</description></item><item><title>'avx512' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/AVX512/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/AVX512/</guid><description>Operation definition avx512.mask.rndscale (::mlir::avx512::MaskRndScaleOp) avx512.mask.scalef (::mlir::avx512::MaskScaleFOp) Operation definition avx512.mask.rndscale (::mlir::avx512::MaskRndScaleOp) Masked roundscale op
Syntax:
operation ::= `avx512.mask.rndscale` $src `,` $k `,` $a `,` $imm `,` $rounding attr-dict `:` type($dst) The mask.rndscale op is an AVX512 specific op that can lower to the proper LLVMAVX512 operation: llvm.mask.rndscale.ps.512 or llvm.mask.rndscale.pd.512 instruction depending on the type of vectors it is applied to.
From the Intel Intrinsics Guide: Round packed floating-point elements in a to the number of fraction bits specified by imm, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</description></item><item><title>'gpu' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/GPU/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/GPU/</guid><description>Note: this dialect is more likely to change than others in the near future; use with caution.
This dialect provides middle-level abstractions for launching GPU kernels following a programming model similar to that of CUDA or OpenCL. It provides abstractions for kernel invocations (and may eventually provide those for device management) that are not present at the lower level (e.g., as LLVM IR intrinsics for GPUs). Its goal is to abstract away device- and driver-specific manipulations to launch a GPU kernel and provide a simple path towards GPU execution from MLIR.</description></item><item><title>'linalg' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Linalg/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Linalg/</guid><description>Rationale Set of Key Transformations High-Level Description of Linalg Ops Payload-Carrying Ops Tensors and Buffers: Conventions and Limitations Data Representation: Views Metadata Ops Named Payload-Carrying Ops Named Payload Ops Specification Open Issues and Design Alternatives Operations linalg.batch_matmul (::mlir::linalg::BatchMatmulOp) linalg.conv_3d (::mlir::linalg::ConvDHWOp) linalg.conv_2d (::mlir::linalg::ConvHWOp) linalg.conv_3d_ncdhw (::mlir::linalg::ConvNCDHWOp) linalg.conv_2d_nchw (::mlir::linalg::ConvNCHWOp) linalg.conv_1d_ncw (::mlir::linalg::ConvNCWOp) linalg.conv_3d_ndhwc (::mlir::linalg::ConvNDHWCOp) linalg.conv_2d_nhwc (::mlir::linalg::ConvNHWCOp) linalg.conv_1d_nwc (::mlir::linalg::ConvNWCOp) linalg.conv (::mlir::linalg::ConvOp) linalg.conv_1d (::mlir::linalg::ConvWOp) linalg.copy (::mlir::linalg::CopyOp) linalg.dot (::mlir::linalg::DotOp) linalg.fill (::mlir::linalg::FillOp) linalg.</description></item><item><title>'llvm' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/LLVM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LLVM/</guid><description>This dialect wraps the LLVM IR types and instructions into MLIR types and operations. It provides several additional operations that are necessary to cover for the differences in the IR structure (e.g., MLIR does not have phi operations and LLVM IR does not have a constant operation).
In this document, we use &amp;ldquo;LLVM IR&amp;rdquo; to designate the intermediate representation of LLVM and &amp;ldquo;LLVM IR dialect&amp;rdquo; to refer to the MLIR dialect reflecting LLVM instructions and types.</description></item><item><title>'llvm_arm_neon' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/LLVMArmNeon/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LLVMArmNeon/</guid><description> Operation definition llvm_arm_neon.smull (::mlir::LLVM::aarch64_arm_neon_smull) Operation definition llvm_arm_neon.smull (::mlir::LLVM::aarch64_arm_neon_smull) Operands: Operand Description «unnamed» LLVM dialect type «unnamed» LLVM dialect type Results: Result Description res LLVM dialect type</description></item><item><title>'llvm_arm_sve' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/LLVMArmSve/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LLVMArmSve/</guid><description>Operation definition llvm_arm_sve.sdot (::mlir::LLVM::aarch64_arm_sve_sdot) llvm_arm_sve.smmla (::mlir::LLVM::aarch64_arm_sve_smmla) llvm_arm_sve.udot (::mlir::LLVM::aarch64_arm_sve_udot) llvm_arm_sve.ummla (::mlir::LLVM::aarch64_arm_sve_ummla) llvm_arm_sve.vscale (::mlir::LLVM::vector_scale) Operation definition llvm_arm_sve.sdot (::mlir::LLVM::aarch64_arm_sve_sdot) Operands: Operand Description «unnamed» LLVM dialect type «unnamed» LLVM dialect type «unnamed» LLVM dialect type Results: Result Description res LLVM dialect type llvm_arm_sve.smmla (::mlir::LLVM::aarch64_arm_sve_smmla) Operands: Operand Description «unnamed» LLVM dialect type «unnamed» LLVM dialect type «unnamed» LLVM dialect type Results: Result Description res LLVM dialect type llvm_arm_sve.</description></item><item><title>'llvm_avx512' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/LLVMAVX512/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/LLVMAVX512/</guid><description>Operation definition llvm_avx512.mask.rndscale.pd.512 (::mlir::LLVM::x86_avx512_mask_rndscale_pd_512) llvm_avx512.mask.rndscale.ps.512 (::mlir::LLVM::x86_avx512_mask_rndscale_ps_512) llvm_avx512.mask.scalef.pd.512 (::mlir::LLVM::x86_avx512_mask_scalef_pd_512) llvm_avx512.mask.scalef.ps.512 (::mlir::LLVM::x86_avx512_mask_scalef_ps_512) Operation definition llvm_avx512.mask.rndscale.pd.512 (::mlir::LLVM::x86_avx512_mask_rndscale_pd_512) Operands: Operand Description «unnamed» LLVM dialect type «unnamed» LLVM dialect type «unnamed» LLVM dialect type «unnamed» LLVM dialect type «unnamed» LLVM dialect type Results: Result Description res LLVM dialect type llvm_avx512.</description></item><item><title>'nvvm' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/NVVMDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/NVVMDialect/</guid><description>Operation definition nvvm.barrier0 (::mlir::NVVM::Barrier0Op) nvvm.read.ptx.sreg.ntid.x (::mlir::NVVM::BlockDimXOp) nvvm.read.ptx.sreg.ntid.y (::mlir::NVVM::BlockDimYOp) nvvm.read.ptx.sreg.ntid.z (::mlir::NVVM::BlockDimZOp) nvvm.read.ptx.sreg.ctaid.x (::mlir::NVVM::BlockIdXOp) nvvm.read.ptx.sreg.ctaid.y (::mlir::NVVM::BlockIdYOp) nvvm.read.ptx.sreg.ctaid.z (::mlir::NVVM::BlockIdZOp) nvvm.read.ptx.sreg.nctaid.x (::mlir::NVVM::GridDimXOp) nvvm.read.ptx.sreg.nctaid.y (::mlir::NVVM::GridDimYOp) nvvm.read.ptx.sreg.nctaid.z (::mlir::NVVM::GridDimZOp) nvvm.read.ptx.sreg.laneid (::mlir::NVVM::LaneIdOp) nvvm.mma.sync (::mlir::NVVM::MmaOp) nvvm.shfl.sync.bfly (::mlir::NVVM::ShflBflyOp) nvvm.read.ptx.sreg.tid.x (::mlir::NVVM::ThreadIdXOp) nvvm.read.ptx.sreg.tid.y (::mlir::NVVM::ThreadIdYOp) nvvm.read.ptx.sreg.tid.z (::mlir::NVVM::ThreadIdZOp) nvvm.vote.ballot.sync (::mlir::NVVM::VoteBallotOp) nvvm.read.ptx.sreg.warpsize (::mlir::NVVM::WarpSizeOp) Operation definition nvvm.barrier0 (::mlir::NVVM::Barrier0Op) Syntax:
operation ::= `nvvm.barrier0` attr-dict nvvm.read.ptx.sreg.ntid.x (::mlir::NVVM::BlockDimXOp) Syntax:
operation ::= `nvvm.read.ptx.sreg.ntid.x` attr-dict `:` type($res) Results: Result Description res LLVM dialect type nvvm.</description></item><item><title>'omp' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/OpenMPDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/OpenMPDialect/</guid><description>Operation definition omp.barrier (::mlir::omp::BarrierOp) omp.flush (::mlir::omp::FlushOp) omp.master (::mlir::omp::MasterOp) omp.parallel (::mlir::omp::ParallelOp) omp.taskwait (::mlir::omp::TaskwaitOp) omp.taskyield (::mlir::omp::TaskyieldOp) omp.terminator (::mlir::omp::TerminatorOp) omp.wsloop (::mlir::omp::WsLoopOp) omp.yield (::mlir::omp::YieldOp) Operation definition omp.barrier (::mlir::omp::BarrierOp) barrier construct
Syntax:
operation ::= `omp.barrier` attr-dict The barrier construct specifies an explicit barrier at the point at which the construct appears.
omp.flush (::mlir::omp::FlushOp) flush construct
Syntax:
operation ::= `omp.flush` ( `(` $varList^ `:` type($varList) `)` )? attr-dict The flush construct executes the OpenMP flush operation.</description></item><item><title>'pdl' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/PDLOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/PDLOps/</guid><description>High level pattern definition dialect PDL presents a high level abstraction for the rewrite pattern infrastructure available in MLIR. This abstraction allows for representing patterns transforming MLIR, as MLIR. This allows for applying all of the benefits that the general MLIR infrastructure provides, to the infrastructure itself. This means that pattern matching can be more easily verified for correctness, targeted by frontends, and optimized.
PDL abstracts over various different aspects of patterns and core MLIR data structures.</description></item><item><title>'pdl_interp' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/PDLInterpOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/PDLInterpOps/</guid><description>Interpreted pattern execution dialect The PDL Interpreter dialect provides a lower level abstraction compared to the PDL dialect, and is targeted towards low level optimization and interpreter code generation. The dialect operations encapsulates low-level pattern match and rewrite &amp;ldquo;primitives&amp;rdquo;, such as navigating the IR (Operation::getOperand), creating new operations (OpBuilder::create), etc. Many of the operations within this dialect also fuse branching control flow with some form of a predicate comparison operation. This type of fusion reduces the amount of work that an interpreter must do when executing.</description></item><item><title>'quant' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/QuantDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/QuantDialect/</guid><description>Type constraint definition UniformQuantizedType Operation definition quant.const_fake_quant (::mlir::quant::ConstFakeQuant) quant.const_fake_quant_per_axis (::mlir::quant::ConstFakeQuantPerAxis) quant.coupled_ref (::mlir::quant::CoupledRefOp) quant.dcast (::mlir::quant::DequantizeCastOp) quant.qcast (::mlir::quant::QuantizeCastOp) quant.region (::mlir::quant::QuantizeRegionOp) quant.return (::mlir::quant::ReturnOp) quant.stats (::mlir::quant::StatisticsOp) quant.stats_ref (::mlir::quant::StatisticsRefOp) quant.scast (::mlir::quant::StorageCastOp) Type constraint definition UniformQuantizedType Operation definition quant.const_fake_quant (::mlir::quant::ConstFakeQuant) Simulates the effect of uniform quantization with const range. Given a const min, max, num_bits and narrow_range attribute, applies the same uniform quantization simulation as is done by the TensorFlow fake_quant_with_min_max_args op.</description></item><item><title>'rocdl' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ROCDLDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ROCDLDialect/</guid><description>Operation definition rocdl.barrier (::mlir::ROCDL::BarrierOp) rocdl.workgroup.dim.x (::mlir::ROCDL::BlockDimXOp) rocdl.workgroup.dim.y (::mlir::ROCDL::BlockDimYOp) rocdl.workgroup.dim.z (::mlir::ROCDL::BlockDimZOp) rocdl.workgroup.id.x (::mlir::ROCDL::BlockIdXOp) rocdl.workgroup.id.y (::mlir::ROCDL::BlockIdYOp) rocdl.workgroup.id.z (::mlir::ROCDL::BlockIdZOp) rocdl.grid.dim.x (::mlir::ROCDL::GridDimXOp) rocdl.grid.dim.y (::mlir::ROCDL::GridDimYOp) rocdl.grid.dim.z (::mlir::ROCDL::GridDimZOp) rocdl.buffer.load (::mlir::ROCDL::MubufLoadOp) rocdl.buffer.store (::mlir::ROCDL::MubufStoreOp) rocdl.workitem.id.x (::mlir::ROCDL::ThreadIdXOp) rocdl.workitem.id.y (::mlir::ROCDL::ThreadIdYOp) rocdl.workitem.id.z (::mlir::ROCDL::ThreadIdZOp) rocdl.mfma.f32.16x16x16f16 (::mlir::ROCDL::mfma_f32_16x16x16f16) rocdl.mfma.f32.16x16x1f32 (::mlir::ROCDL::mfma_f32_16x16x1f32) rocdl.mfma.f32.16x16x2bf16 (::mlir::ROCDL::mfma_f32_16x16x2bf16) rocdl.mfma.f32.16x16x4f16 (::mlir::ROCDL::mfma_f32_16x16x4f16) rocdl.mfma.f32.16x16x4f32 (::mlir::ROCDL::mfma_f32_16x16x4f32) rocdl.mfma.f32.16x16x8bf16 (::mlir::ROCDL::mfma_f32_16x16x8bf16) rocdl.mfma.f32.32x32x1f32 (::mlir::ROCDL::mfma_f32_32x32x1f32) rocdl.mfma.f32.32x32x2bf16 (::mlir::ROCDL::mfma_f32_32x32x2bf16) rocdl.mfma.f32.32x32x2f32 (::mlir::ROCDL::mfma_f32_32x32x2f32) rocdl.mfma.f32.32x32x4bf16 (::mlir::ROCDL::mfma_f32_32x32x4bf16) rocdl.mfma.f32.32x32x4f16 (::mlir::ROCDL::mfma_f32_32x32x4f16) rocdl.mfma.f32.32x32x8f16 (::mlir::ROCDL::mfma_f32_32x32x8f16) rocdl.mfma.f32.4x4x1f32 (::mlir::ROCDL::mfma_f32_4x4x1f32) rocdl.mfma.f32.4x4x2bf16 (::mlir::ROCDL::mfma_f32_4x4x2bf16) rocdl.mfma.f32.4x4x4f16 (::mlir::ROCDL::mfma_f32_4x4x4f16) rocdl.mfma.i32.16x16x16i8 (::mlir::ROCDL::mfma_i32_16x16x16i8) rocdl.mfma.i32.16x16x4i8 (::mlir::ROCDL::mfma_i32_16x16x4i8) rocdl.mfma.i32.32x32x4i8 (::mlir::ROCDL::mfma_i32_32x32x4i8) rocdl.</description></item><item><title>'scf' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/SCFDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SCFDialect/</guid><description>Operation definition scf.condition (::mlir::scf::ConditionOp) scf.for (::mlir::scf::ForOp) scf.if (::mlir::scf::IfOp) scf.parallel (::mlir::scf::ParallelOp) scf.reduce (::mlir::scf::ReduceOp) scf.reduce.return (::mlir::scf::ReduceReturnOp) scf.while (::mlir::scf::WhileOp) scf.yield (::mlir::scf::YieldOp) Operation definition scf.condition (::mlir::scf::ConditionOp) loop continuation condition
Syntax:
operation ::= `scf.condition` `(` $condition `)` attr-dict ($args^ `:` type($args))? This operation accepts the continuation (i.e., inverse of exit) condition of the scf.while construct. If its first argument is true, the &amp;ldquo;after&amp;rdquo; region of scf.while is executed, with the remaining arguments forwarded to the entry block of the region.</description></item><item><title>'shape' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/ShapeDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/ShapeDialect/</guid><description>Types and operations for shape dialect This dialect contains operations for shape inference.
Note: Unless explicitly stated, all functions that return a shape and take shapes as input, return the invalid shape if one of its operands is an invalid shape. This avoids flagging multiple errors for one verification failure. The dialect itself does not specify how errors should be combined (there are multiple different options, from always choosing first operand, concatting etc.</description></item><item><title>'spv' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/SPIR-V/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/SPIR-V/</guid><description>This document describes the design of the SPIR-V dialect in MLIR. It lists various design choices we made for modeling different SPIR-V mechanisms, and their rationale.
This document also explains in a high-level manner how different components are organized and implemented in the code and gives steps to follow for extending them.
This document assumes familiarity with SPIR-V. SPIR-V is the Khronos Group’s binary intermediate language for representing graphics shaders and compute kernels.</description></item><item><title>'std' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Standard/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Standard/</guid><description>This dialect provides documentation for operations within the Standard dialect.
Note: This dialect is a collection of operations for several different concepts, and should be split into multiple more-focused dialects accordingly.
Please post an RFC on the forum before adding or changing any operation in this dialect.
Operations std.absf (AbsFOp) std.addcf (AddCFOp) std.addf (AddFOp) std.addi (AddIOp) std.alloc (AllocOp) std.alloca (AllocaOp) std.and (AndOp) std.assert (AssertOp) std.assume_alignment (AssumeAlignmentOp) std.atan2 (Atan2Op) std.</description></item><item><title>'tensor' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/TensorOps/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/TensorOps/</guid><description>The tensor dialect is intended to hold core tensor creation and manipulation ops, which are not strongly associated with any particular other dialect or domain abstraction. The primary smoke test of this is ops that make sense for any tensor element type.
We leave it to other dialects to hold the vast swath of possible computations one might want to do on a tensor.
The tensor type is (for better or for worse) used to represent all kinds of things, and supports an open-ended set of element types.</description></item><item><title>'vector' Dialect</title><link>https://mlir.llvm.org/docs/Dialects/Vector/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/Vector/</guid><description>Positioning in the Codegen Infrastructure Components of a Generic Retargetable Vector-Level Dialect Short Description of the Existing Infrastructure LLVM level Hardware Vector Ops Virtual Vector Ops Virtual Vector Rewrite Patterns Virtual Vector to Hardware Vector Lowering Rationale Hardware as vector Machines of Minimum Granularity Transformations Problems Avoided The Big Out-Of-Scope Piece: Automatic Vectorization Bikeshed Naming Discussion DeeperDive Alternatives For Lowering an n-D Vector Type to LLVM Constraints Inherited from LLVM (see LangRef) Nested Aggregate Flattened 1-D Vector Type Discussion Relationship to LLVM matrix type proposal.</description></item><item><title>Tensor Operator Set Architecture (TOSA) Dialect</title><link>https://mlir.llvm.org/docs/Dialects/TOSA/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Dialects/TOSA/</guid><description>Rationale TOSA and Tensor Level Expressiveness Complete Minimal Numerical Precision TOSA Operator Rationale IDENTITYN COND\_IF and WHILE\_LOOP Using TOSA In A Compiler Quantization Parameters in Ops vs Tensors Operation definitions tosa.abs (mlir::tosa::AbsOp) tosa.add (mlir::tosa::AddOp) tosa.argmax (mlir::tosa::ArgMaxOp) tosa.arithmetic_right_shift (mlir::tosa::ArithmeticRightShiftOp) tosa.avg_pool2d (mlir::tosa::AvgPool2dOp) tosa.bitwise_and (mlir::tosa::BitwiseAndOp) tosa.bitwise_not (mlir::tosa::BitwiseNotOp) tosa.bitwise_or (mlir::tosa::BitwiseOrOp) tosa.bitwise_xor (mlir::tosa::BitwiseXorOp) tosa.cast (mlir::tosa::CastOp) tosa.ceil (mlir::tosa::CeilOp) tosa.clamp (mlir::tosa::ClampOp) tosa.clz (mlir::tosa::ClzOp) tosa.concat (mlir::tosa::ConcatOp) tosa.const (mlir::tosa::ConstOp) tosa.</description></item></channel></rss>