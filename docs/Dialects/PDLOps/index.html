<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'pdl' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/PDLOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'pdl' Dialect</h1><p>High level pattern definition dialect
PDL presents a high level abstraction for the rewrite pattern infrastructure
available in MLIR. This abstraction allows for representing patterns
transforming MLIR, as MLIR. This allows for applying all of the benefits
that the general MLIR infrastructure provides, to the infrastructure itself.
This means that pattern matching can be more easily verified for
correctness, targeted by frontends, and optimized.</p><p>PDL abstracts over various different aspects of patterns and core MLIR data
structures. Patterns are specified via a <code>pdl.pattern</code> operation. These
operations contain a region body for the &ldquo;matcher&rdquo; code, and terminate with
a <code>pdl.rewrite</code> that either dispatches to an external rewriter or contains
a region for the rewrite specified via <code>pdl</code>. The types of values in <code>pdl</code>
are handle types to MLIR C++ types, with <code>!pdl.attribute</code>, <code>!pdl.operation</code>,
and <code>!pdl.type</code> directly mapping to <code>mlir::Attribute</code>, <code>mlir::Operation*</code>,
and <code>mlir::Value</code> respectively.</p><p>An example pattern is shown below:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// pdl.pattern contains metadata similarly to a `RewritePattern`.
</span><span class=c></span>pdl<span class=p>.</span>pattern <span class=p>:</span> benefit<span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// External input operand values are specified via `pdl.input` operations.
</span><span class=c></span>  <span class=c>// Result types are constrainted via `pdl.type` operations.
</span><span class=c></span>
  <span class=nv>%resultType</span> <span class=p>=</span> pdl<span class=p>.</span>type
  <span class=nv>%inputOperand</span> <span class=p>=</span> pdl<span class=p>.</span>input
  <span class=nv>%root</span><span class=p>,</span> <span class=nv>%results</span> <span class=p>=</span> pdl<span class=p>.</span>operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%inputOperand</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nv>%resultType</span>
  pdl<span class=p>.</span>rewrite <span class=nv>%root</span> <span class=p>{</span>
    pdl<span class=p>.</span>replace <span class=nv>%root</span> with <span class=p>(</span><span class=nv>%inputOperand</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The above pattern simply replaces an operation with its first operand. Note
how the input operation is specified structurally, similarly to how it would
look in memory. This is a simple example and pdl provides support for many
other features such as applying external constraints or external generator
methods. These features and more are detailed below.</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#mlirpdlattributetype>mlir::pdl::AttributeType</a></li><li><a href=#mlirpdloperationtype>mlir::pdl::OperationType</a></li><li><a href=#mlirpdltypetype>mlir::pdl::TypeType</a></li><li><a href=#mlirpdlvaluetype>mlir::pdl::ValueType</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#pdlapply_constraint-mlirpdlapplyconstraintop>pdl.apply_constraint (::mlir::pdl::ApplyConstraintOp)</a></li><li><a href=#pdlattribute-mlirpdlattributeop>pdl.attribute (::mlir::pdl::AttributeOp)</a></li><li><a href=#pdlcreate_native-mlirpdlcreatenativeop>pdl.create_native (::mlir::pdl::CreateNativeOp)</a></li><li><a href=#pdlerase-mlirpdleraseop>pdl.erase (::mlir::pdl::EraseOp)</a></li><li><a href=#pdlinput-mlirpdlinputop>pdl.input (::mlir::pdl::InputOp)</a></li><li><a href=#pdloperation-mlirpdloperationop>pdl.operation (::mlir::pdl::OperationOp)</a></li><li><a href=#pdlpattern-mlirpdlpatternop>pdl.pattern (::mlir::pdl::PatternOp)</a></li><li><a href=#pdlreplace-mlirpdlreplaceop>pdl.replace (::mlir::pdl::ReplaceOp)</a></li><li><a href=#pdlrewrite_end-mlirpdlrewriteendop>pdl.rewrite_end (::mlir::pdl::RewriteEndOp)</a></li><li><a href=#pdlrewrite-mlirpdlrewriteop>pdl.rewrite (::mlir::pdl::RewriteOp)</a></li><li><a href=#pdltype-mlirpdltypeop>pdl.type (::mlir::pdl::TypeOp)</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=mlirpdlattributetype>mlir::pdl::AttributeType&nbsp;<a class=headline-hash href=#mlirpdlattributetype>¶</a></h3><h3 id=mlirpdloperationtype>mlir::pdl::OperationType&nbsp;<a class=headline-hash href=#mlirpdloperationtype>¶</a></h3><h3 id=mlirpdltypetype>mlir::pdl::TypeType&nbsp;<a class=headline-hash href=#mlirpdltypetype>¶</a></h3><h3 id=mlirpdlvaluetype>mlir::pdl::ValueType&nbsp;<a class=headline-hash href=#mlirpdlvaluetype>¶</a></h3><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=pdlapply_constraint-mlirpdlapplyconstraintop><code>pdl.apply_constraint</code> (::mlir::pdl::ApplyConstraintOp)&nbsp;<a class=headline-hash href=#pdlapply_constraint-mlirpdlapplyconstraintop>¶</a></h3><p>Apply a generic constraint to a set of provided entities</p><p>Syntax:</p><pre><code>operation ::= `pdl.apply_constraint` $name ($constParams^)? `(` $args `:` type($args) `)` attr-dict
</code></pre><p><code>apply_constraint</code> operations apply a generic constraint, that has been
registered externally with the consumer of PDL, to a given set of entities.
The constraint is permitted to accept any number of constant valued
parameters.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Apply `myConstraint` to the entities defined by `input`, `attr`, and
</span><span class=c></span><span class=c>// `op`. `42`, `&#34;abc&#34;`, and `i32` are constant parameters passed to the
</span><span class=c></span><span class=c>// constraint.
</span><span class=c></span>pdl<span class=p>.</span>apply_constraint <span class=s>&#34;myConstraint&#34;</span><span class=p>[</span><span class=m>42</span><span class=p>,</span> <span class=s>&#34;abc&#34;</span><span class=p>,</span> <span class=k>i32</span><span class=p>]</span><span class=p>(</span><span class=nv>%input</span><span class=p>,</span> <span class=nv>%attr</span><span class=p>,</span> <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>attribute<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span>
</code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>constParams</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>args</code></td><td>Positional Value</td></tr></tbody></table><h3 id=pdlattribute-mlirpdlattributeop><code>pdl.attribute</code> (::mlir::pdl::AttributeOp)&nbsp;<a class=headline-hash href=#pdlattribute-mlirpdlattributeop>¶</a></h3><p>Define an input attribute in a pattern</p><p>Syntax:</p><pre><code>operation ::= `pdl.attribute` attr-dict (`:` $type^)? ($value^)?
</code></pre><p><code>pdl.attribute</code> operations capture named attribute edges into an operation.
Instances of this operation define, and partially constrain, attributes of a
given operation. A <code>pdl.attribute</code> may partially constrain the input by
specifying an expected attribute value type (via a <code>pdl.type</code> operation), or
a constant value for the attribute (via <code>val</code>). Only one of these may be set
for a given input, as the type of the constant value provides the type. When
defined within a <code>pdl.rewrite</code> region, the constant value must be specified.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Define an attribute:
</span><span class=c></span><span class=nv>%attr</span> <span class=p>=</span> pdl<span class=p>.</span>attribute

<span class=c>// Define an attribute with an expected type:
</span><span class=c></span><span class=nv>%type</span> <span class=p>=</span> pdl<span class=p>.</span>type <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%attr</span> <span class=p>=</span> pdl<span class=p>.</span>attribute <span class=p>:</span> <span class=nv>%type</span>

<span class=c>// Define an attribute with a constant value:
</span><span class=c></span><span class=nv>%attr</span> <span class=p>=</span> pdl<span class=p>.</span>attribute <span class=s>&#34;hello&#34;</span>
</code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>attr</code></td><td>mlir::pdl::AttributeType</td></tr></tbody></table><h3 id=pdlcreate_native-mlirpdlcreatenativeop><code>pdl.create_native</code> (::mlir::pdl::CreateNativeOp)&nbsp;<a class=headline-hash href=#pdlcreate_native-mlirpdlcreatenativeop>¶</a></h3><p>Call a native creation method to construct an <code>Attribute</code>, <code>Operation</code>, <code>Type</code>, or <code>Value</code></p><p>Syntax:</p><pre><code>operation ::= `pdl.create_native` $name ($constParams^)? (`(` $args^ `:` type($args) `)`)? `:` type($result)
              attr-dict
</code></pre><p><code>pdl.create_native</code> operations invoke a native C++ function, that has been
registered externally with the consumer of PDL, to create an <code>Attribute</code>,
<code>Operation</code>, <code>Type</code>, or <code>Value</code>. The native function must produce a value
of the specified return type, and may accept any number of positional
arguments and constant attribute parameters.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%ret</span> <span class=p>=</span> pdl<span class=p>.</span>create_native <span class=s>&#34;myNativeFunc&#34;</span><span class=p>[</span><span class=m>42</span><span class=p>,</span> <span class=s>&#34;gt&#34;</span><span class=p>]</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>attribute
</code></pre></div><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>constParams</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>args</code></td><td>Positional Value</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>Positional Value</td></tr></tbody></table><h3 id=pdlerase-mlirpdleraseop><code>pdl.erase</code> (::mlir::pdl::EraseOp)&nbsp;<a class=headline-hash href=#pdlerase-mlirpdleraseop>¶</a></h3><p>Mark an input operation as <code>erased</code></p><p>Syntax:</p><pre><code>operation ::= `pdl.erase` $operation attr-dict
</code></pre><p><code>pdl.erase</code> operations are used within <code>pdl.rewrite</code> regions to specify that
an input operation should be marked as erased. The semantics of this
operation correspond with the <code>eraseOp</code> method on a <code>PatternRewriter</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>pdl<span class=p>.</span>erase <span class=nv>%root</span>
</code></pre></div><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr></tbody></table><h3 id=pdlinput-mlirpdlinputop><code>pdl.input</code> (::mlir::pdl::InputOp)&nbsp;<a class=headline-hash href=#pdlinput-mlirpdlinputop>¶</a></h3><p>Define an input value in a pattern</p><p>Syntax:</p><pre><code>operation ::= `pdl.input` (`:` $type^)? attr-dict
</code></pre><p><code>pdl.input</code> operations capture external operand edges into an operation
node that originate from operations or block arguments not otherwise
specified within the pattern (e.g. via <code>pdl.operation</code>). These operations
define, and partially constrain, input operands of a given operation.
A <code>pdl.input</code> may partially constrain an input operand by specifying an
expected value type (via a <code>pdl.type</code> operation).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Define an input operand:
</span><span class=c></span><span class=nv>%operand</span> <span class=p>=</span> pdl<span class=p>.</span>input

<span class=c>// Define an input operand with an expected type:
</span><span class=c></span><span class=nv>%type</span> <span class=p>=</span> pdl<span class=p>.</span>type <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%attr</span> <span class=p>=</span> pdl<span class=p>.</span>input <span class=p>:</span> <span class=nv>%type</span>
</code></pre></div><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>val</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h3 id=pdloperation-mlirpdloperationop><code>pdl.operation</code> (::mlir::pdl::OperationOp)&nbsp;<a class=headline-hash href=#pdloperation-mlirpdloperationop>¶</a></h3><p>Define an operation within a pattern</p><p><code>pdl.operation</code> operations define operation nodes within a pattern. Within
a match sequence, i.e. when directly nested within a <code>pdl.pattern</code>, these
operations correspond to input operations, or those that already existing
within the MLIR module. Inside of a <code>pdl.rewrite</code>, these operations
correspond to operations that should be created as part of the replacement
sequence.</p><p><code>pdl.operation</code>s are composed of a name, and a set of attribute, operand,
and result type values, that map to what those that would be on a
constructed instance of that operation. The results of a <code>pdl.operation</code> are
a handle to the operation itself, and a handle to each of the operation
result values.</p><p>When used within a matching context, the name of the operation may be
omitted.</p><p>When used within a rewriting context, i.e. when defined within a
<code>pdl.rewrite</code>, all of the result types must be &ldquo;inferable&rdquo;. This means that
the type must be attributable to either a constant type value or the result
type of another entity, such as an attribute, the result of a
<code>createNative</code>, or the result type of another operation. If the result type
value does not meet any of these criteria, the operation must provide the
<code>InferTypeOpInterface</code> to ensure that the result types can be inferred.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Define an instance of a `foo.op` operation.
</span><span class=c></span><span class=nv>%op</span><span class=p>,</span> <span class=nv>%results</span><span class=p>:</span><span class=nl>4 =</span> pdl<span class=p>.</span>operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>{</span><span class=s>&#34;attrA&#34;</span> <span class=p>=</span> <span class=nv>%attr0</span><span class=p>}</span> <span class=p>-&gt;</span> <span class=nv>%type</span><span class=p>,</span> <span class=nv>%type</span><span class=p>,</span> <span class=nv>%type</span><span class=p>,</span> <span class=nv>%type</span>
</code></pre></div><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>attributeNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>mlir::pdl::ValueType</td></tr><tr><td align=center><code>attributes</code></td><td>mlir::pdl::AttributeType</td></tr><tr><td align=center><code>types</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>op</code></td><td>mlir::pdl::OperationType</td></tr><tr><td align=center><code>results</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h3 id=pdlpattern-mlirpdlpatternop><code>pdl.pattern</code> (::mlir::pdl::PatternOp)&nbsp;<a class=headline-hash href=#pdlpattern-mlirpdlpatternop>¶</a></h3><p>Define a rewrite pattern</p><p>Syntax:</p><pre><code>operation ::= `pdl.pattern` ($sym_name^)? `:` `benefit` `(` $benefit `)`
              (`,` `root` `(` $rootKind^ `)`)? attr-dict-with-keyword $body
</code></pre><p><code>pdl.pattern</code> operations provide a transformable representation for a
<code>RewritePattern</code>. The attributes on this operation correspond to the various
metadata on a <code>RewritePattern</code>, such as the benefit. The match section of
the pattern is specified within the region body, with the rewrite provided
by a terminating <code>pdl.rewrite</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Provide a pattern matching &#34;foo.op&#34; that replaces the root with its
</span><span class=c></span><span class=c>// input.
</span><span class=c></span>pdl<span class=p>.</span>pattern <span class=p>:</span> benefit<span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%resultType</span> <span class=p>=</span> pdl<span class=p>.</span>type
  <span class=nv>%inputOperand</span> <span class=p>=</span> pdl<span class=p>.</span>input
  <span class=nv>%root</span><span class=p>,</span> <span class=nv>%results</span> <span class=p>=</span> pdl<span class=p>.</span>operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%inputOperand</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%resultType</span><span class=p>)</span>
  pdl<span class=p>.</span>rewrite <span class=nv>%root</span> <span class=p>{</span>
    pdl<span class=p>.</span>replace <span class=nv>%root</span> with <span class=p>(</span><span class=nv>%inputOperand</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>rootKind</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>benefit</code></td><td align=center>::mlir::IntegerAttr</td><td>16-bit signless integer attribute whose value is non-negative</td></tr><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=pdlreplace-mlirpdlreplaceop><code>pdl.replace</code> (::mlir::pdl::ReplaceOp)&nbsp;<a class=headline-hash href=#pdlreplace-mlirpdlreplaceop>¶</a></h3><p>Mark an input operation as <code>replaced</code></p><p>Syntax:</p><pre><code>operation ::= `pdl.replace` $operation `with` (`(` $replValues^ `)`)? ($replOperation^)? attr-dict
</code></pre><p><code>pdl.replace</code> operations are used within <code>pdl.rewrite</code> regions to specify
that an input operation should be marked as replaced. The semantics of this
operation correspond with the <code>replaceOp</code> method on a <code>PatternRewriter</code>. The
set of replacement values can be either:</p><ul><li>a single <code>Operation</code> (<code>replOperation</code> should be populated)<ul><li>The operation will be replaced with the results of this operation.</li></ul></li><li>a set of <code>Value</code>s (<code>replValues</code> should be populated)<ul><li>The operation will be replaced with these values.</li></ul></li></ul><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Replace root node with 2 values:
</span><span class=c></span>pdl<span class=p>.</span>replace <span class=nv>%root</span> with <span class=p>(</span><span class=nv>%val0</span><span class=p>,</span> <span class=nv>%val1</span><span class=p>)</span>

<span class=c>// Replace root with another operation:
</span><span class=c></span>pdl<span class=p>.</span>replace <span class=nv>%root</span> with <span class=nv>%otherOp</span>
</code></pre></div><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operation</code></td><td>mlir::pdl::OperationType</td></tr><tr><td align=center><code>replOperation</code></td><td>mlir::pdl::OperationType</td></tr><tr><td align=center><code>replValues</code></td><td>mlir::pdl::ValueType</td></tr></tbody></table><h3 id=pdlrewrite_end-mlirpdlrewriteendop><code>pdl.rewrite_end</code> (::mlir::pdl::RewriteEndOp)&nbsp;<a class=headline-hash href=#pdlrewrite_end-mlirpdlrewriteendop>¶</a></h3><p>Implicit terminator of a <code>pdl.rewrite</code> region</p><p>Syntax:</p><pre><code>operation ::= `pdl.rewrite_end` attr-dict
</code></pre><p><code>pdl.rewrite_end</code> operations terminate the region of a <code>pdl.rewrite</code>.</p><h3 id=pdlrewrite-mlirpdlrewriteop><code>pdl.rewrite</code> (::mlir::pdl::RewriteOp)&nbsp;<a class=headline-hash href=#pdlrewrite-mlirpdlrewriteop>¶</a></h3><p>Specify the rewrite of a matched pattern</p><p>Syntax:</p><pre><code>operation ::= `pdl.rewrite` $root (`with` $name^ ($externalConstParams^)?
              (`(` $externalArgs^ `:` type($externalArgs) `)`)?)?
              ($body^)?
              attr-dict-with-keyword
</code></pre><p><code>pdl.rewrite</code> operations terminate the region of a <code>pdl.pattern</code> and specify
the rewrite of a <code>pdl.pattern</code>, on the specified root operation. The
rewrite is specified either via a string name (<code>name</code>) to an external
rewrite function, or via the region body. The rewrite region, if specified,
must contain a single block and terminate via the <code>pdl.rewrite_end</code>
operation. If the rewrite is external, it also takes a set of constant
parameters and a set of additional positional values defined within the
matcher as arguments.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Specify an external rewrite function:
</span><span class=c></span>pdl<span class=p>.</span>rewrite <span class=nv>%root</span> with <span class=s>&#34;myExternalRewriter&#34;</span><span class=p>(</span><span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span>

<span class=c>// Specify the rewrite inline using PDL:
</span><span class=c></span>pdl<span class=p>.</span>rewrite <span class=nv>%root</span> <span class=p>{</span>
  <span class=nv>%op</span> <span class=p>=</span> pdl<span class=p>.</span>operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span>
  pdl<span class=p>.</span>replace <span class=nv>%root</span> with <span class=nv>%op</span>
<span class=p>}</span>
</code></pre></div><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>externalConstParams</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>root</code></td><td>mlir::pdl::OperationType</td></tr><tr><td align=center><code>externalArgs</code></td><td>Positional Value</td></tr></tbody></table><h3 id=pdltype-mlirpdltypeop><code>pdl.type</code> (::mlir::pdl::TypeOp)&nbsp;<a class=headline-hash href=#pdltype-mlirpdltypeop>¶</a></h3><p>Define a type handle within a pattern</p><p>Syntax:</p><pre><code>operation ::= `pdl.type` attr-dict (`:` $type^)?
</code></pre><p><code>pdl.type</code> operations capture result type constraints of an <code>Attributes</code>,
<code>Values</code>, and <code>Operations</code>. Instances of this operation define, and
partially constrain, results types of a given entity. A <code>pdl.type</code> may
partially constrain the result by specifying a constant <code>Type</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Define a type:
</span><span class=c></span><span class=nv>%attr</span> <span class=p>=</span> pdl<span class=p>.</span>type

<span class=c>// Define a type with a constant value:
</span><span class=c></span><span class=nv>%attr</span> <span class=p>=</span> pdl<span class=p>.</span>type <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>mlir::pdl::TypeType</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/OpenMPDialect/ title="'omp' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'omp' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/PDLInterpOps/ title="'pdl_interp' Dialect">Next - 'pdl_interp' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Builtin/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/AVX512/>'avx512' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmNeon/>'llvm_arm_neon' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmSve/>'llvm_arm_sve' Dialect</a></li><li><a href=/docs/Dialects/LLVMAVX512/>'llvm_avx512' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li class=active><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/TensorPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/Bufferization/>Bufferization on MLIR</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>