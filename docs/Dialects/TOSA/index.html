<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Tensor Operator Set Architecture (TOSA) Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/TOSA/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Tensor Operator Set Architecture (TOSA) Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a></li><li><a href=#tosa-and-tensor-level-expressiveness>TOSA and Tensor Level Expressiveness</a><ul><li><a href=#complete>Complete</a></li><li><a href=#minimal>Minimal</a></li><li><a href=#numerical-precision>Numerical Precision</a></li></ul></li><li><a href=#tosa-operator-rationale>TOSA Operator Rationale</a><ul><li><a href=#identityn>IDENTITYN</a></li><li><a href=#cond_if-and-while_loop>COND\_IF and WHILE\_LOOP</a></li></ul></li><li><a href=#using-tosa-in-a-compiler>Using TOSA In A Compiler</a><ul><li><a href=#quantization-parameters-in-ops-vs-tensors>Quantization Parameters in Ops vs Tensors</a></li></ul></li><li><a href=#operation-definitions>Operation definitions</a><ul><li><a href=#tosaabs-mlirtosaabsop>tosa.abs (mlir::tosa::AbsOp)</a></li><li><a href=#tosaadd-mlirtosaaddop>tosa.add (mlir::tosa::AddOp)</a></li><li><a href=#tosaargmax-mlirtosaargmaxop>tosa.argmax (mlir::tosa::ArgMaxOp)</a></li><li><a href=#tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop>tosa.arithmetic_right_shift (mlir::tosa::ArithmeticRightShiftOp)</a></li><li><a href=#tosaavg_pool2d-mlirtosaavgpool2dop>tosa.avg_pool2d (mlir::tosa::AvgPool2dOp)</a></li><li><a href=#tosabitwise_and-mlirtosabitwiseandop>tosa.bitwise_and (mlir::tosa::BitwiseAndOp)</a></li><li><a href=#tosabitwise_not-mlirtosabitwisenotop>tosa.bitwise_not (mlir::tosa::BitwiseNotOp)</a></li><li><a href=#tosabitwise_or-mlirtosabitwiseorop>tosa.bitwise_or (mlir::tosa::BitwiseOrOp)</a></li><li><a href=#tosabitwise_xor-mlirtosabitwisexorop>tosa.bitwise_xor (mlir::tosa::BitwiseXorOp)</a></li><li><a href=#tosacast-mlirtosacastop>tosa.cast (mlir::tosa::CastOp)</a></li><li><a href=#tosaceil-mlirtosaceilop>tosa.ceil (mlir::tosa::CeilOp)</a></li><li><a href=#tosaclamp-mlirtosaclampop>tosa.clamp (mlir::tosa::ClampOp)</a></li><li><a href=#tosaclz-mlirtosaclzop>tosa.clz (mlir::tosa::ClzOp)</a></li><li><a href=#tosaconcat-mlirtosaconcatop>tosa.concat (mlir::tosa::ConcatOp)</a></li><li><a href=#tosaconst-mlirtosaconstop>tosa.const (mlir::tosa::ConstOp)</a></li><li><a href=#tosaconv2d-mlirtosaconv2dop>tosa.conv2d (mlir::tosa::Conv2DOp)</a></li><li><a href=#tosaconv3d-mlirtosaconv3dop>tosa.conv3d (mlir::tosa::Conv3DOp)</a></li><li><a href=#tosacustom-mlirtosacustomop>tosa.custom (mlir::tosa::CustomOp)</a></li><li><a href=#tosadepthwise_conv2d-mlirtosadepthwiseconv2dop>tosa.depthwise_conv2d (mlir::tosa::DepthwiseConv2DOp)</a></li><li><a href=#tosaequal-mlirtosaequalop>tosa.equal (mlir::tosa::EqualOp)</a></li><li><a href=#tosaexp-mlirtosaexpop>tosa.exp (mlir::tosa::ExpOp)</a></li><li><a href=#tosafloor-mlirtosafloorop>tosa.floor (mlir::tosa::FloorOp)</a></li><li><a href=#tosafully_connected-mlirtosafullyconnectedop>tosa.fully_connected (mlir::tosa::FullyConnectedOp)</a></li><li><a href=#tosagather-mlirtosagatherop>tosa.gather (mlir::tosa::GatherOp)</a></li><li><a href=#tosagreater_equal-mlirtosagreaterequalop>tosa.greater_equal (mlir::tosa::GreaterEqualOp)</a></li><li><a href=#tosagreater-mlirtosagreaterop>tosa.greater (mlir::tosa::GreaterOp)</a></li><li><a href=#tosaidentityn-mlirtosaidentitynop>tosa.identityn (mlir::tosa::IdentityNOp)</a></li><li><a href=#tosaidentity-mlirtosaidentityop>tosa.identity (mlir::tosa::IdentityOp)</a></li><li><a href=#tosacond_if-mlirtosaifop>tosa.cond_if (mlir::tosa::IfOp)</a></li><li><a href=#tosalog-mlirtosalogop>tosa.log (mlir::tosa::LogOp)</a></li><li><a href=#tosalogical_and-mlirtosalogicalandop>tosa.logical_and (mlir::tosa::LogicalAndOp)</a></li><li><a href=#tosalogical_left_shift-mlirtosalogicalleftshiftop>tosa.logical_left_shift (mlir::tosa::LogicalLeftShiftOp)</a></li><li><a href=#tosalogical_not-mlirtosalogicalnotop>tosa.logical_not (mlir::tosa::LogicalNotOp)</a></li><li><a href=#tosalogical_or-mlirtosalogicalorop>tosa.logical_or (mlir::tosa::LogicalOrOp)</a></li><li><a href=#tosalogical_right_shift-mlirtosalogicalrightshiftop>tosa.logical_right_shift (mlir::tosa::LogicalRightShiftOp)</a></li><li><a href=#tosalogical_xor-mlirtosalogicalxorop>tosa.logical_xor (mlir::tosa::LogicalXorOp)</a></li><li><a href=#tosamatmul-mlirtosamatmulop>tosa.matmul (mlir::tosa::MatMulOp)</a></li><li><a href=#tosamax_pool2d-mlirtosamaxpool2dop>tosa.max_pool2d (mlir::tosa::MaxPool2dOp)</a></li><li><a href=#tosamaximum-mlirtosamaximumop>tosa.maximum (mlir::tosa::MaximumOp)</a></li><li><a href=#tosaminimum-mlirtosaminimumop>tosa.minimum (mlir::tosa::MinimumOp)</a></li><li><a href=#tosamul-mlirtosamulop>tosa.mul (mlir::tosa::MulOp)</a></li><li><a href=#tosanegate-mlirtosanegateop>tosa.negate (mlir::tosa::NegateOp)</a></li><li><a href=#tosapad-mlirtosapadop>tosa.pad (mlir::tosa::PadOp)</a></li><li><a href=#tosaplaceholder-mlirtosaplaceholderop>tosa.placeholder (mlir::tosa::PlaceholderOp)</a></li><li><a href=#tosapow-mlirtosapowop>tosa.pow (mlir::tosa::PowOp)</a></li><li><a href=#tosareciprocal-mlirtosareciprocalop>tosa.reciprocal (mlir::tosa::ReciprocalOp)</a></li><li><a href=#tosareduce_all-mlirtosareduceallop>tosa.reduce_all (mlir::tosa::ReduceAllOp)</a></li><li><a href=#tosareduce_any-mlirtosareduceanyop>tosa.reduce_any (mlir::tosa::ReduceAnyOp)</a></li><li><a href=#tosareduce_max-mlirtosareducemaxop>tosa.reduce_max (mlir::tosa::ReduceMaxOp)</a></li><li><a href=#tosareduce_min-mlirtosareduceminop>tosa.reduce_min (mlir::tosa::ReduceMinOp)</a></li><li><a href=#tosareduce_prod-mlirtosareduceprodop>tosa.reduce_prod (mlir::tosa::ReduceProdOp)</a></li><li><a href=#tosareduce_sum-mlirtosareducesumop>tosa.reduce_sum (mlir::tosa::ReduceSumOp)</a></li><li><a href=#tosarelun-mlirtosarelunop>tosa.reluN (mlir::tosa::ReluNOp)</a></li><li><a href=#tosarescale-mlirtosarescaleop>tosa.rescale (mlir::tosa::RescaleOp)</a></li><li><a href=#tosareshape-mlirtosareshapeop>tosa.reshape (mlir::tosa::ReshapeOp)</a></li><li><a href=#tosaresize-mlirtosaresizeop>tosa.resize (mlir::tosa::ResizeOp)</a></li><li><a href=#tosareverse-mlirtosareverseop>tosa.reverse (mlir::tosa::ReverseOp)</a></li><li><a href=#tosarsqrt-mlirtosarsqrtop>tosa.rsqrt (mlir::tosa::RsqrtOp)</a></li><li><a href=#tosaselect-mlirtosaselectop>tosa.select (mlir::tosa::SelectOp)</a></li><li><a href=#tosasigmoid-mlirtosasigmoidop>tosa.sigmoid (mlir::tosa::SigmoidOp)</a></li><li><a href=#tosaslice-mlirtosasliceop>tosa.slice (mlir::tosa::SliceOp)</a></li><li><a href=#tosasub-mlirtosasubop>tosa.sub (mlir::tosa::SubOp)</a></li><li><a href=#tosatable-mlirtosatableop>tosa.table (mlir::tosa::TableOp)</a></li><li><a href=#tosatanh-mlirtosatanhop>tosa.tanh (mlir::tosa::TanhOp)</a></li><li><a href=#tosatile-mlirtosatileop>tosa.tile (mlir::tosa::TileOp)</a></li><li><a href=#tosatranspose_conv2d-mlirtosatransposeconv2dop>tosa.transpose_conv2d (mlir::tosa::TransposeConv2DOp)</a></li><li><a href=#tosatranspose-mlirtosatransposeop>tosa.transpose (mlir::tosa::TransposeOp)</a></li><li><a href=#tosawhile_loop-mlirtosawhileop>tosa.while_loop (mlir::tosa::WhileOp)</a></li><li><a href=#tosayield-mlirtosayieldop>tosa.yield (mlir::tosa::YieldOp)</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>The MLIR TOSA dialect implements the
<a href=https://developer.mlplatform.org/w/tosa/>TOSA
specification</a>
. This document
describes the decision process for how TOSA expresses operators in
high level dialects.</p><p>TOSA was developed after parallel efforts to rationalize the top-down picture
from multiple high-level frameworks, as well as a bottom-up view of different
hardware target concerns (CPU, GPU and NPU), and reflects a set of choices
that attempt to manage both sets of requirements.</p><h2 id=tosa-and-tensor-level-expressiveness>TOSA and Tensor Level Expressiveness&nbsp;<a class=headline-hash href=#tosa-and-tensor-level-expressiveness>¶</a></h2><p>TOSA endeavors to provide an operator set that tries to fulfil the following
expressivenes goals at the <em>tensor level of abstraction</em> :</p><h3 id=complete>Complete&nbsp;<a class=headline-hash href=#complete>¶</a></h3><p>This is driven by the top-down perspective, needing to express as much of
multiple high level frameworks fully in TOSA, as possible. This was originally
done from an operator frequency analysis done upon dozens of high level
networks in different frameworks, to select the most frequently occuring ones
and establish a common set of tensor-level operators that could express them.</p><p>TOSA categorizes its operator set into classes and attempts to address major
functional operations at the tensor level, including compute, reduction,
elementwise transformations, comparison and control flow.</p><h3 id=minimal>Minimal&nbsp;<a class=headline-hash href=#minimal>¶</a></h3><p>This takes the bottom-up approach - keep the TOSA operator set minimal in
order to bound the design of hardware, operator kernels, code generation
strategies and associated considerations that effect the executability of TOSA
content.</p><p>In this regard TOSA seeks to avoid creating compound operators, instead
leaving it to compiler backend to fuse multiple TOSA ops if required. This
choice also benefits the numerical precision goal, since it is easier to fuse the
numerical functionality of successive operators, than to split the numerical
functionality of a compound operator.</p><h3 id=numerical-precision>Numerical Precision&nbsp;<a class=headline-hash href=#numerical-precision>¶</a></h3><p>TOSA began as a means to address operator-level numerical precision for
code generation and hardware development. It therefore incorporates precision
detail into the operator set.</p><p>In this regard, TOSA operators are best understood as a combination of the visible
quantization information embedded within an operation, together with the
functional information about how that information is used, as described in the
specification of the operation.</p><h2 id=tosa-operator-rationale>TOSA Operator Rationale&nbsp;<a class=headline-hash href=#tosa-operator-rationale>¶</a></h2><p>The general basis of selection of the operator set that constitutes TOSA is
described in the TOSA specification document under Section 1.3 Operator
Selection. Explanation of the thinking behind some operators is listed here:</p><h3 id=identityn>IDENTITYN&nbsp;<a class=headline-hash href=#identityn>¶</a></h3><p>tosa.IDENTITYN is used to form a list of Operator results during
lowering of operations such as tf.Split from a sequence of tosa.SLICE
ops. If there are alternate ways to express this lowering without the
tosa.IDENTITYN op, the tosa.IDENTITYN op could be removed from TOSA.</p><pre><code>Value lower_split_op(Value %value, size_t axis, size_t
num_split) { Value %output[]

    size_t slice_size = %value.shape[axis] / num_split

    for (int i = 0; i &lt; num_split; i++) {
        vector &lt;size_t&gt; begin_vals, size_vals

        for (int j = 0; j &lt; %value.rank; j++) {
            if (j == axis) {
               begin_vals.push_back(slice_size * i)
               size_vals.push_back(slice_size)
            } else {
               begin_vals.push_back(0)
               size_vals.push_bac(%value.shape[j])
            }

            %output[i] = tosa.SLICE(%value) {start=begin_vals, size=size_vals} (tensor&lt;%value.type&gt;) -&gt; tensor&lt;size_vals, %value.dtype&gt;
        }

    }

    %output_list = tosa.IDENTITYN(%output) (tensor&lt;%output:*.type&gt;) -&gt; tensor&lt;%output_list:*.type&gt;
    return %output_list
}
</code></pre><h3 id=cond_if-and-while_loop>COND_IF and WHILE_LOOP&nbsp;<a class=headline-hash href=#cond_if-and-while_loop>¶</a></h3><p>Several neural networks express conditional control flow at the tensor level.
A survey of multiple high level frameworks indicated that conditional if and
a loop construct are common in all major frameworks, with some variation.
Since TOSA endeavors to be complete in expressing tensor level functionality
including control flow, it implements these constructs.</p><p>The COND_IF and WHILE_LOOP operators implement such structured control
flow forms and should be lowerable to corresponding ops in the scf dialect.
Since the dialect seeks to remain isomorphic with an external, serialized form,
the decision was to keep these ops in the dialect (as opposed to deferring
completely to scf), and this may be re-evaluated if this turns out to not yield
the expected value.</p><h2 id=using-tosa-in-a-compiler>Using TOSA In A Compiler&nbsp;<a class=headline-hash href=#using-tosa-in-a-compiler>¶</a></h2><p>The TOSA specification describes each operator in functional detail. It is
expected that compilers that use TOSA will use its builders to construct the
operators so that the quantization information for the operator is correctly
generated.</p><p>The functional steps described in the pseudocode of the specification enables
the construction of code generation for that operation, or decisions on the
design of underlying hardware. The functional pseudocode also describes
how the quantization parameters are utilized within the operation.</p><h3 id=quantization-parameters-in-ops-vs-tensors>Quantization Parameters in Ops vs Tensors&nbsp;<a class=headline-hash href=#quantization-parameters-in-ops-vs-tensors>¶</a></h3><p>TOSA uses the quantization parameters embedded in the input and output
tensors to construct the quantization attributes that sit within the operator.
Once these attributes are constructed, the quantization information within
the tensors are no longer necessary for code generation.</p><p>This enables the tensors to be subsequently interpreted simply as contiguous
buffers containing raw data, with no &lsquo;meta information&rsquo; in the form of the
quantization_type. Precision related manipulation of the input or output are
instead described by the operator itself which describes, for example, when
the zero point is applied, or when the scale multiplication is done.</p><p>However, TOSA does <em>not</em> eliminate the existing MLIR QuantOps quantization
type information within the tensors; this leaves the choice of how to handle
quantization information, to later backend code generation steps.</p><p>Maintaining the ability to overlap these different representations of
quantization parameters (i.e. tensor-carried vs op-carried) is an important
capability when considering progressive lowering between uses that expect one
scheme vs the other.</p><h2 id=operation-definitions>Operation definitions&nbsp;<a class=headline-hash href=#operation-definitions>¶</a></h2><h3 id=tosaabs-mlirtosaabsop><code>tosa.abs</code> (mlir::tosa::AbsOp)&nbsp;<a class=headline-hash href=#tosaabs-mlirtosaabsop>¶</a></h3><p>Elementwise abs op</p><p>Elementwise absolute value operation</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaadd-mlirtosaaddop><code>tosa.add</code> (mlir::tosa::AddOp)&nbsp;<a class=headline-hash href=#tosaadd-mlirtosaaddop>¶</a></h3><p>Elementwise addition operator</p><p>Elementwise addition of input1 and input2. Axis of size 1 will be broadcast,
as necessary. Rank of input tensors must match.</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaargmax-mlirtosaargmaxop><code>tosa.argmax</code> (mlir::tosa::ArgMaxOp)&nbsp;<a class=headline-hash href=#tosaargmax-mlirtosaargmaxop>¶</a></h3><p>Perform argmax on the input.</p><p>This returns the index with the largest value across the given axis of the
input tensor.</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop><code>tosa.arithmetic_right_shift</code> (mlir::tosa::ArithmeticRightShiftOp)&nbsp;<a class=headline-hash href=#tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop>¶</a></h3><p>Elementwise Arithmetic Right Shift</p><p>Elementwise arithmetic right shift of input1 by the amount specified in
input2. Axis of size 1 will be broadcast, as necessary. Rank of input
tensors must match.</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>round</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaavg_pool2d-mlirtosaavgpool2dop><code>tosa.avg_pool2d</code> (mlir::tosa::AvgPool2dOp)&nbsp;<a class=headline-hash href=#tosaavg_pool2d-mlirtosaavgpool2dop>¶</a></h3><p>Performs max pooling on the input.</p><p>This performs an average pooling over the given input tensor. A sliding
window of size given by <kernel size>is passed over the input tensor, with
the mean value being placed in the output tensor.</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>kernel</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>pad</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::UnaryOpQuantizationAttr</td><td>Attribute for UnaryOp quantization information.</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>4D tensor of number values</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>4D tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_and-mlirtosabitwiseandop><code>tosa.bitwise_and</code> (mlir::tosa::BitwiseAndOp)&nbsp;<a class=headline-hash href=#tosabitwise_and-mlirtosabitwiseandop>¶</a></h3><p>Bitwise AND operator</p><p>Elementwise bitwise AND of input1 and input2. Axis of size 1
will be broadcast as necessary. Rank of input tensors must match.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_not-mlirtosabitwisenotop><code>tosa.bitwise_not</code> (mlir::tosa::BitwiseNotOp)&nbsp;<a class=headline-hash href=#tosabitwise_not-mlirtosabitwisenotop>¶</a></h3><p>Bitwise NOT operator</p><p>Elementwise bitwise NOT of input tensor.</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_or-mlirtosabitwiseorop><code>tosa.bitwise_or</code> (mlir::tosa::BitwiseOrOp)&nbsp;<a class=headline-hash href=#tosabitwise_or-mlirtosabitwiseorop>¶</a></h3><p>Bitwise OR operator</p><p>Elementwise bitwise OR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_xor-mlirtosabitwisexorop><code>tosa.bitwise_xor</code> (mlir::tosa::BitwiseXorOp)&nbsp;<a class=headline-hash href=#tosabitwise_xor-mlirtosabitwisexorop>¶</a></h3><p>Bitwise XOR operator</p><p>Elementwise bitwise XOR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosacast-mlirtosacastop><code>tosa.cast</code> (mlir::tosa::CastOp)&nbsp;<a class=headline-hash href=#tosacast-mlirtosacastop>¶</a></h3><p>Cast operation</p><p>Performs a set of permissible cast operations
Mode Input Output
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
signed 8 to bool int8 Boolean
signed 16 to bool int16 Boolean
signed 32 to bool int32 Boolean
bool to 8 Boolean int8
bool to 16 Boolean int16
bool to 32 Boolean int32
signed 8 to signed 16 int8 int16
signed 8 to signed 32 int8 int32
signed 16 to signed 8 int16 int8
signed 16 to signed 32 int16 int32
signed 32 to signed 8 int32 int8
signed 32 to signed 16 int32 int16
float to signed 8 float int8
float to signed 16 float int16
signed 8 to float int8 float
signed 16 to float int16 float</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaceil-mlirtosaceilop><code>tosa.ceil</code> (mlir::tosa::CeilOp)&nbsp;<a class=headline-hash href=#tosaceil-mlirtosaceilop>¶</a></h3><p>Elementwise ceil op</p><p>Elementwise ceiling operation</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaclamp-mlirtosaclampop><code>tosa.clamp</code> (mlir::tosa::ClampOp)&nbsp;<a class=headline-hash href=#tosaclamp-mlirtosaclampop>¶</a></h3><p>Computes clamp(features, min, max).</p><p>Clamp to an arbitrary minimum and maximum value. Note that the maximum and
minimum values are specified as signed quantized values, no scaling happens
before or after this operation.</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>min_int</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>max_int</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>min_fp</code></td><td align=center>::mlir::FloatAttr</td><td>32-bit float attribute</td></tr><tr><td align=center><code>max_fp</code></td><td align=center>::mlir::FloatAttr</td><td>32-bit float attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaclz-mlirtosaclzop><code>tosa.clz</code> (mlir::tosa::ClzOp)&nbsp;<a class=headline-hash href=#tosaclz-mlirtosaclzop>¶</a></h3><p>Elementwise count leading zero op</p><p>Elementwise count leading zeros operation</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaconcat-mlirtosaconcatop><code>tosa.concat</code> (mlir::tosa::ConcatOp)&nbsp;<a class=headline-hash href=#tosaconcat-mlirtosaconcatop>¶</a></h3><p>Concatenates tensors along one dimension.</p><p>Concatenate two tensors along a given axis. No data conversion happens
during a concat operation.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaconst-mlirtosaconstop><code>tosa.const</code> (mlir::tosa::ConstOp)&nbsp;<a class=headline-hash href=#tosaconst-mlirtosaconstop>¶</a></h3><p>Constant op.</p><p>A node containing constant data for use as the input to an operation. May
hold data in any of the supported data formats.</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaconv2d-mlirtosaconv2dop><code>tosa.conv2d</code> (mlir::tosa::Conv2DOp)&nbsp;<a class=headline-hash href=#tosaconv2d-mlirtosaconv2dop>¶</a></h3><p>2D Convolution Operator</p><p>Performs a 2D convolution over the given tensor input, using the weight
tensor.</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pad</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>dilation</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>4D tensor of number values</td></tr><tr><td align=center><code>weight</code></td><td>4D tensor of number values</td></tr><tr><td align=center><code>bias</code></td><td>1D tensor of number values</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>4D tensor of number values</td></tr></tbody></table><h3 id=tosaconv3d-mlirtosaconv3dop><code>tosa.conv3d</code> (mlir::tosa::Conv3DOp)&nbsp;<a class=headline-hash href=#tosaconv3d-mlirtosaconv3dop>¶</a></h3><p>3D Convolution operator</p><p>Performs a 3D convolution over the given input tensor.</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pad</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 6 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 3 elements</td></tr><tr><td align=center><code>dilation</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 3 elements</td></tr><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>5D tensor of number values</td></tr><tr><td align=center><code>weight</code></td><td>5D tensor of number values</td></tr><tr><td align=center><code>bias</code></td><td>1D tensor of number values</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>5D tensor of number values</td></tr></tbody></table><h3 id=tosacustom-mlirtosacustomop><code>tosa.custom</code> (mlir::tosa::CustomOp)&nbsp;<a class=headline-hash href=#tosacustom-mlirtosacustomop>¶</a></h3><p>Custom operator wrapper for Tosa</p><p>Hardware implementing TOSA may choose to add additional custom operators
that are not expressed in the existing TOSA operations. These operators are
not expected to be portable across TOSA implementations. The input and
output signatures must be expressed in the corresponding TOSA node.</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>identifier</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>outputs</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosadepthwise_conv2d-mlirtosadepthwiseconv2dop><code>tosa.depthwise_conv2d</code> (mlir::tosa::DepthwiseConv2DOp)&nbsp;<a class=headline-hash href=#tosadepthwise_conv2d-mlirtosadepthwiseconv2dop>¶</a></h3><p>Depthwise 2D Convolution operator</p><p>Performs 2D convolutions separately over each channel of the given tensor
input, using the weight tensor.</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pad</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>dilation</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>4D tensor of number values</td></tr><tr><td align=center><code>weight</code></td><td>4D tensor of number values</td></tr><tr><td align=center><code>bias</code></td><td>1D tensor of number values</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>4D tensor of number values</td></tr></tbody></table><h3 id=tosaequal-mlirtosaequalop><code>tosa.equal</code> (mlir::tosa::EqualOp)&nbsp;<a class=headline-hash href=#tosaequal-mlirtosaequalop>¶</a></h3><p>Returns the truth value of (x == y) element-wise.</p><p>Elementwise comparison operation</p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosaexp-mlirtosaexpop><code>tosa.exp</code> (mlir::tosa::ExpOp)&nbsp;<a class=headline-hash href=#tosaexp-mlirtosaexpop>¶</a></h3><p>Elementwise exp op</p><p>Elementwise e to the x operation</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosafloor-mlirtosafloorop><code>tosa.floor</code> (mlir::tosa::FloorOp)&nbsp;<a class=headline-hash href=#tosafloor-mlirtosafloorop>¶</a></h3><p>Elementwise floor op</p><p>Elementwise floor operation</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosafully_connected-mlirtosafullyconnectedop><code>tosa.fully_connected</code> (mlir::tosa::FullyConnectedOp)&nbsp;<a class=headline-hash href=#tosafully_connected-mlirtosafullyconnectedop>¶</a></h3><p>Fully Connected operator</p><p>Performs a fully connected network.</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>2D tensor of number values</td></tr><tr><td align=center><code>weight</code></td><td>2D tensor of number values</td></tr><tr><td align=center><code>bias</code></td><td>1D tensor of number values</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>2D tensor of number values</td></tr></tbody></table><h3 id=tosagather-mlirtosagatherop><code>tosa.gather</code> (mlir::tosa::GatherOp)&nbsp;<a class=headline-hash href=#tosagather-mlirtosagatherop>¶</a></h3><p>Gather operation,</p><p>Generate a tensor for which each element in the output is a subtensor of the
values tensor along the given axis, based on the value of indices.</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>indices</code></td><td>tensor of 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td align=center><code>values</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosagreater_equal-mlirtosagreaterequalop><code>tosa.greater_equal</code> (mlir::tosa::GreaterEqualOp)&nbsp;<a class=headline-hash href=#tosagreater_equal-mlirtosagreaterequalop>¶</a></h3><p>Returns the truth value of (x >= y) element-wise.</p><p>Elementwise comparison operation</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosagreater-mlirtosagreaterop><code>tosa.greater</code> (mlir::tosa::GreaterOp)&nbsp;<a class=headline-hash href=#tosagreater-mlirtosagreaterop>¶</a></h3><p>Returns the truth value of (x > y) element-wise.</p><p>Elementwise greater than comparison operation</p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosaidentityn-mlirtosaidentitynop><code>tosa.identityn</code> (mlir::tosa::IdentityNOp)&nbsp;<a class=headline-hash href=#tosaidentityn-mlirtosaidentitynop>¶</a></h3><p>IdentityN operator</p><p>Returns a list of tensors with the same shape, type, and contents as the
input list of tensors.</p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosaidentity-mlirtosaidentityop><code>tosa.identity</code> (mlir::tosa::IdentityOp)&nbsp;<a class=headline-hash href=#tosaidentity-mlirtosaidentityop>¶</a></h3><p>Identity operator</p><p>Returns a tensor with the same shape, size, type
and content as the input.</p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosacond_if-mlirtosaifop><code>tosa.cond_if</code> (mlir::tosa::IfOp)&nbsp;<a class=headline-hash href=#tosacond_if-mlirtosaifop>¶</a></h3><p>Conditional if operator</p><p>Evaluates a Boolean condition and then takes one of two distinct execution
paths. This implements the semantic If-then-else structure.</p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td align=center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosalog-mlirtosalogop><code>tosa.log</code> (mlir::tosa::LogOp)&nbsp;<a class=headline-hash href=#tosalog-mlirtosalogop>¶</a></h3><p>Elementwise log op</p><p>Elementwise natural logarithm operation</p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosalogical_and-mlirtosalogicalandop><code>tosa.logical_and</code> (mlir::tosa::LogicalAndOp)&nbsp;<a class=headline-hash href=#tosalogical_and-mlirtosalogicalandop>¶</a></h3><p>Returns the truth value of x AND y element-wise.</p><p>Elementwise logical AND of input1 and input2. Axis of size 1 will be
broadcast, as necessary. Rank of input tensors must match.</p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td align=center><code>input2</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>z</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_left_shift-mlirtosalogicalleftshiftop><code>tosa.logical_left_shift</code> (mlir::tosa::LogicalLeftShiftOp)&nbsp;<a class=headline-hash href=#tosalogical_left_shift-mlirtosalogicalleftshiftop>¶</a></h3><p>Elementwise Logical Left Shift</p><p>Elementwise left shift of input1 and input2. Axis of size 1 will be
broadcast, as necessary. Rank of input tensors must match.</p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosalogical_not-mlirtosalogicalnotop><code>tosa.logical_not</code> (mlir::tosa::LogicalNotOp)&nbsp;<a class=headline-hash href=#tosalogical_not-mlirtosalogicalnotop>¶</a></h3><p>Returns the truth value of NOT x element-wise.</p><p>Elementwise logical NOT of input.</p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_or-mlirtosalogicalorop><code>tosa.logical_or</code> (mlir::tosa::LogicalOrOp)&nbsp;<a class=headline-hash href=#tosalogical_or-mlirtosalogicalorop>¶</a></h3><p>Returns the truth value of x OR y element-wise.</p><p>Elementwise logical OR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td align=center><code>input2</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>z</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_right_shift-mlirtosalogicalrightshiftop><code>tosa.logical_right_shift</code> (mlir::tosa::LogicalRightShiftOp)&nbsp;<a class=headline-hash href=#tosalogical_right_shift-mlirtosalogicalrightshiftop>¶</a></h3><p>Elementwise Logical Right Shift</p><p>Elementwise logical right shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary.
Rank of input tensors must match.</p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosalogical_xor-mlirtosalogicalxorop><code>tosa.logical_xor</code> (mlir::tosa::LogicalXorOp)&nbsp;<a class=headline-hash href=#tosalogical_xor-mlirtosalogicalxorop>¶</a></h3><p>Returns the truth value of x XOR y element-wise.</p><p>Elementwise logical XOR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td align=center><code>input2</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>z</code></td><td>tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosamatmul-mlirtosamatmulop><code>tosa.matmul</code> (mlir::tosa::MatMulOp)&nbsp;<a class=headline-hash href=#tosamatmul-mlirtosamatmulop>¶</a></h3><p>Matrix multiplication with bias</p><p>Performs a two dimensional matrix multiplication. This allows both inputs to
be activations, rather than reserving weights as an attribute in the
FULLY_CONNECTED operator.</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::MatMulOpQuantizationAttr</td><td>Attribute for MatMulOp quantization information.</td></tr></tbody></table><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>2D tensor of number values</td></tr><tr><td align=center><code>b</code></td><td>2D tensor of number values</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>c</code></td><td>2D tensor of number values</td></tr></tbody></table><h3 id=tosamax_pool2d-mlirtosamaxpool2dop><code>tosa.max_pool2d</code> (mlir::tosa::MaxPool2dOp)&nbsp;<a class=headline-hash href=#tosamax_pool2d-mlirtosamaxpool2dop>¶</a></h3><p>Performs max pooling on the input.</p><p>This performs a max pooling over the given input tensor. A sliding window of
size given by <kernel size>is passed over the input tensor, with the
maximum value being placed in the
output tensor.</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>kernel</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>pad</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 4 elements</td></tr></tbody></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>4D tensor of number values</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>4D tensor of number values</td></tr></tbody></table><h3 id=tosamaximum-mlirtosamaximumop><code>tosa.maximum</code> (mlir::tosa::MaximumOp)&nbsp;<a class=headline-hash href=#tosamaximum-mlirtosamaximumop>¶</a></h3><p>Elementwise Maximum</p><p>Elementwise max of input1 and input2. Axis of size 1 will be broadcast, as
necessary. Rank of input tensors must match.</p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaminimum-mlirtosaminimumop><code>tosa.minimum</code> (mlir::tosa::MinimumOp)&nbsp;<a class=headline-hash href=#tosaminimum-mlirtosaminimumop>¶</a></h3><p>Elementwise Minimum</p><p>Elementwise minimum of input1 and input2. Axis of size 1
will be broadcast, as necessary. Rank of input tensors must match.</p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosamul-mlirtosamulop><code>tosa.mul</code> (mlir::tosa::MulOp)&nbsp;<a class=headline-hash href=#tosamul-mlirtosamulop>¶</a></h3><p>Multiplication operator</p><p>Elementwise multiplication (Hadamard product) of input1 and input2.
Axis of size 1 will be broadcast, as necessary.
Rank of input tensors must match.</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>shift</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosanegate-mlirtosanegateop><code>tosa.negate</code> (mlir::tosa::NegateOp)&nbsp;<a class=headline-hash href=#tosanegate-mlirtosanegateop>¶</a></h3><p>Elementwise negate op</p><p>Elementwise negation operation</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::UnaryOpQuantizationAttr</td><td>Attribute for UnaryOp quantization information.</td></tr></tbody></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosapad-mlirtosapadop><code>tosa.pad</code> (mlir::tosa::PadOp)&nbsp;<a class=headline-hash href=#tosapad-mlirtosapadop>¶</a></h3><p>Pads a tensor with zeros.</p><p>Zero-pads a tensor along borders of each dimension.</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::PadOpQuantizationAttr</td><td>Attribute for PadOp quantization information.</td></tr></tbody></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>padding</code></td><td>tensor of 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaplaceholder-mlirtosaplaceholderop><code>tosa.placeholder</code> (mlir::tosa::PlaceholderOp)&nbsp;<a class=headline-hash href=#tosaplaceholder-mlirtosaplaceholderop>¶</a></h3><p>Placeholder op</p><p>A node where data will be inserted into the network at runtime. Generally
used for inputs to the network.</p><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosapow-mlirtosapowop><code>tosa.pow</code> (mlir::tosa::PowOp)&nbsp;<a class=headline-hash href=#tosapow-mlirtosapowop>¶</a></h3><p>Computes the power of one value to another.</p><p>Elementwise input1 raised to the power of input2.
Axis of size 1 will be broadcast, as necessary.
Rank of input tensors must match.</p><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>z</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareciprocal-mlirtosareciprocalop><code>tosa.reciprocal</code> (mlir::tosa::ReciprocalOp)&nbsp;<a class=headline-hash href=#tosareciprocal-mlirtosareciprocalop>¶</a></h3><p>Elementwise reciprocal op</p><p>Elementwise reciprocal operation. For integer operation, a TABLE should be
used with the appropriate ranges.</p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_all-mlirtosareduceallop><code>tosa.reduce_all</code> (mlir::tosa::ReduceAllOp)&nbsp;<a class=headline-hash href=#tosareduce_all-mlirtosareduceallop>¶</a></h3><p>Reduce All operator</p><p>Reduce a tensor along the given axis with a logical AND operation</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_any-mlirtosareduceanyop><code>tosa.reduce_any</code> (mlir::tosa::ReduceAnyOp)&nbsp;<a class=headline-hash href=#tosareduce_any-mlirtosareduceanyop>¶</a></h3><p>Reduce Any operator</p><p>Reduce a tensor along the given axis with a logical OR operation</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_max-mlirtosareducemaxop><code>tosa.reduce_max</code> (mlir::tosa::ReduceMaxOp)&nbsp;<a class=headline-hash href=#tosareduce_max-mlirtosareducemaxop>¶</a></h3><p>Reduce Max operator</p><p>Reduce a tensor along the given axis with a maximum operation</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_min-mlirtosareduceminop><code>tosa.reduce_min</code> (mlir::tosa::ReduceMinOp)&nbsp;<a class=headline-hash href=#tosareduce_min-mlirtosareduceminop>¶</a></h3><p>Reduce Min operator</p><p>Reduce a tensor along the given axis with a minimum operation</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_prod-mlirtosareduceprodop><code>tosa.reduce_prod</code> (mlir::tosa::ReduceProdOp)&nbsp;<a class=headline-hash href=#tosareduce_prod-mlirtosareduceprodop>¶</a></h3><p>Reduce Prod operator</p><p>Reduce a tensor along the given axis by computing the product of the axis.</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareduce_sum-mlirtosareducesumop><code>tosa.reduce_sum</code> (mlir::tosa::ReduceSumOp)&nbsp;<a class=headline-hash href=#tosareduce_sum-mlirtosareducesumop>¶</a></h3><p>Reduce Sum operator</p><p>Reduce a tensor along the given axis by computing the sum of the axis.</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosarelun-mlirtosarelunop><code>tosa.reluN</code> (mlir::tosa::ReluNOp)&nbsp;<a class=headline-hash href=#tosarelun-mlirtosarelunop>¶</a></h3><p>Computes rectified linear: <code>max(features, N)</code>.</p><p>ReLU with a scalar maximum value.</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>max_int</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>max_fp</code></td><td align=center>::mlir::FloatAttr</td><td>32-bit float attribute</td></tr></tbody></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosarescale-mlirtosarescaleop><code>tosa.rescale</code> (mlir::tosa::RescaleOp)&nbsp;<a class=headline-hash href=#tosarescale-mlirtosarescaleop>¶</a></h3><p>Tosa rescale operator</p><p>Rescale quantized values into a new domain. Supported rescalings are:
Mode Input Output
signed 8 to 8 aint8 aint8
signed 8 to 16 aint8 int16
signed 8 to 32 aint8 int32
signed 16 to 8 int16 aint8
signed 16 to 16 int16 int16
signed 16 to 32 int16 int32
signed 32 to 8 int32 aint8
signed 32 to 16 int32 int16
signed 32 to 32 int32 int32
signed 48 to 8 int48 aint8
signed 48 to 16 int48 int16
signed 48 to 32 int48 int32
unsigned 8 to signed 8 uint8 aint8
signed 8 to unsigned 8 aint8 uint8</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input_zp</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>output_zp</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>multiplier</code></td><td align=center>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr><tr><td align=center><code>shift</code></td><td align=center>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr><tr><td align=center><code>scale32</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>double_round</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td align=center><code>per_channel</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosareshape-mlirtosareshapeop><code>tosa.reshape</code> (mlir::tosa::ReshapeOp)&nbsp;<a class=headline-hash href=#tosareshape-mlirtosareshapeop>¶</a></h3><p>Reshape operator</p><p>Returns a tensor with the same type/values as the input, with a new shape
specified by the shape argument. Reshape may operate on tensors of any rank.
No data conversion happens during a reshape operation.</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>new_shape</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosaresize-mlirtosaresizeop><code>tosa.resize</code> (mlir::tosa::ResizeOp)&nbsp;<a class=headline-hash href=#tosaresize-mlirtosaresizeop>¶</a></h3><p>Resize operation, supports various resize/upsample modes</p><p>Resizes a tensor. Resize is only allowed in the H and W dimensions. In
expected use, stride_y is approximately (IH&#171;shift)/OH and stride_x is
approximately (IW&#171;shift)/OW. OH and OW are also supplied as inputs since
there may be off by one errors if calculating OH and OW from the strides.</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output_size</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>offset</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>shift</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>mode</code></td><td align=center>::mlir::StringAttr</td><td>Supported resize/upsampling strategies</td></tr></tbody></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>4D tensor of number values</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>4D tensor of number values</td></tr></tbody></table><h3 id=tosareverse-mlirtosareverseop><code>tosa.reverse</code> (mlir::tosa::ReverseOp)&nbsp;<a class=headline-hash href=#tosareverse-mlirtosareverseop>¶</a></h3><p>Reverse operator</p><p>Returns a tensor with the same type/values as the input, with the data
reversed along the given axis. No data conversion happens during a reverse
operation.</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>axis</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosarsqrt-mlirtosarsqrtop><code>tosa.rsqrt</code> (mlir::tosa::RsqrtOp)&nbsp;<a class=headline-hash href=#tosarsqrt-mlirtosarsqrtop>¶</a></h3><p>Elementwise 1/sqrt op</p><p>Elementwise reciprocal square root operation. For integer operation, a TABLE
should be used with the appropriate ranges.</p><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaselect-mlirtosaselectop><code>tosa.select</code> (mlir::tosa::SelectOp)&nbsp;<a class=headline-hash href=#tosaselect-mlirtosaselectop>¶</a></h3><p>Elementwise select operator</p><p>Elementwise select of the output based on a condition.</p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>tensor of 1-bit signless integer values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input3</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosasigmoid-mlirtosasigmoidop><code>tosa.sigmoid</code> (mlir::tosa::SigmoidOp)&nbsp;<a class=headline-hash href=#tosasigmoid-mlirtosasigmoidop>¶</a></h3><p>Computes elementwise sigmoid of input.</p><p>Sigmoid function: output = 1 / (1 + exp(-input))
For quantized integer data types, the TABLE operator should be used instead
with the following definition. The sigmoid table has 513 entries each of
16-bit precision and covering the input range -16.0 to +16.0
in steps of 1/16.</p><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosaslice-mlirtosasliceop><code>tosa.slice</code> (mlir::tosa::SliceOp)&nbsp;<a class=headline-hash href=#tosaslice-mlirtosasliceop>¶</a></h3><p>Slice operator</p><p>Extracts a slice of the input1 on the given axis, beginning at the
start coordinates, and extending for size elements in each direction. No
data conversion happens during a slice operation.</p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>start</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td align=center><code>size</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosasub-mlirtosasubop><code>tosa.sub</code> (mlir::tosa::SubOp)&nbsp;<a class=headline-hash href=#tosasub-mlirtosasubop>¶</a></h3><p>Elementwise subtraction operator</p><p>Elementwise subtraction of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>input2</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosatable-mlirtosatableop><code>tosa.table</code> (mlir::tosa::TableOp)&nbsp;<a class=headline-hash href=#tosatable-mlirtosatableop>¶</a></h3><p>Table lookup op</p><p>Interpolated table lookup operation. Input values are scaled to create a
fixed-point 9.7 value. The high 9 bits are used to index into the table.
The fractional bits are used to interpolate based on the looked up value and
the index+1 value in the table. The TABLE operator then returns a 16.7
interpolated value. Note that there must be 513 values to handle the full
range of inputs.</p><p>The TABLE operator is expected to be used as follows:</p><ul><li>A RESCALE node is expected before the TABLE operator to scale the input
to a full int16_t range for the table lookup</li><li>If an int16_t result is required then follow the TABLE operator with a
RESCALE with a right shift of 7</li><li>If an int8_t result is required then follow the TABLE operator with a
RESCALE with a right shift of 15</li></ul><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr><tr><td align=center><code>table</code></td><td>1D tensor of number values</td></tr></tbody></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>0D/1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosatanh-mlirtosatanhop><code>tosa.tanh</code> (mlir::tosa::TanhOp)&nbsp;<a class=headline-hash href=#tosatanh-mlirtosatanhop>¶</a></h3><p>Computes elementwise hyperbolic tangent of input</p><p>Parameterized hyperbolic tangent.
For quantized integer data types, the TABLE operator should be used instead
with the following definition. The tanh_table has 513 entries each of
16-bit precision and covering the input range -8.0 to +8.0 in steps of 1/32.</p><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosatile-mlirtosatileop><code>tosa.tile</code> (mlir::tosa::TileOp)&nbsp;<a class=headline-hash href=#tosatile-mlirtosatileop>¶</a></h3><p>Tile operator</p><p>Replicates input 0 multiplies times along each dimension.</p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>multiples</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D tensor of number values</td></tr></tbody></table><h3 id=tosatranspose_conv2d-mlirtosatransposeconv2dop><code>tosa.transpose_conv2d</code> (mlir::tosa::TransposeConv2DOp)&nbsp;<a class=headline-hash href=#tosatranspose_conv2d-mlirtosatransposeconv2dop>¶</a></h3><p>Transpose 2D Convolution operator.</p><p>Performs a 2D transposed convolution over the given tensor input, using the
weights tensor.</p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>out_pad</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>stride</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>dilation</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with exactly 2 elements</td></tr><tr><td align=center><code>out_shape</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute with at least 4 elements</td></tr><tr><td align=center><code>quantization_info</code></td><td align=center>mlir::tosa::ConvOpQuantizationAttr</td><td>Attribute for Conv type op quantization information.</td></tr></tbody></table><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>4D tensor of number values</td></tr><tr><td align=center><code>filter</code></td><td>4D tensor of number values</td></tr><tr><td align=center><code>bias</code></td><td>1D tensor of number values</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>4D tensor of number values</td></tr></tbody></table><h3 id=tosatranspose-mlirtosatransposeop><code>tosa.transpose</code> (mlir::tosa::TransposeOp)&nbsp;<a class=headline-hash href=#tosatranspose-mlirtosatransposeop>¶</a></h3><p>Transpose operator</p><p>Permutes the dimensions based on perm.</p><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input1</code></td><td>1D/2D/3D/4D/5D/6D tensor of number values</td></tr><tr><td align=center><code>perms</code></td><td>tensor of 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>1D/2D/3D/4D/5D/6D tensor of number values</td></tr></tbody></table><h3 id=tosawhile_loop-mlirtosawhileop><code>tosa.while_loop</code> (mlir::tosa::WhileOp)&nbsp;<a class=headline-hash href=#tosawhile_loop-mlirtosawhileop>¶</a></h3><p>output = input; While (Cond(output)) {output = Body(output)}</p><p>Generates and evaluates a Bool condition and either executes a loop body or
exits to another control point. This action is performed repeatedly after
updating and re-evaluating the Boolean condition every iteration. This
implements the semantic foreach or while iterative loop structure.</p><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td>tensor of number values</td></tr></tbody></table><h3 id=tosayield-mlirtosayieldop><code>tosa.yield</code> (mlir::tosa::YieldOp)&nbsp;<a class=headline-hash href=#tosayield-mlirtosayieldop>¶</a></h3><p>yield operator</p><p>return operation within the conditional and body of
structured control flow. Operation takes variadic operands
but produces no results of its own.</p><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>tensor of number values</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Vector/ title="'vector' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'vector' Dialect</a>
<a class="nav nav-next" href=/docs/TensorPasses/>Next - <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Builtin/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/AVX512/>'avx512' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmNeon/>'llvm_arm_neon' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmSve/>'llvm_arm_sve' Dialect</a></li><li><a href=/docs/Dialects/LLVMAVX512/>'llvm_avx512' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li class=active><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/TensorPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/Bufferization/>Bufferization on MLIR</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>