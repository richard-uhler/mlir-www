<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1Type.html">Type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1Type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::Type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  
 <a href="classmlir_1_1Type.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Types_8h_source.html">mlir/IR/Types.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::Type:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1Type__inherit__graph.png" border="0" usemap="#mlir_1_1Type_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1Type_inherit__map" id="mlir_1_1Type_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1Interface.html" title="mlir::detail::Interface\l\&lt; ConcreteType, Type,\l Traits, Type, TypeTrait\l::TraitBase \&gt;" alt="" coords="143,5,302,76"/>
<area shape="rect" id="node4" href="classmlir_1_1FloatType.html" title="mlir::FloatType" alt="" coords="168,101,277,127"/>
<area shape="rect" id="node5" href="classmlir_1_1LLVM_1_1LLVMType.html" title="Base class for LLVM dialect types. " alt="" coords="145,151,301,178"/>
<area shape="rect" id="node7" href="classmlir_1_1quant_1_1QuantizedType.html" title="Base class for all quantized types known to this dialect. " alt="" coords="133,202,312,229"/>
<area shape="rect" id="node8" href="classmlir_1_1ShapedType.html" title="This is a common base class between Vector, UnrankedTensor, RankedTensor, and MemRef types because th..." alt="" coords="161,253,285,279"/>
<area shape="rect" id="node11" href="classmlir_1_1spirv_1_1SPIRVType.html" title="mlir::spirv::SPIRVType" alt="" coords="144,303,301,330"/>
<area shape="rect" id="node3" href="classmlir_1_1TypeInterface.html" title="This class represents the base of a type interface. " alt="" coords="373,20,542,61"/>
<area shape="rect" id="node6" href="classmlir_1_1LLVM_1_1LLVMVectorType.html" title="LLVM dialect vector type, represents a sequence of elements that can be processed as one..." alt="" coords="360,151,555,178"/>
<area shape="rect" id="node9" href="classmlir_1_1BaseMemRefType.html" title="Base MemRef for Ranked and Unranked variants. " alt="" coords="377,202,537,229"/>
<area shape="rect" id="node10" href="classmlir_1_1TensorType.html" title="Tensor types represent multi&#45;dimensional arrays, and have two variants: RankedTensorType and Unranked..." alt="" coords="397,253,517,279"/>
<area shape="rect" id="node12" href="classmlir_1_1spirv_1_1CompositeType.html" title="mlir::spirv::CompositeType" alt="" coords="368,303,547,330"/>
<area shape="rect" id="node13" href="classmlir_1_1spirv_1_1ScalarType.html" title="mlir::spirv::ScalarType" alt="" coords="381,354,534,381"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::Type:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1Type__coll__graph.png" border="0" usemap="#mlir_1_1Type_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1Type_coll__map" id="mlir_1_1Type_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. " alt="" coords="13,96,139,123"/>
<area shape="rect" id="node3" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="This class acts as the base storage that all storage classes must derived from. " alt="" coords="5,5,147,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">TypeBase</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt; ConcreteType, <a class="el" href="classmlir_1_1detail_1_1BaseType.html">BaseType</a>, StorageType, <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits... &gt;</td></tr>
<tr class="memdesc:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing types.  <a href="#acd35e3f5186bd1c0e4c4f53f69aad716">More...</a><br /></td></tr>
<tr class="separator:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de246b01ef652963e1ddde953d62e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="separator:a89de246b01ef652963e1ddde953d62e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5472fc9326984b512232b1ac27114629"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a5472fc9326984b512232b1ac27114629">Type</a> ()</td></tr>
<tr class="separator:a5472fc9326984b512232b1ac27114629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8871458ee7b2abdca3e94788ae3048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aaa8871458ee7b2abdca3e94788ae3048">Type</a> (const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *<a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a>)</td></tr>
<tr class="separator:aaa8871458ee7b2abdca3e94788ae3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237023ae4dcab369d064457a10bcf518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a237023ae4dcab369d064457a10bcf518">Type</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a237023ae4dcab369d064457a10bcf518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e9e7612215565aadad622ccf4cbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a860e9e7612215565aadad622ccf4cbb0">operator=</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a860e9e7612215565aadad622ccf4cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac53df1249058e8c2ec0fa70f172f0b59">operator==</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be45203a0010965388d41e712dc268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad1be45203a0010965388d41e712dc268">operator!=</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ad1be45203a0010965388d41e712dc268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8b20e59002a0fedfcb93e314b416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afeb8b20e59002a0fedfcb93e314b416f">operator bool</a> () const</td></tr>
<tr class="separator:afeb8b20e59002a0fedfcb93e314b416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516f7c8eb957068555b5781d78f23af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">operator!</a> () const</td></tr>
<tr class="separator:ac516f7c8eb957068555b5781d78f23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#adcd295cf88ab7faa33601d3bbee5c4b8">isa</a> () const</td></tr>
<tr class="separator:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297bb52f523ab1064dc72f39a451cb18"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:a297bb52f523ab1064dc72f39a451cb18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a297bb52f523ab1064dc72f39a451cb18">isa</a> () const</td></tr>
<tr class="separator:a297bb52f523ab1064dc72f39a451cb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6b8d33d03b9736dfcc3cc0e9351b1826">dyn_cast</a> () const</td></tr>
<tr class="separator:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a33ca8bbee5e3e8a02e0df18897981edf">dyn_cast_or_null</a> () const</td></tr>
<tr class="separator:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">cast</a> () const</td></tr>
<tr class="separator:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf7dade447f73f5b04c46fcf616b68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#accf7dade447f73f5b04c46fcf616b68c">getTypeID</a> ()</td></tr>
<tr class="memdesc:accf7dade447f73f5b04c46fcf616b68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <a href="#accf7dade447f73f5b04c46fcf616b68c">More...</a><br /></td></tr>
<tr class="separator:accf7dade447f73f5b04c46fcf616b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951cad794a5bc5ad086158c20f8e50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a3951cad794a5bc5ad086158c20f8e50e">getContext</a> () const</td></tr>
<tr class="memdesc:a3951cad794a5bc5ad086158c20f8e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> in which this type was uniqued.  <a href="#a3951cad794a5bc5ad086158c20f8e50e">More...</a><br /></td></tr>
<tr class="separator:a3951cad794a5bc5ad086158c20f8e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21810b671ec68509499ee2d4f10a8a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a21810b671ec68509499ee2d4f10a8a6b">getDialect</a> () const</td></tr>
<tr class="memdesc:a21810b671ec68509499ee2d4f10a8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dialect this type is registered to.  <a href="#a21810b671ec68509499ee2d4f10a8a6b">More...</a><br /></td></tr>
<tr class="separator:a21810b671ec68509499ee2d4f10a8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d5335ce4fc906636a2690155a7d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a5d5d5335ce4fc906636a2690155a7d72">isIndex</a> () const</td></tr>
<tr class="separator:a5d5d5335ce4fc906636a2690155a7d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077a551403812fae63d3ee3f9233d35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#af077a551403812fae63d3ee3f9233d35">isBF16</a> () const</td></tr>
<tr class="separator:af077a551403812fae63d3ee3f9233d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a009c7555ce7c74ab581e0ac66a593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad5a009c7555ce7c74ab581e0ac66a593">isF16</a> () const</td></tr>
<tr class="separator:ad5a009c7555ce7c74ab581e0ac66a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cde84bc1dbdaecf64df30e7c99e2106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6cde84bc1dbdaecf64df30e7c99e2106">isF32</a> () const</td></tr>
<tr class="separator:a6cde84bc1dbdaecf64df30e7c99e2106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075a66eef3b8dc3f5fd51eba8399ceb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a075a66eef3b8dc3f5fd51eba8399ceb8">isF64</a> () const</td></tr>
<tr class="separator:a075a66eef3b8dc3f5fd51eba8399ceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d16f5d47b21c67f4d49c02979c33724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1d16f5d47b21c67f4d49c02979c33724">isInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="memdesc:a1d16f5d47b21c67f4d49c02979c33724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer type with the specified width.  <a href="#a1d16f5d47b21c67f4d49c02979c33724">More...</a><br /></td></tr>
<tr class="separator:a1d16f5d47b21c67f4d49c02979c33724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53765d45f36d2bbff81bb81b286a9525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a53765d45f36d2bbff81bb81b286a9525">isSignlessInteger</a> () const</td></tr>
<tr class="memdesc:a53765d45f36d2bbff81bb81b286a9525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer type (with the specified width).  <a href="#a53765d45f36d2bbff81bb81b286a9525">More...</a><br /></td></tr>
<tr class="separator:a53765d45f36d2bbff81bb81b286a9525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213fdac03ae27d597f277ac05ea30fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a213fdac03ae27d597f277ac05ea30fca">isSignlessInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="separator:a213fdac03ae27d597f277ac05ea30fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50385bcb919f49adab0f8f2521dc479f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a50385bcb919f49adab0f8f2521dc479f">isSignedInteger</a> () const</td></tr>
<tr class="memdesc:a50385bcb919f49adab0f8f2521dc479f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signed integer type (with the specified width).  <a href="#a50385bcb919f49adab0f8f2521dc479f">More...</a><br /></td></tr>
<tr class="separator:a50385bcb919f49adab0f8f2521dc479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920ada7270762d4e2f96d96f5b29a140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a920ada7270762d4e2f96d96f5b29a140">isSignedInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="separator:a920ada7270762d4e2f96d96f5b29a140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c30270dcbb289e5931b2ed1c4c6919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a78c30270dcbb289e5931b2ed1c4c6919">isUnsignedInteger</a> () const</td></tr>
<tr class="memdesc:a78c30270dcbb289e5931b2ed1c4c6919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an unsigned integer type (with the specified width).  <a href="#a78c30270dcbb289e5931b2ed1c4c6919">More...</a><br /></td></tr>
<tr class="separator:a78c30270dcbb289e5931b2ed1c4c6919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbb14dffe2d155b3f3f478ca216aca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a8dbb14dffe2d155b3f3f478ca216aca7">isUnsignedInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="separator:a8dbb14dffe2d155b3f3f478ca216aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb142623709910125e07ecf1f9f2cdd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aeb142623709910125e07ecf1f9f2cdd5">getIntOrFloatBitWidth</a> () const</td></tr>
<tr class="memdesc:aeb142623709910125e07ecf1f9f2cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width of an integer or a float type, assert failure on other types.  <a href="#aeb142623709910125e07ecf1f9f2cdd5">More...</a><br /></td></tr>
<tr class="separator:aeb142623709910125e07ecf1f9f2cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f738cb5a46aeb47df2e6243a11c41c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a26f738cb5a46aeb47df2e6243a11c41c">isSignlessIntOrIndex</a> () const</td></tr>
<tr class="memdesc:a26f738cb5a46aeb47df2e6243a11c41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer or index type.  <a href="#a26f738cb5a46aeb47df2e6243a11c41c">More...</a><br /></td></tr>
<tr class="separator:a26f738cb5a46aeb47df2e6243a11c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afeff6b78a50b5d435c10e6c8927bbb7d">isSignlessIntOrIndexOrFloat</a> () const</td></tr>
<tr class="memdesc:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer, index, or float type.  <a href="#afeff6b78a50b5d435c10e6c8927bbb7d">More...</a><br /></td></tr>
<tr class="separator:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d6282ddfa213055b965f2db7eb9752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae8d6282ddfa213055b965f2db7eb9752">isSignlessIntOrFloat</a> () const</td></tr>
<tr class="memdesc:ae8d6282ddfa213055b965f2db7eb9752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of this is a signless integer or a float type.  <a href="#ae8d6282ddfa213055b965f2db7eb9752">More...</a><br /></td></tr>
<tr class="separator:ae8d6282ddfa213055b965f2db7eb9752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f33529654fee149935f1e14cdf74305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a7f33529654fee149935f1e14cdf74305">isIntOrIndex</a> () const</td></tr>
<tr class="memdesc:a7f33529654fee149935f1e14cdf74305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or an index type.  <a href="#a7f33529654fee149935f1e14cdf74305">More...</a><br /></td></tr>
<tr class="separator:a7f33529654fee149935f1e14cdf74305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4295aaec59a8a864338a2b7dab0c935"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aa4295aaec59a8a864338a2b7dab0c935">isIntOrFloat</a> () const</td></tr>
<tr class="memdesc:aa4295aaec59a8a864338a2b7dab0c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or a float type.  <a href="#aa4295aaec59a8a864338a2b7dab0c935">More...</a><br /></td></tr>
<tr class="separator:aa4295aaec59a8a864338a2b7dab0c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69310264441dfb377a3789c8eedcdce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a69310264441dfb377a3789c8eedcdce7">isIntOrIndexOrFloat</a> () const</td></tr>
<tr class="memdesc:a69310264441dfb377a3789c8eedcdce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness), index, or float type.  <a href="#a69310264441dfb377a3789c8eedcdce7">More...</a><br /></td></tr>
<tr class="separator:a69310264441dfb377a3789c8eedcdce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f326ccb845e5e7f384a8069153f305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a94f326ccb845e5e7f384a8069153f305">print</a> (raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a94f326ccb845e5e7f384a8069153f305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current type.  <a href="#a94f326ccb845e5e7f384a8069153f305">More...</a><br /></td></tr>
<tr class="separator:a94f326ccb845e5e7f384a8069153f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975aa15f5744af5a899e491135ab1384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a975aa15f5744af5a899e491135ab1384">dump</a> ()</td></tr>
<tr class="separator:a975aa15f5744af5a899e491135ab1384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1035844c344d17a9e6081c6a0e101b80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoid.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1035844c344d17a9e6081c6a0e101b80">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a1035844c344d17a9e6081c6a0e101b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="#a1035844c344d17a9e6081c6a0e101b80">More...</a><br /></td></tr>
<tr class="separator:a1035844c344d17a9e6081c6a0e101b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225471c06d85dd43b0848a90d68adb18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a225471c06d85dd43b0848a90d68adb18">getAbstractType</a> ()</td></tr>
<tr class="memdesc:a225471c06d85dd43b0848a90d68adb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the abstract type descriptor for this type.  <a href="#a225471c06d85dd43b0848a90d68adb18">More...</a><br /></td></tr>
<tr class="separator:a225471c06d85dd43b0848a90d68adb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a20187f3bc53c94040a83d41de0119a59"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a20187f3bc53c94040a83d41de0119a59">classof</a> (<a class="el" href="classmlir_1_1Type.html">Type</a>)</td></tr>
<tr class="separator:a20187f3bc53c94040a83d41de0119a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b903c935dfc504b4f4e3f77939b113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a58b903c935dfc504b4f4e3f77939b113">getFromOpaquePointer</a> (const <a class="el" href="classvoid.html">void</a> *pointer)</td></tr>
<tr class="separator:a58b903c935dfc504b4f4e3f77939b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a54af6c081e012a32bba9b650480c6c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a></td></tr>
<tr class="separator:a54af6c081e012a32bba9b650480c6c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a54ee333db7234f6ada1036072a24b877"><td class="memItemLeft" align="right" valign="top">::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54ee333db7234f6ada1036072a24b877">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a54ee333db7234f6ada1036072a24b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component. </p>
<p>They wrap a pointer to the storage object owned by <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. Therefore, instances of <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> are passed around by value.</p>
<p>Some types are "primitives" meaning they do not have any parameters, for example the Index type. Parametric types have additional information that differentiates the types of the same class, for example the Integer type has bitwidth, making i8 and i16 belong to the same kind by be different instances of the <a class="el" href="classmlir_1_1IntegerType.html" title="Integer types can have arbitrary bitwidth up to a large fixed limit. ">IntegerType</a>. <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> parameters are part of the unique immutable key. The mutable component of the type can be modified after the type is created, but cannot affect the identity of the type.</p>
<p>Types are constructed and uniqued via the '<a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html" title="A utility class to get, or create, unique instances of types within an MLIRContext. ">detail::TypeUniquer</a>' class.</p>
<p>Derived type classes are expected to implement several required implementation hooks:</p><ul>
<li>Optional:<ul>
<li>static <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> verifyConstructionInvariants(<a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> loc, Args... args)<ul>
<li>This method is invoked when calling the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a73da59a295ce21e18919de2ad6a6bb2b" title="Get or create a new ConcreteT instance within the ctx. ">TypeBase::get</a>/getChecked' methods to ensure that the arguments passed in are valid to construct a type instance with.</li>
<li>This method is expected to return failure if a type cannot be constructed with 'args', success otherwise.</li>
<li>'args' must correspond with the arguments passed into the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a73da59a295ce21e18919de2ad6a6bb2b" title="Get or create a new ConcreteT instance within the ctx. ">TypeBase::get</a>' call.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> storage objects inherit from <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. ">TypeStorage</a> and contain the following:</p><ul>
<li>The dialect that defined the type.</li>
<li>Any parameters of the type.</li>
<li>An optional mutable component. For non-parametric types, a convenience DefaultTypeStorage is provided. Parametric storage types must derive <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. ">TypeStorage</a> and respect the following:</li>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the type.<ul>
<li>The key type must be constructible from the values passed into the <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html#ac7e6b6b86fe49d6695a455f7d8813f37" title="Get an uniqued instance of a parametric type T. ">detail::TypeUniquer::get</a> call.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(TypeStorageAllocator &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data within the context and the key type for this storage.</li>
<li>If they have a mutable component, this component must not be a part of </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00071">71</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a89de246b01ef652963e1ddde953d62e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89de246b01ef652963e1ddde953d62e7">&#9670;&nbsp;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">mlir::Type::ImplType</a> =  <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00079">79</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="acd35e3f5186bd1c0e4c4f53f69aad716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd35e3f5186bd1c0e4c4f53f69aad716">&#9670;&nbsp;</a></span>TypeBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">mlir::Type::TypeBase</a> =  <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt;ConcreteType, <a class="el" href="classmlir_1_1detail_1_1BaseType.html">BaseType</a>, StorageType, <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility class for implementing types. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00077">77</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5472fc9326984b512232b1ac27114629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5472fc9326984b512232b1ac27114629">&#9670;&nbsp;</a></span>Type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mlir::Type::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00081">81</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00164">getFromOpaquePointer()</a>, and <a class="el" href="Types_8h_source.html#l00082">Type()</a>.</p>

</div>
</div>
<a id="aaa8871458ee7b2abdca3e94788ae3048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8871458ee7b2abdca3e94788ae3048">&#9670;&nbsp;</a></span>Type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00082">82</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1Type.html#a860e9e7612215565aadad622ccf4cbb0">operator=()</a>, and <a class="el" href="Types_8h_source.html#l00081">Type()</a>.</p>

</div>
</div>
<a id="a237023ae4dcab369d064457a10bcf518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237023ae4dcab369d064457a10bcf518">&#9670;&nbsp;</a></span>Type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a9c3e06d3b23ad9457c13cb828a7c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c3e06d3b23ad9457c13cb828a7c48">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00240">240</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8cpp_source.html#l00146">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00102">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00171">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00122">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01293">mlir::DenseFPElementsAttr::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01312">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00929">computeTensorReshapeCollapsedType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00247">convertArrayType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00577">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00823">convertReassociationIndicesToMaps()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00234">convertScalarType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00084">createConstantAllBitsSet()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00097">createFPConstant()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00027">createGlobalVarForEntryPointArgument()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02212">createScopedSubViewIntersection()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="Loops_8cpp_source.html#l00335">emitScalarImplementation()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00080">extractOne()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00461">mlir::StructBuilder::extractPtr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02710">extractShape()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00122">extractVectorTypeFromScalarView()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00815">foldExtractFromBroadcast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00846">foldExtractFromShapeCast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02114">foldTransferMaskAttribute()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00021">mlir::quant::ExpressedToQuantizedConverter::forInputType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02219">generatePointWiseCopy()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00301">mlir::IntegerAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00850">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00148">mlir::spirv::ArrayType::getCapabilities()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00543">mlir::spirv::RuntimeArrayType::getCapabilities()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00326">mlir::spirv::CooperativeMatrixNVType::getCapabilities()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01043">mlir::DenseElementsAttr::getComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01019">mlir::DenseElementsAttr::getComplexIntValues()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00454">getDimMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00142">mlir::AffineDmaStartOp::getDstMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00137">mlir::AffineDmaStartOp::getDstMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00132">mlir::AffineDmaStartOp::getDstMemRefType()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00676">mlir::MemRefDescriptor::getElementPtrType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01147">mlir::spirv::MatrixType::getElementType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00143">mlir::spirv::ArrayType::getExtensions()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00537">mlir::spirv::RuntimeArrayType::getExtensions()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00317">mlir::spirv::CooperativeMatrixNVType::getExtensions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02599">getFullMemRefAsRegion()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00134">mlir::detail::FloatAttributeStorage::getKey()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00146">getMemRefAlignment()</a>, <a class="el" href="Dialect_2StandardOps_2EDSC_2Builders_8cpp_source.html#l00017">getMemRefSizes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02183">getMultiLevelStrides()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00277">getOrCreateUnrolledVectorSlice()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00093">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01151">mlir::DenseIntOrFPElementsAttr::getRawComplex()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00154">mlir::spirv::ArrayType::getSizeInBytes()</a>, <a class="el" href="AffineOps_8h_source.html#l00121">mlir::AffineDmaStartOp::getSrcMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00100">mlir::AffineDmaStartOp::getSrcMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00171">mlir::AffineDmaStartOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00302">mlir::AffineDmaWaitOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00166">mlir::AffineDmaStartOp::getTagMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00285">mlir::AffineDmaWaitOp::getTagMemRefType()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00437">mlir::ElementsAttr::getType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01375">mlir::SparseElementsAttr::getValue()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00276">mlir::Builder::getZeroAttr()</a>, <a class="el" href="BufferOptimizations_8cpp_source.html#l00075">hasAllocationScope()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00562">inferExtractOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01619">inferStridedSliceOpResultType()</a>, <a class="el" href="Ops_8cpp_source.html#l03969">inferTransposeResultType()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00134">insertCopies()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00053">insertOne()</a>, <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00311">isAsyncWithOneDependency()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00084">mlir::quant::QuantizedType::isCompatibleExpressedType()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00018">isElementwiseMappableOpOnRankedTensors()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>, <a class="el" href="Ops_8cpp_source.html#l03184">isRankReducedType()</a>, <a class="el" href="Ops_8cpp_source.html#l03864">joinShapes()</a>, <a class="el" href="Tiling_8cpp_source.html#l00222">makeTiledShapes()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00025">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00040">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00507">mlir::MemRefDescriptor::MemRefDescriptor()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00074">minusOneIntegerAttribute()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00089">mlir::OperandElementTypeIterator::OperandElementTypeIterator()</a>, <a class="el" href="Types_8h_source.html#l00092">operator!()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00720">mlir::DenseElementsAttr::IntElementIterator::operator*()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00117">optionallyTruncateOrExtend()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00645">parseCallOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00894">mlir::detail::Parser::parseElementsLiteralType()</a>, <a class="el" href="Ops_8cpp_source.html#l00518">parseGenericAtomicRMWOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00046">parseNVVMShflSyncBflyOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03782">parseSubTensorInsertOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03668">parseSubTensorOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03059">parseSubViewOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00982">populateFromInt64AttrArray()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02100">print()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00498">printLandingpadOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03253">produceSubViewErrorMsg()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l04060">mlir::LLVMTypeConverter::promoteOneMemRefDescriptor()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00110">reshapeLoad()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00110">reshapeLowerToHigher()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00098">mlir::ResultElementTypeIterator::ResultElementTypeIterator()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00249">mlir::LLVM::LLVMType::setStructTyBody()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00618">mlir::MemRefDescriptor::size()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02382">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00129">transferReadVector()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00139">transferWriteVector()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00478">mlir::ComplexStructBuilder::undef()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00515">mlir::MemRefDescriptor::undef()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00771">mlir::UnrankedMemRefDescriptor::undef()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00590">unrollTransferReadOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00634">mlir::vector::unrollTransferWriteOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00894">vectorizeConstant()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02285">verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00699">verifyAtomicUpdateOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00479">verifyBlockReadWritePtrAndValTypes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00309">verifyCastOp()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00252">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01116">mlir::spirv::MatrixType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03220">verifyCopyMemory()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00464">verifyLoadStorePtrAndValTypes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03022">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01893">verifyTransferOp()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00069">walkReturnOperations()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01271">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a20187f3bc53c94040a83d41de0119a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20187f3bc53c94040a83d41de0119a59">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::Type::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00102">102</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a975aa15f5744af5a899e491135ab1384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975aa15f5744af5a899e491135ab1384">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> Type::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02529">2529</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Shape_8cpp_source.html#l00612">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>.</p>

</div>
</div>
<a id="a6b8d33d03b9736dfcc3cc0e9351b1826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8d33d03b9736dfcc3cc0e9351b1826">&#9670;&nbsp;</a></span>dyn_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00234">234</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DecomposeCallGraphTypes_8h_source.html#l00057">mlir::ValueDecomposer::addDecomposeValueConversion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01396">appendMangledType()</a>, <a class="el" href="Ops_8cpp_source.html#l00209">areVectorCastSimpleCompatible()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00102">mlir::tosa::buildConvOpQuantizationAttr()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00245">mlir::tosa::buildConvOpResultTypeInfo()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01329">buildLLVMFunctionType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00887">buildLogicalBinaryOp()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00151">mlir::tosa::buildMatMulOpQuantizationAttr()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00212">buildMatMulOpWithQuantInfo()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00220">mlir::tosa::buildPadOpQuantizationAttr()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00279">mlir::tosa::buildQTypeFromMinMax()</a>, <a class="el" href="QuantUtils_8cpp_source.html#l00187">mlir::tosa::buildUnaryOpQuantizationAttr()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00715">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00558">mlir::spirv::ScalarType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00166">mlir::spirv::CompositeType::classof()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00035">mlir::quant::ExpressedToQuantizedConverter::convert()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00423">mlir::LLVMTypeConverter::convertCallingConventionType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01223">mlir::DenseIntOrFPElementsAttr::convertEndianOfArrayRefForBEmachine()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00343">convertMemrefType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00234">convertScalarType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00305">convertTensorType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00097">createFPConstant()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02489">mlir::vector::distributPointwiseVectorOp()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00877">forwardPassthroughAttributes()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00055">getBitWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00352">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00903">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00578">getElementType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00021">mlir::getElementTypeOrSelf()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00228">getEnclosingforOps()</a>, <a class="el" href="Ops_8cpp_source.html#l00755">getI1SameShape()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00784">getInsertExtractValueElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00220">getLoadStoreElementType()</a>, <a class="el" href="Loops_8cpp_source.html#l00220">getPaddedInput()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00093">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="Traits_8cpp_source.html#l00091">getShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00748">getTensorOrVectorElementType()</a>, <a class="el" href="Ops_8cpp_source.html#l00223">getTensorTypeFromMemRefType()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00816">getUnaryOpResultType()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00276">mlir::Builder::getZeroAttr()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01606">handleMultidimensionalVectors()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00505">initializeAliases()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00134">insertCopies()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00221">isAllocationSupported()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00032">isBoolScalarOrVector()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00158">mlir::VulkanLayoutUtils::isLegalType()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00043">mlir::isOpaqueTypeWithName()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00037">isSignedIntegerOrVector()</a>, <a class="el" href="BufferOptimizations_8cpp_source.html#l00032">isSmallAlloc()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00046">isUnsignedIntegerOrVector()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01137">mlir::spirv::MatrixType::isValidColumnType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00918">isValidIntOrFloat()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00045">isValidQuantizationSpec()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00025">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00216">mlir::TypeConverter::materializeTargetConversion()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00074">minusOneIntegerAttribute()</a>, <a class="el" href="Types_8h_source.html#l00092">operator!()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00156">optionallyBroadcast()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00136">parseAllocaOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00205">parseAndVerifyMatrixType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00161">parseAndVerifyType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01065">parseAtomicCompareExchangeWeakOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00656">parseAtomicUpdateOp()</a>, <a class="el" href="Async_8cpp_source.html#l00330">parseAwaitResultType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00645">parseCallOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00062">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00794">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01278">parseCompositeConstructOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00363">parseConstShapeOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00366">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00749">parseExtractElementOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00595">parseExtractOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02045">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00867">parseInsertElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00363">parseInvokeOp()</a>, <a class="el" href="Parser_8cpp_source.html#l00098">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01488">parseOuterProductOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01260">parseShuffleVectorOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02086">parseSubgroupBlockReadINTELOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02129">parseSubgroupBlockWriteINTELOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00314">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00755">mlir::OpAsmParser::parseType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02889">parseVariableOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00612">print()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00416">printCalibratedQuantizedType()</a>, <a class="el" href="QuantizeUtils_8cpp_source.html#l00127">mlir::quant::quantizeAttr()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00110">reshapeLowerToHigher()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00338">mlir::VectorType::scaleElementBitwidth()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00410">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00455">mlir::StructBuilder::StructBuilder()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00139">transferWriteVector()</a>, <a class="el" href="TypeRange_8cpp_source.html#l00028">mlir::TypeRange::TypeRange()</a>, <a class="el" href="ArmSVEToLLVM_8cpp_source.html#l00039">unwrap()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="Async_8cpp_source.html#l00302">verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00309">verifyCastOp()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00073">mlir::verifyCompatibleShape()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00031">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00341">mlir::IntegerAttr::verifyConstructionInvariants()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00285">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="a33ca8bbee5e3e8a02e0df18897981edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ca8bbee5e3e8a02e0df18897981edf">&#9670;&nbsp;</a></span>dyn_cast_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00237">237</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00040">diag()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00486">getVectorElementwiseOpUnrollState()</a>, <a class="el" href="Types_8h_source.html#l00092">operator!()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02599">verify()</a>.</p>

</div>
</div>
<a id="a225471c06d85dd43b0848a90d68adb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225471c06d85dd43b0848a90d68adb18">&#9670;&nbsp;</a></span>getAbstractType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a>&amp; mlir::Type::getAbstractType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the abstract type descriptor for this type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00169">169</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a1035844c344d17a9e6081c6a0e101b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1035844c344d17a9e6081c6a0e101b80">&#9670;&nbsp;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoid.html">void</a>* mlir::Type::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00161">161</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00172">impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00266">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getAsVoidPointer()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00621">llvm::PointerLikeTypeTraits&lt; mlir::LLVM::LLVMType &gt;::getAsVoidPointer()</a>, <a class="el" href="ByteCode_8cpp_source.html#l00699">mlir::detail::PDLByteCode::initializeMutableState()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00026">mlir::AttributeStorage::setType()</a>.</p>

</div>
</div>
<a id="a3951cad794a5bc5ad086158c20f8e50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951cad794a5bc5ad086158c20f8e50e">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * Type::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> in which this type was uniqued. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00023">23</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8h_source.html#l00212">mlir::LLVM::LLVMType::createStructTy()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00034">mlir::ComplexType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00125">mlir::spirv::ArrayType::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00210">mlir::FloatAttr::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00203">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00295">mlir::IntegerAttr::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00468">mlir::spirv::PointerType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00525">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00238">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00266">mlir::LLVM::LLVMArrayType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00300">mlir::LLVM::LLVMFunctionType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00290">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00417">mlir::StringAttr::get()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00312">mlir::VectorType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00373">mlir::LLVM::LLVMPointerType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00358">mlir::quant::CalibratedQuantizedType::get()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00377">mlir::RankedTensorType::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00427">mlir::TypeAttr::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00299">mlir::spirv::CooperativeMatrixNVType::get()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00405">mlir::UnrankedTensorType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01107">mlir::spirv::MatrixType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00506">mlir::LLVM::LLVMFixedVectorType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00523">mlir::LLVM::LLVMScalableVectorType::get()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00522">mlir::UnrankedMemRefType::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01093">mlir::DenseStringElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01321">mlir::OpaqueElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01354">mlir::SparseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00451">mlir::MemRefType::getChecked()</a>, <a class="el" href="Attributes_8cpp_source.html#l00038">mlir::Attribute::getContext()</a>, <a class="el" href="Value_8h_source.html#l00111">mlir::Value::getContext()</a>, <a class="el" href="Ops_8cpp_source.html#l00755">getI1SameShape()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01139">mlir::DenseIntOrFPElementsAttr::getRaw()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00179">mlir::LLVM::LLVMType::getStructTy()</a>, <a class="el" href="Ops_8cpp_source.html#l00223">getTensorTypeFromMemRefType()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00579">parseSymbol()</a>, <a class="el" href="Value_8cpp_source.html#l00047">mlir::Value::setType()</a>, and <a class="el" href="ArmSVEToLLVM_8cpp_source.html#l00039">unwrap()</a>.</p>

</div>
</div>
<a id="a21810b671ec68509499ee2d4f10a8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21810b671ec68509499ee2d4f10a8a6b">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> Type::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dialect this type is registered to. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00019">19</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8cpp_source.html#l00027">mlir::quant::QuantizedType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00715">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00031">mlir::LLVM::LLVMType::classof()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00035">mlir::LLVM::LLVMType::getDialect()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00364">mlir::TensorType::isValidElementType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00161">parseAndVerifyType()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01630">printDenseElementsAttrImpl()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l01494">verify()</a>.</p>

</div>
</div>
<a id="a58b903c935dfc504b4f4e3f77939b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b903c935dfc504b4f4e3f77939b113">&#9670;&nbsp;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> mlir::Type::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoid.html">void</a> *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00164">164</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00081">Type()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00051">mlir::DiagnosticArgument::getAsType()</a>, <a class="el" href="Types_8h_source.html#l00269">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getFromVoidPointer()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00023">mlir::AttributeStorage::getType()</a>.</p>

</div>
</div>
<a id="aeb142623709910125e07ecf1f9f2cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb142623709910125e07ecf1f9f2cdd5">&#9670;&nbsp;</a></span>getIntOrFloatBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> Type::getIntOrFloatBitWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bit width of an integer or a float type, assert failure on other types. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00093">93</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00070">allocBuffer()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00326">buildAttributeAPInt()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00055">getBitWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00352">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00229">mlir::ShapedType::getElementTypeBitWidth()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00309">verifyCastOp()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00182">verifyShuffleOp()</a>.</p>

</div>
</div>
<a id="accf7dade447f73f5b04c46fcf616b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf7dade447f73f5b04c46fcf616b68c">&#9670;&nbsp;</a></span>getTypeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a> mlir::Type::getTypeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unique identifier for the concrete type. </p>
<p>This is used to support dynamic type casting. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00106">106</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02529">dump()</a>, <a class="el" href="Types_8cpp_source.html#l00023">getContext()</a>, <a class="el" href="Types_8cpp_source.html#l00019">getDialect()</a>, <a class="el" href="Types_8cpp_source.html#l00093">getIntOrFloatBitWidth()</a>, <a class="el" href="Types_8h_source.html#l00220">hash_value</a>, <a class="el" href="Types_8cpp_source.html#l00025">isBF16()</a>, <a class="el" href="Types_8cpp_source.html#l00026">isF16()</a>, <a class="el" href="Types_8cpp_source.html#l00027">isF32()</a>, <a class="el" href="Types_8cpp_source.html#l00028">isF64()</a>, <a class="el" href="Types_8cpp_source.html#l00030">isIndex()</a>, <a class="el" href="Types_8cpp_source.html#l00033">isInteger()</a>, <a class="el" href="Types_8cpp_source.html#l00089">isIntOrFloat()</a>, <a class="el" href="Types_8cpp_source.html#l00087">isIntOrIndex()</a>, <a class="el" href="Types_8cpp_source.html#l00091">isIntOrIndexOrFloat()</a>, <a class="el" href="Types_8cpp_source.html#l00051">isSignedInteger()</a>, <a class="el" href="Types_8cpp_source.html#l00039">isSignlessInteger()</a>, <a class="el" href="Types_8cpp_source.html#l00083">isSignlessIntOrFloat()</a>, <a class="el" href="Types_8cpp_source.html#l00075">isSignlessIntOrIndex()</a>, <a class="el" href="Types_8cpp_source.html#l00079">isSignlessIntOrIndexOrFloat()</a>, <a class="el" href="Types_8cpp_source.html#l00063">isUnsignedInteger()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02527">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operation_8cpp_source.html#l01087">areSameShapedTypeIgnoringElementType()</a>.</p>

</div>
</div>
<a id="adcd295cf88ab7faa33601d3bbee5c4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd295cf88ab7faa33601d3bbee5c4b8">&#9670;&nbsp;</a></span>isa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00224">224</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00300">areAllLLVMTypes()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00146">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00102">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00171">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00122">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="Ops_8cpp_source.html#l01253">mlir::ConstantFloatOp::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00715">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00166">mlir::spirv::CompositeType::classof()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00649">mlir::FloatType::classof()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00669">mlir::ShapedType::classof()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00645">mlir::BaseMemRefType::classof()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00477">mlir::LLVM::LLVMVectorType::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01293">mlir::DenseFPElementsAttr::classof()</a>, <a class="el" href="Fusion_8cpp_source.html#l00090">cloneWithLoopRanges()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00085">convertRangeType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00285">convertStructType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00084">createConstantAllBitsSet()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00237">mlir::edsc::op::eq()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00815">foldExtractFromBroadcast()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00021">mlir::quant::ExpressedToQuantizedConverter::forInputType()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00556">genLoad()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00850">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01354">mlir::SparseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00055">getBitWidth()</a>, <a class="el" href="Traits_8cpp_source.html#l00106">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01043">mlir::DenseElementsAttr::getComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01019">mlir::DenseElementsAttr::getComplexIntValues()</a>, <a class="el" href="Ops_8cpp_source.html#l00755">getI1SameShape()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00177">mlir::LLVMTypeConverter::getPointerBitwidth()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00042">mlir::LLVM::LLVMType::getPrimitiveSizeInBits()</a>, <a class="el" href="Fusion_8cpp_source.html#l00465">getProducerOfTensor()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00093">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01139">mlir::DenseIntOrFPElementsAttr::getRaw()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00029">getTreePredicates()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00913">getVectorType()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00276">mlir::Builder::getZeroAttr()</a>, <a class="el" href="Traits_8cpp_source.html#l00163">hasTensorOrVectorType()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00181">mlir::detail::IntegerAttributeStorage::IntegerAttributeStorage()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00163">isAccessIndexInvariant()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00084">mlir::quant::QuantizedType::isCompatibleExpressedType()</a>, <a class="el" href="Shape_8cpp_source.html#l00033">isErrorPropagationPossible()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00072">isMemRefDereferencingOp()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00016">isQuantizablePrimitiveType()</a>, <a class="el" href="Ops_8cpp_source.html#l03184">isRankReducedType()</a>, <a class="el" href="Async_8h_source.html#l00062">mlir::async::isRefCounted()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00292">mlir::LLVM::LLVMFunctionType::isValidArgumentType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00261">mlir::LLVM::LLVMArrayType::isValidElementType()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00348">mlir::VectorType::isValidElementType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00364">mlir::TensorType::isValidElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00368">mlir::LLVM::LLVMPointerType::isValidElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00398">mlir::LLVM::LLVMStructType::isValidElementType()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00447">mlir::BaseMemRefType::isValidElementType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00471">mlir::LLVM::LLVMVectorType::isValidElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00918">isValidIntOrFloat()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00045">isValidQuantizationSpec()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00296">mlir::LLVM::LLVMFunctionType::isValidResultType()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00112">mlir::edsc::ops::linalg_generic_pointwise()</a>, <a class="el" href="Tiling_8cpp_source.html#l00222">makeTiledShapes()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01244">mappingHelper()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01930">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00243">mlir::edsc::op::ne()</a>, <a class="el" href="Types_8h_source.html#l00092">operator!()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01279">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">mlir::detail::Parser::parseComplexType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01474">parseConstantOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00366">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00894">mlir::detail::Parser::parseElementsLiteralType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00292">mlir::detail::Parser::parseFloatAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01935">parseGlobalVariableOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00612">print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01630">printDenseElementsAttrImpl()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00676">printGPUFuncOp()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00267">mlir::edsc::op::sge()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00261">mlir::edsc::op::sgt()</a>, <a class="el" href="Ops_8cpp_source.html#l02741">signedCeilNonnegInputs()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00255">mlir::edsc::op::sle()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00249">mlir::edsc::op::slt()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="EDSC_2Builders_8h_source.html#l00141">mlir::edsc::StructuredIndexed::StructuredIndexed()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00291">mlir::edsc::op::uge()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00285">mlir::edsc::op::ugt()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00279">mlir::edsc::op::ule()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00273">mlir::edsc::op::ult()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00894">vectorizeConstant()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00969">vectorizeOperand()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="Async_8cpp_source.html#l00347">verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00220">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00256">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00310">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00370">mlir::quant::CalibratedQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00241">verifyFloatTypeInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00330">verifyIntegerTypeInvariants()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00285">verifyOutputShape()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03022">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="Operation_8cpp_source.html#l01013">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, and <a class="el" href="Shape_8cpp_source.html#l00051">verifyShapeOrExtentTensorOp()</a>.</p>

</div>
</div>
<a id="a297bb52f523ab1064dc72f39a451cb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297bb52f523ab1064dc72f39a451cb18">&#9670;&nbsp;</a></span>isa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00230">230</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="af077a551403812fae63d3ee3f9233d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077a551403812fae63d3ee3f9233d35">&#9670;&nbsp;</a></span>isBF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isBF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00025">25</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="QuantTypes_8h_source.html#l00105">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00568">mlir::spirv::ScalarType::isValid()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00161">parseAndVerifyType()</a>.</p>

</div>
</div>
<a id="ad5a009c7555ce7c74ab581e0ac66a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a009c7555ce7c74ab581e0ac66a593">&#9670;&nbsp;</a></span>isF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00026">26</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, and <a class="el" href="QuantTypes_8h_source.html#l00105">mlir::quant::QuantizedType::isSigned()</a>.</p>

</div>
</div>
<a id="a6cde84bc1dbdaecf64df30e7c99e2106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde84bc1dbdaecf64df30e7c99e2106">&#9670;&nbsp;</a></span>isF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00027">27</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00079">convertFloatAttr()</a>, <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html#l00025">getSrcVectorElementType()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, and <a class="el" href="QuantTypes_8h_source.html#l00105">mlir::quant::QuantizedType::isSigned()</a>.</p>

</div>
</div>
<a id="a075a66eef3b8dc3f5fd51eba8399ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075a66eef3b8dc3f5fd51eba8399ceb8">&#9670;&nbsp;</a></span>isF64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00028">28</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00311">buildHexadecimalFloatLiteral()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00134">mlir::detail::FloatAttributeStorage::getKey()</a>, <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html#l00025">getSrcVectorElementType()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="QuantTypes_8h_source.html#l00105">mlir::quant::QuantizedType::isSigned()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>.</p>

</div>
</div>
<a id="a5d5d5335ce4fc906636a2690155a7d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d5335ce4fc906636a2690155a7d72">&#9670;&nbsp;</a></span>isIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00030">30</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00326">buildAttributeAPInt()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00125">ceilDivPositive()</a>, <a class="el" href="Ops_8cpp_source.html#l01279">mlir::ConstantIndexOp::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00301">mlir::IntegerAttr::get()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00352">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00360">getGenericEffectsImpl()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00181">mlir::detail::IntegerAttributeStorage::IntegerAttributeStorage()</a>, <a class="el" href="QuantTypes_8h_source.html#l00105">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="BufferOptimizations_8cpp_source.html#l00032">isSmallAlloc()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00256">mlir::isValidDim()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00918">isValidIntOrFloat()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00351">mlir::isValidSymbol()</a>, <a class="el" href="Ops_8cpp_source.html#l01581">mlir::DmaStartOp::verify()</a>, <a class="el" href="Ops_8cpp_source.html#l01706">mlir::DmaWaitOp::verify()</a>, and <a class="el" href="Ops_8cpp_source.html#l02074">verify()</a>.</p>

</div>
</div>
<a id="a1d16f5d47b21c67f4d49c02979c33724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d16f5d47b21c67f4d49c02979c33724">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer type with the specified width. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00033">33</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeDetail_8h_source.html#l00501">mlir::detail::DenseIntOrFPElementsAttributeStorage::construct()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00821">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01354">mlir::SparseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00419">mlir::detail::DenseIntOrFPElementsAttributeStorage::getKey()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00032">isBoolScalarOrVector()</a>, <a class="el" href="QuantTypes_8h_source.html#l00105">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00192">mlir::edsc::op::negate()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00396">mlir::detail::DenseIntOrFPElementsAttributeStorage::operator==()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00203">mlir::edsc::op::operator||()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>.</p>

</div>
</div>
<a id="aa4295aaec59a8a864338a2b7dab0c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4295aaec59a8a864338a2b7dab0c935">&#9670;&nbsp;</a></span>isIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or a float type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00089">89</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00833">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00055">getBitWidth()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00221">isAllocationSupported()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00043">mlir::ComplexType::verifyConstructionInvariants()</a>.</p>

</div>
</div>
<a id="a7f33529654fee149935f1e14cdf74305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f33529654fee149935f1e14cdf74305">&#9670;&nbsp;</a></span>isIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or an index type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00087">87</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01312">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00842">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00125">verify()</a>.</p>

</div>
</div>
<a id="a69310264441dfb377a3789c8eedcdce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69310264441dfb377a3789c8eedcdce7">&#9670;&nbsp;</a></span>isIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness), index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00091">91</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00777">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00447">mlir::BaseMemRefType::isValidElementType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00125">verify()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l01207">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="a50385bcb919f49adab0f8f2521dc479f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50385bcb919f49adab0f8f2521dc479f">&#9670;&nbsp;</a></span>isSignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signed integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00051">51</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00326">buildAttributeAPInt()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, and <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00037">isSignedIntegerOrVector()</a>.</p>

</div>
</div>
<a id="a920ada7270762d4e2f96d96f5b29a140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920ada7270762d4e2f96d96f5b29a140">&#9670;&nbsp;</a></span>isSignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00057">57</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a53765d45f36d2bbff81bb81b286a9525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53765d45f36d2bbff81bb81b286a9525">&#9670;&nbsp;</a></span>isSignlessInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00039">39</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l01271">mlir::ConstantIntOp::build()</a>, <a class="el" href="Ops_8cpp_source.html#l01258">mlir::ConstantIntOp::classof()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00295">mlir::IntegerAttr::get()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="Ops_8cpp_source.html#l02741">signedCeilNonnegInputs()</a>, and <a class="el" href="Ops_8cpp_source.html#l01767">verify()</a>.</p>

</div>
</div>
<a id="a213fdac03ae27d597f277ac05ea30fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213fdac03ae27d597f277ac05ea30fca">&#9670;&nbsp;</a></span>isSignlessInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00045">45</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="ae8d6282ddfa213055b965f2db7eb9752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d6282ddfa213055b965f2db7eb9752">&#9670;&nbsp;</a></span>isSignlessIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true of this is a signless integer or a float type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00083">83</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00034">mlir::linalg::RegionMatcher::matchAsScalarBinaryOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01070">verify()</a>, and <a class="el" href="GPUDialect_8cpp_source.html#l00182">verifyShuffleOp()</a>.</p>

</div>
</div>
<a id="a26f738cb5a46aeb47df2e6243a11c41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f738cb5a46aeb47df2e6243a11c41c">&#9670;&nbsp;</a></span>isSignlessIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer or index type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00075">75</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, and <a class="el" href="Operation_8cpp_source.html#l01022">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike()</a>.</p>

</div>
</div>
<a id="afeff6b78a50b5d435c10e6c8927bbb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeff6b78a50b5d435c10e6c8927bbb7d">&#9670;&nbsp;</a></span>isSignlessIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer, index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00079">79</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01396">appendMangledType()</a>, and <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>.</p>

</div>
</div>
<a id="a78c30270dcbb289e5931b2ed1c4c6919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c30270dcbb289e5931b2ed1c4c6919">&#9670;&nbsp;</a></span>isUnsignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an unsigned integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00063">63</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00046">isUnsignedIntegerOrVector()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00366">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l01630">printDenseElementsAttrImpl()</a>.</p>

</div>
</div>
<a id="a8dbb14dffe2d155b3f3f478ca216aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbb14dffe2d155b3f3f478ca216aca7">&#9670;&nbsp;</a></span>isUnsignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00069">69</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="afeb8b20e59002a0fedfcb93e314b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8b20e59002a0fedfcb93e314b416f">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00090">90</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00172">impl</a>.</p>

</div>
</div>
<a id="ac516f7c8eb957068555b5781d78f23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516f7c8eb957068555b5781d78f23af">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00092">92</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00240">cast()</a>, <a class="el" href="Types_8h_source.html#l00234">dyn_cast()</a>, <a class="el" href="Types_8h_source.html#l00237">dyn_cast_or_null()</a>, and <a class="el" href="Types_8h_source.html#l00224">isa()</a>.</p>

</div>
</div>
<a id="ad1be45203a0010965388d41e712dc268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be45203a0010965388d41e712dc268">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">mlir::Type::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00089">89</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a860e9e7612215565aadad622ccf4cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e9e7612215565aadad622ccf4cbb0">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a>&amp; mlir::Type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00082">Type()</a>.</p>

</div>
</div>
<a id="ac53df1249058e8c2ec0fa70f172f0b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53df1249058e8c2ec0fa70f172f0b59">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00088">88</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00172">impl</a>.</p>

</div>
</div>
<a id="a94f326ccb845e5e7f384a8069153f305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f326ccb845e5e7f384a8069153f305">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> Type::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the current type. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02527">2527</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>, and <a class="el" href="Types_8h_source.html#l00175">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a54ee333db7234f6ada1036072a24b877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee333db7234f6ada1036072a24b877">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::llvm::hash_code hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00220">220</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00106">getTypeID()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a54af6c081e012a32bba9b650480c6c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af6c081e012a32bba9b650480c6c06">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a>* mlir::Type::impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00172">172</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00161">getAsOpaquePointer()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00481">mlir::LLVM::LLVMVectorType::getElementType()</a>, <a class="el" href="Types_8h_source.html#l00220">mlir::hash_value()</a>, <a class="el" href="Types_8h_source.html#l00090">operator bool()</a>, and <a class="el" href="Types_8h_source.html#l00088">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="Types_8h_source.html">Types.h</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="Types_8cpp_source.html">Types.cpp</a></li>
<li>lib/TableGen/<a class="el" href="Type_8cpp_source.html">Type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 16 2020 12:50:41 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
