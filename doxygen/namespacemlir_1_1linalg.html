<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1AffineMinSCFCanonicalizationPattern.html">AffineMinSCFCanonicalizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize AffineMinOp operations in the context of enclosing scf.for and scf.parallel by:  <a href="structmlir_1_1linalg_1_1AffineMinSCFCanonicalizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1Aliases.html">Aliases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very primitive alias analysis which just records for each view, either:  <a href="classmlir_1_1linalg_1_1Aliases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CodegenStrategy.html">CodegenStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codegen strategy controls how a Linalg op is progressively lowered.  <a href="structmlir_1_1linalg_1_1CodegenStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1ConvOpVectorization.html">ConvOpVectorization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Convolution op into vector contraction.  <a href="classmlir_1_1linalg_1_1ConvOpVectorization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1CopyOpToLibraryCallRewrite.html">CopyOpToLibraryCallRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pattern specialization for CopyOp, kicks in when both input and output permutations are left unspecified or are the identity.  <a href="classmlir_1_1linalg_1_1CopyOpToLibraryCallRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1CopyTransposeRewrite.html">CopyTransposeRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite CopyOp with permutations into a sequence of TransposeOp and permutation-free CopyOp.  <a href="classmlir_1_1linalg_1_1CopyTransposeRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing the Linalg producer before and after fusion.  <a href="structmlir_1_1linalg_1_1FusionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <code>loopRanges</code> and loop type described by the <code>iteratorTypes</code>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1IndexedGenericOpToLibraryCallRewrite.html">IndexedGenericOpToLibraryCallRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion pattern specialization for IndexedGenericOp, has special handling for the extra index operands.  <a href="classmlir_1_1linalg_1_1IndexedGenericOpToLibraryCallRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseInterchangePattern.html">LinalgBaseInterchangePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg interchange patterns.  <a href="structmlir_1_1linalg_1_1LinalgBaseInterchangePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html">LinalgBasePromotionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg promotion patterns.  <a href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTileAndFusePattern.html">LinalgBaseTileAndFusePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTilingPattern.html">LinalgBaseTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseVectorizationPattern.html">LinalgBaseVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg vectorization patterns.  <a href="structmlir_1_1linalg_1_1LinalgBaseVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for holding a dependence graph that operates on LinalgOp and views as SSA values.  <a href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgFusionOptions.html">LinalgFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgInterchangePattern.html">LinalgInterchangePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that allow distribution of loops generated in Linalg transforms to processors while generating the loops.  <a href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoweringPattern.html">LinalgLoweringPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to control common attribute matching and setting behavior.  <a href="structmlir_1_1linalg_1_1LinalgMarker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgOpToLibraryCallRewrite.html">LinalgOpToLibraryCallRewrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionPattern.html">LinalgPromotionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTileAndFusePattern.html">LinalgTileAndFusePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingPattern.html">LinalgTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransforms.html">LinalgTransforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationPattern.html">LinalgVectorizationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to get processor ID, and number of processors used for distribution for all parallel loops generated.  <a href="structmlir_1_1linalg_1_1ProcInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Promote.html">Promote</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotion transformation enqueues a particular stage-1 pattern for <code><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Promotion transformation enqueues a particular stage-1 pattern for Promote&lt;LinalgOpType&gt;with the appr...">Promote</a>&lt;LinalgOpType&gt;</code>with the appropriate <code>options</code>.  <a href="structmlir_1_1linalg_1_1Promote.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new buffer using the <code>allocationFn</code> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1RangeType.html">RangeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1linalg_1_1RangeType.html" title="A RangeType represents a minimal range abstraction (min, max, step). ">RangeType</a> represents a minimal range abstraction (min, max, step).  <a href="classmlir_1_1linalg_1_1RangeType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SparsificationOptions.html">SparsificationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparsification options.  <a href="structmlir_1_1linalg_1_1SparsificationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Tile.html">Tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotion transformation enqueues a particular stage-1 pattern for <code><a class="el" href="structmlir_1_1linalg_1_1Tile.html" title="Promotion transformation enqueues a particular stage-1 pattern for Tile&lt;LinalgOpType&gt;with the appropr...">Tile</a>&lt;LinalgOpType&gt;</code>with the appropriate <code>options</code>.  <a href="structmlir_1_1linalg_1_1Tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse a sequence of linalg operations (<code>ops</code>) using tile-and-fuse.  <a href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract <a class="el" href="structmlir_1_1linalg_1_1Transformation.html" title="Abstract Transformation class applied in a sequence that also handles state through markers...">Transformation</a> class applied in a sequence that also handles state through markers.  <a href="structmlir_1_1linalg_1_1Transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Vectorize.html">Vectorize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization transformation enqueues a particular stage-1 pattern for <code><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationPattern.html">LinalgVectorizationPattern</a>&lt;LinalgOpType&gt;</code> as well as copy to vector transfer rewrite forwarding patterns.  <a href="structmlir_1_1linalg_1_1Vectorize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a10103a485fe9c337c136df76eef06b7e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a10103a485fe9c337c136df76eef06b7e">LoopRangeBuilder</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt;</td></tr>
<tr class="separator:a10103a485fe9c337c136df76eef06b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69975b2f4b34a10326a9b5535288ce6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab69975b2f4b34a10326a9b5535288ce6">ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt;</td></tr>
<tr class="separator:ab69975b2f4b34a10326a9b5535288ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7a7d808d207697fcd133ff4c46eed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab4e7a7d808d207697fcd133ff4c46eed">ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;</td></tr>
<tr class="separator:ab4e7a7d808d207697fcd133ff4c46eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6225c1f06228d3cabaf5367e60659b80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6225c1f06228d3cabaf5367e60659b80">AllocBufferCallbackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; boundingSubViewSize, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder)&gt;</td></tr>
<tr class="memdesc:a6225c1f06228d3cabaf5367e60659b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="#a6225c1f06228d3cabaf5367e60659b80">More...</a><br /></td></tr>
<tr class="separator:a6225c1f06228d3cabaf5367e60659b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">DeallocBufferCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">CopyCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">TileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c8e52c82709202bade005c0609f77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> = llvm::MapVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>, 1 &gt; &gt;</td></tr>
<tr class="separator:aed2c8e52c82709202bade005c0609f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a0b220b224fc8b91b37ee63b95a12f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a60a0b220b224fc8b91b37ee63b95a12f">ProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>, 2 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; parallelLoopRanges)&gt;</td></tr>
<tr class="separator:a60a0b220b224fc8b91b37ee63b95a12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">LinalgTilingLoopType::Loops</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">LinalgTilingLoopType::AffineLoops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">LinalgTilingLoopType::ParallelLoops</a> = 2
 }<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg tiling patterns.  <a href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">LinalgLoweringType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c">LinalgLoweringType::LibraryCall</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">LinalgLoweringType::Loops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877">LinalgLoweringType::AffineLoops</a> = 2, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7">LinalgLoweringType::ParallelLoops</a> = 3
 }<tr class="memdesc:a98153087b663d0d7aa3ab0685cfaedaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg lowering patterns.  <a href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ab4803d425ee16eb0e38b32d1db9aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aa">SparseParallelizationStrategy</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aaa35c3ace1970663a16e5c65baa5941b13">SparseParallelizationStrategy::kNone</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aaa09e4a3d1c3e70c9426528f102480e6e7">SparseParallelizationStrategy::kDenseOuterLoop</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aaafe3590ad05890d8754eef93504f9b7af">SparseParallelizationStrategy::kAnyStorageOuterLoop</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aaa0d7778373362fd80feddcb9b38a354b8">SparseParallelizationStrategy::kDenseAnyLoop</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aaa3b1257bf6747bc07f90c215e9aafd4a7">SparseParallelizationStrategy::kAnyStorageAnyLoop</a>
<br />
 }<tr class="memdesc:a60ab4803d425ee16eb0e38b32d1db9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a parallelization strategy.  <a href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aa">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a60ab4803d425ee16eb0e38b32d1db9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2777e3bc15a502b62c7933bc79e18c12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2777e3bc15a502b62c7933bc79e18c12">SparseVectorizationStrategy</a> { <a class="el" href="namespacemlir_1_1linalg.html#a2777e3bc15a502b62c7933bc79e18c12a35c3ace1970663a16e5c65baa5941b13">SparseVectorizationStrategy::kNone</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#a2777e3bc15a502b62c7933bc79e18c12a580289a4bc04d1b8340b94829df37fbb">SparseVectorizationStrategy::kDenseInnerLoop</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#a2777e3bc15a502b62c7933bc79e18c12a3bd27e991efaf1f1fad03867e363b410">SparseVectorizationStrategy::kAnyStorageInnerLoop</a>
 }<tr class="memdesc:a2777e3bc15a502b62c7933bc79e18c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a vectorization strategy.  <a href="namespacemlir_1_1linalg.html#a2777e3bc15a502b62c7933bc79e18c12">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2777e3bc15a502b62c7933bc79e18c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5976a568de1ca78edff41afb434ca0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5976a568de1ca78edff41afb434ca0b">SparseIntType</a> { <a class="el" href="namespacemlir_1_1linalg.html#ab5976a568de1ca78edff41afb434ca0baca6e03c42e2798b2075f3815105e47c6">SparseIntType::kNative</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#ab5976a568de1ca78edff41afb434ca0ba6601e7b0f7c0f03d9ffa9f222c82e6a0">SparseIntType::kI64</a>, 
<a class="el" href="namespacemlir_1_1linalg.html#ab5976a568de1ca78edff41afb434ca0ba0a0ecdb4eded286c722877578774a293">SparseIntType::kI32</a>
 }<tr class="memdesc:ab5976a568de1ca78edff41afb434ca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a type for "pointer" and "index" storage in the sparse storage scheme, with a choice between the native platform-dependent index width, 64-bit integers, or 32-bit integers.  <a href="namespacemlir_1_1linalg.html#ab5976a568de1ca78edff41afb434ca0b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab5976a568de1ca78edff41afb434ca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382d59369873eb3a9a9ddd571056982"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> { <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">DistributionMethod::Cyclic</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">DistributionMethod::CyclicNumProcsGeNumIters</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">DistributionMethod::CyclicNumProcsEqNumIters</a> = 2
 }<tr class="memdesc:a7382d59369873eb3a9a9ddd571056982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme used to distribute loops to processors.  <a href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7382d59369873eb3a9a9ddd571056982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3da433fb329e5403a3aca8f2aff90201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3da433fb329e5403a3aca8f2aff90201">populateLinalgToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a3da433fb329e5403a3aca8f2aff90201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to Standard.  <a href="#a3da433fb329e5403a3aca8f2aff90201">More...</a><br /></td></tr>
<tr class="separator:a3da433fb329e5403a3aca8f2aff90201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a67f3fb54af9cdc66ff265b44a17a5df4">applyMapToValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values obtained by applying <code>map</code> to the list of values.  <a href="#a67f3fb54af9cdc66ff265b44a17a5df4">More...</a><br /></td></tr>
<tr class="separator:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aac538302681e906bd4261c128d90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1linalg.html#a10103a485fe9c337c136df76eef06b7e">LoopRangeBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af9aac538302681e906bd4261c128d90e">defaultLoopRangesBuilder</a> (LinalgOp op)</td></tr>
<tr class="memdesc:af9aac538302681e906bd4261c128d90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a very simple inference procedure to build the loop ranges from the op and its operands.  <a href="#af9aac538302681e906bd4261c128d90e">More...</a><br /></td></tr>
<tr class="separator:af9aac538302681e906bd4261c128d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <a href="#a754ec5c5960c640563ddcd9727b77d87">More...</a><br /></td></tr>
<tr class="separator:a754ec5c5960c640563ddcd9727b77d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (<a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>.  <a href="#a962a46fba2ac497e30bb6d23fef35d1a">More...</a><br /></td></tr>
<tr class="separator:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memTemplParams" colspan="2">template&lt;typename PoolingOp &gt; </td></tr>
<tr class="memitem:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5dd029acdda95eeb6887d0e169bcbb5">weightedPoolingInputIndex</a> (PoolingOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; outputDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; windowDims)</td></tr>
<tr class="memdesc:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the indexing expressions for a ConvOp/PoolingOp <code>op</code>.  <a href="#ab5dd029acdda95eeb6887d0e169bcbb5">More...</a><br /></td></tr>
<tr class="separator:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ddca37c4e3bf09cb06fc5197380bde3">extractOrIdentityMap</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, <a class="el" href="classunsigned.html">unsigned</a> rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>.  <a href="#a6ddca37c4e3bf09cb06fc5197380bde3">More...</a><br /></td></tr>
<tr class="separator:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; b)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <code>a</code> and <code>b</code>.  <a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">More...</a><br /></td></tr>
<tr class="separator:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d0107ce313528b9b8b2ecefb43e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a504d0107ce313528b9b8b2ecefb43e38">getDimsOfType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef iteratorTypeName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;res)</td></tr>
<tr class="memdesc:a504d0107ce313528b9b8b2ecefb43e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dims that are <code>iteratorTypeName</code> loops in the LinalgOp <code>op</code>.  <a href="#a504d0107ce313528b9b8b2ecefb43e38">More...</a><br /></td></tr>
<tr class="separator:a504d0107ce313528b9b8b2ecefb43e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca3e5737cb6287861d9315999de8e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1ca3e5737cb6287861d9315999de8e75">hoistViewAllocOps</a> (FuncOp func)</td></tr>
<tr class="memdesc:a1ca3e5737cb6287861d9315999de8e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist alloc/dealloc pairs and alloca op out of immediately enclosing scf::ForOp if both conditions are true:  <a href="#a1ca3e5737cb6287861d9315999de8e75">More...</a><br /></td></tr>
<tr class="separator:a1ca3e5737cb6287861d9315999de8e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc911548f9f0328faf5855ab880e7bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afbc911548f9f0328faf5855ab880e7bc">hoistRedundantVectorTransfers</a> (FuncOp func)</td></tr>
<tr class="memdesc:afbc911548f9f0328faf5855ab880e7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <a href="#afbc911548f9f0328faf5855ab880e7bc">More...</a><br /></td></tr>
<tr class="separator:afbc911548f9f0328faf5855ab880e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb36f5e419e824d5003b53b922eebfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8bb36f5e419e824d5003b53b922eebfe">populateConvVectorizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &gt; &amp;patterns, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes)</td></tr>
<tr class="memdesc:a8bb36f5e419e824d5003b53b922eebfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for vectorization of all ConvN-D ops.  <a href="#a8bb36f5e419e824d5003b53b922eebfe">More...</a><br /></td></tr>
<tr class="separator:a8bb36f5e419e824d5003b53b922eebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8893ac7d0de6eaaf5a82120404825665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8893ac7d0de6eaaf5a82120404825665">populateLinalgBufferizePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a8893ac7d0de6eaaf5a82120404825665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns to bufferize linalg ops.  <a href="#a8893ac7d0de6eaaf5a82120404825665">More...</a><br /></td></tr>
<tr class="separator:a8893ac7d0de6eaaf5a82120404825665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2efdb9223f206f2d1f8f8ee6b27564f">tileLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="#ab2efdb9223f206f2d1f8f8ee6b27564f">More...</a><br /></td></tr>
<tr class="separator:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0dffca46cdba77603c5b6b113d5c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0d0dffca46cdba77603c5b6b113d5c7a">tileAndFuseLinalgOps</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;tilingOptions)</td></tr>
<tr class="separator:a0d0dffca46cdba77603c5b6b113d5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3b16ee2227dad39c6771069df37e34"><td class="memItemLeft" align="right" valign="top">LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d3b16ee2227dad39c6771069df37e34">interchange</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a3d3b16ee2227dad39c6771069df37e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions of <code>op</code>.  <a href="#a3d3b16ee2227dad39c6771069df37e34">More...</a><br /></td></tr>
<tr class="separator:a3d3b16ee2227dad39c6771069df37e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1995fb7a1d6a3a28e7607df02c8a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9d1995fb7a1d6a3a28e7607df02c8a7e">promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, SubViewOp subView, <a class="el" href="namespacemlir_1_1linalg.html#a6225c1f06228d3cabaf5367e60659b80">AllocBufferCallbackFn</a> allocationFn, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder=nullptr)</td></tr>
<tr class="separator:a9d1995fb7a1d6a3a28e7607df02c8a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea396843a4c8fce5aa96c6d49a483661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aea396843a4c8fce5aa96c6d49a483661">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder=nullptr)</td></tr>
<tr class="memdesc:aea396843a4c8fce5aa96c6d49a483661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="#aea396843a4c8fce5aa96c6d49a483661">More...</a><br /></td></tr>
<tr class="separator:aea396843a4c8fce5aa96c6d49a483661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae5d2ec66e658cbabd89ea5c15a5ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3fae5d2ec66e658cbabd89ea5c15a5ef">vectorizeLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a3fae5d2ec66e658cbabd89ea5c15a5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Linalg op with fully static shape.  <a href="#a3fae5d2ec66e658cbabd89ea5c15a5ef">More...</a><br /></td></tr>
<tr class="separator:a3fae5d2ec66e658cbabd89ea5c15a5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="memTemplParams" colspan="2">template&lt;typename LoopTy &gt; </td></tr>
<tr class="memitem:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6f06d90d0f4f8c54740c7387cc7a566a">linalgLowerOpToLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>LoopTy</code> with the proper body for <code>op</code>.  <a href="#a6f06d90d0f4f8c54740c7387cc7a566a">More...</a><br /></td></tr>
<tr class="separator:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86639658ec94ada14e3a8569b62c5322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a86639658ec94ada14e3a8569b62c5322">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a86639658ec94ada14e3a8569b62c5322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.for</code> with the proper body for <code>op</code>.  <a href="#a86639658ec94ada14e3a8569b62c5322">More...</a><br /></td></tr>
<tr class="separator:a86639658ec94ada14e3a8569b62c5322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab13dd380c27183fb9cec5d731eacc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5ab13dd380c27183fb9cec5d731eacc9">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5ab13dd380c27183fb9cec5d731eacc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>op</code>.  <a href="#a5ab13dd380c27183fb9cec5d731eacc9">More...</a><br /></td></tr>
<tr class="separator:a5ab13dd380c27183fb9cec5d731eacc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1ea88640f72268964910f4e170c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a65b1ea88640f72268964910f4e170c2b">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a65b1ea88640f72268964910f4e170c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>affine.for</code> with the proper body for <code>op</code>.  <a href="#a65b1ea88640f72268964910f4e170c2b">More...</a><br /></td></tr>
<tr class="separator:a65b1ea88640f72268964910f4e170c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b9fae0d74c3d13d7612c73ea66c7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae8b9fae0d74c3d13d7612c73ea66c7c0">interchangeGenericLinalgOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:ae8b9fae0d74c3d13d7612c73ea66c7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a <code>generic</code> or <code>indexed_generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>.  <a href="#ae8b9fae0d74c3d13d7612c73ea66c7c0">More...</a><br /></td></tr>
<tr class="separator:ae8b9fae0d74c3d13d7612c73ea66c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Promotion transformation enqueues a particular stage-1 pattern for Promote&lt;LinalgOpType&gt;with the appr...">Promote</a> std.subviews feeding linalg operations.  <a href="#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bd78a651f6a42d01090db72bc039c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a434bd78a651f6a42d01090db72bc039c">vectorizeLinalgOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a434bd78a651f6a42d01090db72bc039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a linalg.generic into a suitable vector.contraction op.  <a href="#a434bd78a651f6a42d01090db72bc039c">More...</a><br /></td></tr>
<tr class="separator:a434bd78a651f6a42d01090db72bc039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4bbb94eb4bb91c171a4eec22374453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6c4bbb94eb4bb91c171a4eec22374453">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a6c4bbb94eb4bb91c171a4eec22374453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="#a6c4bbb94eb4bb91c171a4eec22374453">More...</a><br /></td></tr>
<tr class="separator:a6c4bbb94eb4bb91c171a4eec22374453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3476cd1399d5bcda0827220ea9c7f105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3476cd1399d5bcda0827220ea9c7f105">populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:a3476cd1399d5bcda0827220ea9c7f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b26f2e4297d8349803cab2e1d9bf32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a64b26f2e4297d8349803cab2e1d9bf32">populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a> marker=<a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a>())</td></tr>
<tr class="memdesc:a64b26f2e4297d8349803cab2e1d9bf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <a href="#a64b26f2e4297d8349803cab2e1d9bf32">More...</a><br /></td></tr>
<tr class="separator:a64b26f2e4297d8349803cab2e1d9bf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fe6c6c47d52860111960fc07d817ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a77fe6c6c47d52860111960fc07d817ed">populateLinalgConvGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a> marker=<a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a>())</td></tr>
<tr class="memdesc:a77fe6c6c47d52860111960fc07d817ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns to convert linalg.conv ops to linalg.generic ops.  <a href="#a77fe6c6c47d52860111960fc07d817ed">More...</a><br /></td></tr>
<tr class="separator:a77fe6c6c47d52860111960fc07d817ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ee51b5397a712bcc28ccddaa94791f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae5ee51b5397a712bcc28ccddaa94791f">applyStagedPatterns</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &gt; stage1Patterns, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;stage2Patterns, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; stage3Lambda=nullptr)</td></tr>
<tr class="memdesc:ae5ee51b5397a712bcc28ccddaa94791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion:  <a href="#ae5ee51b5397a712bcc28ccddaa94791f">More...</a><br /></td></tr>
<tr class="separator:ae5ee51b5397a712bcc28ccddaa94791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b24b8390edbdd1026ef6a2433534c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac77b24b8390edbdd1026ef6a2433534c">populateSparsificationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, const <a class="el" href="structmlir_1_1linalg_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1linalg_1_1SparsificationOptions.html">SparsificationOptions</a>())</td></tr>
<tr class="memdesc:ac77b24b8390edbdd1026ef6a2433534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up sparsification rewriting rules with the given options.  <a href="#ac77b24b8390edbdd1026ef6a2433534c">More...</a><br /></td></tr>
<tr class="separator:ac77b24b8390edbdd1026ef6a2433534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9742d07020a6835f7a1855ef4f81c294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9742d07020a6835f7a1855ef4f81c294">isParallelIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a9742d07020a6835f7a1855ef4f81c294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#a9742d07020a6835f7a1855ef4f81c294">More...</a><br /></td></tr>
<tr class="separator:a9742d07020a6835f7a1855ef4f81c294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bde6d8fa6533d77b1d706654f0f963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af7bde6d8fa6533d77b1d706654f0f963">isReductionIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:af7bde6d8fa6533d77b1d706654f0f963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#af7bde6d8fa6533d77b1d706654f0f963">More...</a><br /></td></tr>
<tr class="separator:af7bde6d8fa6533d77b1d706654f0f963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecab0d508abda7349407fa91a3b47e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0ecab0d508abda7349407fa91a3b47e">isWindowIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:ad0ecab0d508abda7349407fa91a3b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#ad0ecab0d508abda7349407fa91a3b47e">More...</a><br /></td></tr>
<tr class="separator:ad0ecab0d508abda7349407fa91a3b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1a2959f54ccc7cabc35c9337f50c0734">isProducerLastWriteOfView</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a1a2959f54ccc7cabc35c9337f50c0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>.  <a href="#a1a2959f54ccc7cabc35c9337f50c0734">More...</a><br /></td></tr>
<tr class="separator:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf6605778cf3f93537f2bc2e58da089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6bf6605778cf3f93537f2bc2e58da089">isFusableInto</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a6bf6605778cf3f93537f2bc2e58da089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible.  <a href="#a6bf6605778cf3f93537f2bc2e58da089">More...</a><br /></td></tr>
<tr class="separator:a6bf6605778cf3f93537f2bc2e58da089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad74083992ed8c5b3e804e513bdd29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a13ad74083992ed8c5b3e804e513bdd29">findAllFusableDependences</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph)</td></tr>
<tr class="memdesc:a13ad74083992ed8c5b3e804e513bdd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all dependences that are fusable.  <a href="#a13ad74083992ed8c5b3e804e513bdd29">More...</a><br /></td></tr>
<tr class="separator:a13ad74083992ed8c5b3e804e513bdd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0b815c49a028a8a605ae76d2940360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6f0b815c49a028a8a605ae76d2940360">fuseProducerOfBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp consumer, <a class="el" href="classunsigned.html">unsigned</a> consumerIdx, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a6f0b815c49a028a8a605ae76d2940360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies.  <a href="#a6f0b815c49a028a8a605ae76d2940360">More...</a><br /></td></tr>
<tr class="separator:a6f0b815c49a028a8a605ae76d2940360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c7e79ea0da425639e2582dcd085073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a30c7e79ea0da425639e2582dcd085073">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp consumer, <a class="el" href="classunsigned.html">unsigned</a> consumerIdx)</td></tr>
<tr class="memdesc:a30c7e79ea0da425639e2582dcd085073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="#a30c7e79ea0da425639e2582dcd085073">More...</a><br /></td></tr>
<tr class="separator:a30c7e79ea0da425639e2582dcd085073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bab525b091111ea64710884928b4559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7bab525b091111ea64710884928b4559">fuseTensorOps</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *consumer, <a class="el" href="classunsigned.html">unsigned</a> consumerIdx)</td></tr>
<tr class="memdesc:a7bab525b091111ea64710884928b4559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse linalg operation on tensors, with the producer of the operand at position <code>consumerIdx</code> of the consumer.  <a href="#a7bab525b091111ea64710884928b4559">More...</a><br /></td></tr>
<tr class="separator:a7bab525b091111ea64710884928b4559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530f16081d546284eb2273df0e359881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a530f16081d546284eb2273df0e359881">getStaticShape</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a530f16081d546284eb2273df0e359881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>getShape</code>, but only returns statically-known information, without generating any new IR.  <a href="#a530f16081d546284eb2273df0e359881">More...</a><br /></td></tr>
<tr class="separator:a530f16081d546284eb2273df0e359881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e76d73be6ad7ae5593d983f9816d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a15e76d73be6ad7ae5593d983f9816d09">getStaticLoopRanges</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a15e76d73be6ad7ae5593d983f9816d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the statically-known loop ranges of the <code>linalgOp</code>.  <a href="#a15e76d73be6ad7ae5593d983f9816d09">More...</a><br /></td></tr>
<tr class="separator:a15e76d73be6ad7ae5593d983f9816d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad21c196847c314c07d222ce3f6bdaa8c">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permutation)</td></tr>
<tr class="memdesc:ad21c196847c314c07d222ce3f6bdaa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="#ad21c196847c314c07d222ce3f6bdaa8c">More...</a><br /></td></tr>
<tr class="separator:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde2ef42e2887221b469aa879f8e892a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#adde2ef42e2887221b469aa879f8e892a">updateBoundsForCyclicDistribution</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> procId, <a class="el" href="classmlir_1_1Value.html">Value</a> nprocs, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lb, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;ub, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;step)</td></tr>
<tr class="memdesc:adde2ef42e2887221b469aa879f8e892a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>.  <a href="#adde2ef42e2887221b469aa879f8e892a">More...</a><br /></td></tr>
<tr class="separator:adde2ef42e2887221b469aa879f8e892a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10a7b62949f7a975415094a9e053482"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac10a7b62949f7a975415094a9e053482">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; iteratorTypes, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> &gt; distributionMethod={})</td></tr>
<tr class="memdesc:ac10a7b62949f7a975415094a9e053482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes.  <a href="#ac10a7b62949f7a975415094a9e053482">More...</a><br /></td></tr>
<tr class="separator:ac10a7b62949f7a975415094a9e053482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6225c1f06228d3cabaf5367e60659b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6225c1f06228d3cabaf5367e60659b80">&#9670;&nbsp;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a6225c1f06228d3cabaf5367e60659b80">mlir::linalg::AllocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; boundingSubViewSize, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to perform the allocation for the promoted <code>subView</code>. </p>
<p>In <code>boundingSubViewsize</code> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00151">151</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa49994e2aab61b35167972384684cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49994e2aab61b35167972384684cf24">&#9670;&nbsp;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <code>src</code> to <code>dst</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00163">163</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3d7afb284c4be072a74a24eeb71cc985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7afb284c4be072a74a24eeb71cc985">&#9670;&nbsp;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00156">156</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aed2c8e52c82709202bade005c0609f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2c8e52c82709202bade005c0609f77">&#9670;&nbsp;</a></span>FusableOpDependencesTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">mlir::linalg::FusableOpDependencesTy</a> = typedef llvm::MapVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>, 1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00088">88</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a4a9ca79033211e3e53e0eb25a8e9551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ca79033211e3e53e0eb25a8e9551b">&#9670;&nbsp;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00032">32</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a10103a485fe9c337c136df76eef06b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10103a485fe9c337c136df76eef06b7e">&#9670;&nbsp;</a></span>LoopRangeBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a10103a485fe9c337c136df76eef06b7e">mlir::linalg::LoopRangeBuilder</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00044">44</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="a60a0b220b224fc8b91b37ee63b95a12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a0b220b224fc8b91b37ee63b95a12f">&#9670;&nbsp;</a></span>ProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a60a0b220b224fc8b91b37ee63b95a12f">mlir::linalg::ProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>, 2&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>&gt; parallelLoopRanges)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00188">188</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="ab4e7a7d808d207697fcd133ff4c46eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7a7d808d207697fcd133ff4c46eed">&#9670;&nbsp;</a></span>ReassociationExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ab4e7a7d808d207697fcd133ff4c46eed">mlir::linalg::ReassociationExprs</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00060">60</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="ab69975b2f4b34a10326a9b5535288ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69975b2f4b34a10326a9b5535288ce6">&#9670;&nbsp;</a></span>ReassociationIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ab69975b2f4b34a10326a9b5535288ce6">mlir::linalg::ReassociationIndices</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00059">59</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="a730df0415b8172eb93f8f7b346e04440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730df0415b8172eb93f8f7b346e04440">&#9670;&nbsp;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00333">333</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7382d59369873eb3a9a9ddd571056982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7382d59369873eb3a9a9ddd571056982">&#9670;&nbsp;</a></span>DistributionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">mlir::linalg::DistributionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scheme used to distribute loops to processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Cyclic distribution where no assumption is made about the dynamic relationship between number of processors and number of iterations of the distributed loop. </p>
<p>Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>scf.parallel(iv)= (lb + procId * step) to (ub) step (step * nprocs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e"></a>CyclicNumProcsGeNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be more than or equal to the number of iterations of the distributed loop. </p>
<p>In such cases, a simple in-bounds check is enough (instead of materializing a loop). Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step cond = cmpi "slt", iv, ub scf.if cond { ... } </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b"></a>CyclicNumProcsEqNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be equal to the number of iterations of the distributed loop. </p>
<p>In such cases, no bounds check is needed. Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00141">141</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a98153087b663d0d7aa3ab0685cfaedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98153087b663d0d7aa3ab0685cfaedaf">&#9670;&nbsp;</a></span>LinalgLoweringType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">mlir::linalg::LinalgLoweringType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg lowering patterns. </p>
<p>Apply the <code>linalgLowerOpToLoops</code> transformation as a pattern. <code>marker</code> controls LinalgTransformMarker matching and update when specified. See <code>linalgLowerOpToLoops</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c"></a>LibraryCall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00584">584</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&nbsp;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg tiling patterns. </p>
<p>Apply the <code>tileLinalgOp</code> transformation as a pattern. <code>marker</code> controls LinalgTransformMarker matching and update when specified. See <code>tileLinalgOp</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00326">326</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ab5976a568de1ca78edff41afb434ca0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5976a568de1ca78edff41afb434ca0b">&#9670;&nbsp;</a></span>SparseIntType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#ab5976a568de1ca78edff41afb434ca0b">mlir::linalg::SparseIntType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a type for "pointer" and "index" storage in the sparse storage scheme, with a choice between the native platform-dependent index width, 64-bit integers, or 32-bit integers. </p>
<p>A narrow width obviously reduces the memory footprint of the sparse storage scheme, but the width should suffice to define the total required range (viz. the maximum number of stored entries per indirection level for the "pointers" and the maximum value of each tensor index over all dimensions for the "indices"). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5976a568de1ca78edff41afb434ca0baca6e03c42e2798b2075f3815105e47c6"></a>kNative&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5976a568de1ca78edff41afb434ca0ba6601e7b0f7c0f03d9ffa9f222c82e6a0"></a>kI64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5976a568de1ca78edff41afb434ca0ba0a0ecdb4eded286c722877578774a293"></a>kI32&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00838">838</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a60ab4803d425ee16eb0e38b32d1db9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ab4803d425ee16eb0e38b32d1db9aa">&#9670;&nbsp;</a></span>SparseParallelizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a60ab4803d425ee16eb0e38b32d1db9aa">mlir::linalg::SparseParallelizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a parallelization strategy. </p>
<p>Any implicit loop in the Linalg operation that is marked "parallel" (thus not "reduction") is a candidate for parallelization. The loop is made parallel if (1) allowed by the strategy (e.g., AnyStorageOuterLoop considers either a dense or sparse outermost loop only), and (2) the generated code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a60ab4803d425ee16eb0e38b32d1db9aaa35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a60ab4803d425ee16eb0e38b32d1db9aaa09e4a3d1c3e70c9426528f102480e6e7"></a>kDenseOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a60ab4803d425ee16eb0e38b32d1db9aaafe3590ad05890d8754eef93504f9b7af"></a>kAnyStorageOuterLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a60ab4803d425ee16eb0e38b32d1db9aaa0d7778373362fd80feddcb9b38a354b8"></a>kDenseAnyLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a60ab4803d425ee16eb0e38b32d1db9aaa3b1257bf6747bc07f90c215e9aafd4a7"></a>kAnyStorageAnyLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00811">811</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a2777e3bc15a502b62c7933bc79e18c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2777e3bc15a502b62c7933bc79e18c12">&#9670;&nbsp;</a></span>SparseVectorizationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a2777e3bc15a502b62c7933bc79e18c12">mlir::linalg::SparseVectorizationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a vectorization strategy. </p>
<p>Any implicit inner loop in the Linalg operation is a candidate (full SIMD for "parallel" loops and horizontal SIMD for "reduction" loops). A loop is actually vectorized if (1) allowed by the strategy, and (2) the emitted code is an actual for-loop (and not a co-iterating while-loop). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2777e3bc15a502b62c7933bc79e18c12a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2777e3bc15a502b62c7933bc79e18c12a580289a4bc04d1b8340b94829df37fbb"></a>kDenseInnerLoop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2777e3bc15a502b62c7933bc79e18c12a3bd27e991efaf1f1fad03867e363b410"></a>kAnyStorageInnerLoop&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00825">825</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67f3fb54af9cdc66ff265b44a17a5df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f3fb54af9cdc66ff265b44a17a5df4">&#9670;&nbsp;</a></span>applyMapToValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::applyMapToValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values obtained by applying <code>map</code> to the list of values. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l00044">44</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l01483">buildNamedStructuredOpRegionAndAttributes()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00035">createFoldedComposedAffineApply()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00242">mlir::ShapedType::getRank()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00225">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01526">parseCommonStructuredOpParts()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01578">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01501">parseNamedStructuredOpRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01517">parseNamedStructuredOpResults()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01610">printCommonStructuredOpParts()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01623">printNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01602">printNamedStructuredOpResults()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l01639">verifyNamedStructuredOp()</a>.</p>

</div>
</div>
<a id="ad21c196847c314c07d222ce3f6bdaa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21c196847c314c07d222ce3f6bdaa8c">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector `inVec = ['a', 'b', 'c']<code>and a permutation vector </code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00132">132</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00056">interchange()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00318">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ae5ee51b5397a712bcc28ccddaa94791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ee51b5397a712bcc28ccddaa94791f">&#9670;&nbsp;</a></span>applyStagedPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::applyStagedPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &gt;&#160;</td>
          <td class="paramname"><em>stage1Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>stage2Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>stage3Lambda</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion: </p>
<ol type="1">
<li>the first stage consists of a list of <a class="el" href="classmlir_1_1FrozenRewritePatternList.html" title="This class represents a frozen set of patterns that can be processed by a pattern applicator...">FrozenRewritePatternList</a>. Each <a class="el" href="classmlir_1_1FrozenRewritePatternList.html" title="This class represents a frozen set of patterns that can be processed by a pattern applicator...">FrozenRewritePatternList</a> in this list is applied once, in order.</li>
<li>the second stage consists of a single OwningRewritePattern that is applied greedily until convergence.</li>
<li>the third stage consists of applying a lambda, generally used for non-local transformation effects. This allows creating custom fused transformations where patterns can be ordered and applied at a finer granularity than a sequence of traditional compiler passes. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00316">316</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00763">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::ConvOpVectorization()</a>, and <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <code>a</code> and <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01388">1388</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00584">mlir::Simplex::makeProduct()</a>.</p>

</div>
</div>
<a id="af9aac538302681e906bd4261c128d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aac538302681e906bd4261c128d90e">&#9670;&nbsp;</a></span>defaultLoopRangesBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1linalg.html#a10103a485fe9c337c136df76eef06b7e">LoopRangeBuilder</a> mlir::linalg::defaultLoopRangesBuilder </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a very simple inference procedure to build the loop ranges from the op and its operands. </p>
<p>This only works with permutation affine maps and patterns of the form <code>(m, n)[s] -&gt; (m + n - s floordiv 2)</code>. A more advanced Tensor-Comprehension like inference is possible but has proven to be ambiguous in unfavorable case. As a consequence, we relax the default behavior very conservatively and provide an op-specified hook so that Linalg ops may override the behavior. </p>

</div>
</div>
<a id="a6ddca37c4e3bf09cb06fc5197380bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddca37c4e3bf09cb06fc5197380bde3">&#9670;&nbsp;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01340">1340</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00168">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a13ad74083992ed8c5b3e804e513bdd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad74083992ed8c5b3e804e513bdd29">&#9670;&nbsp;</a></span>findAllFusableDependences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> mlir::linalg::findAllFusableDependences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all dependences that are fusable. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00726">726</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00381">findFusableProducer()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00351">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00836">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="a6f0b815c49a028a8a605ae76d2940360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0b815c49a028a8a605ae76d2940360">&#9670;&nbsp;</a></span>fuseProducerOfBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>consumerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies. </p>
<p>Implements the fusion part of the "tileAndFuse on buffers" transformation and thus requires the <code>consumerdIdx</code>^th operand of <code>consumer</code> to be a <code>subview</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00427">427</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00381">findFusableProducer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00210">fuse()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a30c7e79ea0da425639e2582dcd085073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c7e79ea0da425639e2582dcd085073">&#9670;&nbsp;</a></span>fuseProducerOfTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>consumerIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerdIdx</code>^th operand of <code>consumer</code> to be the result of a <code>subtensor</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00490">490</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Fusion_8cpp_source.html#l00210">fuse()</a>, <a class="el" href="Value_8cpp_source.html#l00231">mlir::OpOperand::get()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Fusion_8cpp_source.html#l00465">getProducerOfTensor()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Value_8cpp_source.html#l00236">mlir::OpOperand::set()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a7bab525b091111ea64710884928b4559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bab525b091111ea64710884928b4559">&#9670;&nbsp;</a></span>fuseTensorOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 1 &gt; &gt; mlir::linalg::fuseTensorOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>consumerIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse linalg operation on tensors, with the producer of the operand at position <code>consumerIdx</code> of the consumer. </p>

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l00935">935</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00175">mlir::PatternRewriter::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00179">fuseTensorOpsImpl()</a>, <a class="el" href="Operation_8cpp_source.html#l00214">mlir::Operation::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Operation_8h_source.html#l00228">mlir::Operation::getNumOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00554">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00232">mlir::Operation::getOperand()</a>, <a class="el" href="Operation_8h_source.html#l00413">mlir::Operation::getRegions()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l01004">mlir::populateFoldReshapeOpsByLinearizationPatterns()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l01019">mlir::populateLinalgTensorOpsFusionPatterns()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00161">mlir::PatternRewriter::replaceOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, and <a class="el" href="Operation_8h_source.html#l00582">mlir::Operation::use_empty()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&nbsp;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <code>linalg.</code> prefix, and the <code>&lt;</code>, <code>&gt;</code>, <code>?</code> symbols from the type. Assumes <code>op</code> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(A, f) : memref&lt;f32&gt;, f32 name mangles into <code>linalg_fill_viewf32_f32_impl</code></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, memref&lt;f32&gt;) name mangles into <code>linalg_dot_viewxf32_viewxf32_viewf32_impl</code></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <code>linalg_matmul_viewxxf32_viewxxf32_viewxxf32_impl</code> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01417">1417</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l01396">appendMangledType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00133">foldMemRefCast()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00647">foldReshapeOp()</a>, <a class="el" href="Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="Operation_8h_source.html#l00268">mlir::Operation::getOperandTypes()</a>, <a class="el" href="Operation_8cpp_source.html#l00049">mlir::OperationName::getStringRef()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="ac10a7b62949f7a975415094a9e053482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10a7b62949f7a975415094a9e053482">&#9670;&nbsp;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> &gt;&#160;</td>
          <td class="paramname"><em>distributionMethod</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes. </p>
<p>` Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <code>bodyBuilderFn</code> that accepts a range of induction variables for all loops. <code>ivStorage</code> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00203">203</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00096">mlir::edsc::conditionBuilder()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">Cyclic</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">CyclicNumProcsEqNumIters</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">CyclicNumProcsGeNumIters</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00060">isParallelIteratorType()</a>, <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00018">mlir::edsc::loopNestBuilder()</a>, and <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00249">mlir::edsc::op::slt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00314">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a504d0107ce313528b9b8b2ecefb43e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504d0107ce313528b9b8b2ecefb43e38">&#9670;&nbsp;</a></span>getDimsOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::getDimsOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>iteratorTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dims that are <code>iteratorTypeName</code> loops in the LinalgOp <code>op</code>. </p>
<p>Assumes <code>op</code> is a LinalgOp. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01325">1325</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">mlir::getAffineDimExpr()</a>, and <a class="el" href="Operation_8cpp_source.html#l00214">mlir::Operation::getContext()</a>.</p>

</div>
</div>
<a id="a6c4bbb94eb4bb91c171a4eec22374453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4bbb94eb4bb91c171a4eec22374453">&#9670;&nbsp;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00555">555</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp_source.html#l00561">populateLinalgTilingCanonicalizationPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00590">applyTilingToLoopPatterns()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00379">mlir::linalg::LinalgTilingOptions::setDistributionOptions()</a>, and <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a15e76d73be6ad7ae5593d983f9816d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e76d73be6ad7ae5593d983f9816d09">&#9670;&nbsp;</a></span>getStaticLoopRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::linalg::getStaticLoopRanges </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the statically-known loop ranges of the <code>linalgOp</code>. </p>
<p>Composes <code>linalgOp.getShapesToLoopsMap()</code> with the result of <code>getStaticShape</code>. Returns None if <code>linalgOp.getShapesToLoopsMap()</code> fails. Returns -1 for non-statically-known loop ranges. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00116">116</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">mlir::AffineMap::compose()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00101">getStaticShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00437">fuseWithReshapeByExpansion()</a>.</p>

</div>
</div>
<a id="a530f16081d546284eb2273df0e359881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530f16081d546284eb2273df0e359881">&#9670;&nbsp;</a></span>getStaticShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; mlir::linalg::getStaticShape </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>getShape</code>, but only returns statically-known information, without generating any new IR. </p>
<p>For each shape dimension, returns &gt;=0 if that dimension is statically known, or -1 otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00101">101</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Traits_8cpp_source.html#l00091">getShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00116">getStaticLoopRanges()</a>.</p>

</div>
</div>
<a id="afbc911548f9f0328faf5855ab880e7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc911548f9f0328faf5855ab880e7bc">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop) To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00084">84</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00046">mlir::WalkResult::advance()</a>, <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00025">mlir::cloneWithNewYields()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00030">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="namespacemlir.html#ab3c9138cd38e82a78b5895b0e606d5d6">mlir::getForwardSlice()</a>, <a class="el" href="Visitors_8h_source.html#l00045">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00078">mlir::moveLoopInvariantCode()</a>, and <a class="el" href="Dominance_8cpp_source.html#l00221">mlir::DominanceInfo::properlyDominates()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a1ca3e5737cb6287861d9315999de8e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca3e5737cb6287861d9315999de8e75">&#9670;&nbsp;</a></span>hoistViewAllocOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistViewAllocOps </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist alloc/dealloc pairs and alloca op out of immediately enclosing scf::ForOp if both conditions are true: </p>
<ol type="1">
<li>All operands are defined outside the loop.</li>
<li>All uses are ViewLikeOp or DeallocOp. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00037">37</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Hoisting_8cpp_source.html#l00030">DBGS</a>, <a class="el" href="Operation_8cpp_source.html#l00554">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00254">mlir::Operation::getOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00231">mlir::Operation::getParentOp()</a>, <a class="el" href="Operation_8h_source.html#l00278">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00183">mlir::Value::getUses()</a>, and <a class="el" href="Operation_8cpp_source.html#l00517">mlir::Operation::moveAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a3d3b16ee2227dad39c6771069df37e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3b16ee2227dad39c6771069df37e34">&#9670;&nbsp;</a></span>interchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LinalgOp mlir::linalg::interchange </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions of <code>op</code>. </p>
<p>This is an in-place transformation controlled by <code>interchangeVector</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed with <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>op.rank</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00056">56</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00132">applyPermutationToVector()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">mlir::AffineMap::compose()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00028">mlir::AffineMapAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00038">mlir::ArrayAttr::get()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00051">mlir::getIndexingMapsAttrName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00055">mlir::getIteratorTypesAttrName()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00114">mlir::AffineMap::getPermutationMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00417">mlir::inversePermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00249">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae8b9fae0d74c3d13d7612c73ea66c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b9fae0d74c3d13d7612c73ea66c7c0">&#9670;&nbsp;</a></span>interchangeGenericLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::interchangeGenericLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a <code>generic</code> or <code>indexed_generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00035">35</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Operation_8cpp_source.html#l00214">mlir::Operation::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00114">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00417">mlir::inversePermutation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00249">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a6bf6605778cf3f93537f2bc2e58da089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf6605778cf3f93537f2bc2e58da089">&#9670;&nbsp;</a></span>isFusableInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isFusableInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible. </p>
<p>This checks <code>producer</code> is the last write of <code>consumedView</code> and that no interleaved dependence would be violated (RAW, WAR or WAW). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00324">324</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00214">mlir::linalg::LinalgDependenceGraph::findCoveringDependences()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00300">isProducerLastWriteOfView()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00381">findFusableProducer()</a>.</p>

</div>
</div>
<a id="a9742d07020a6835f7a1855ef4f81c294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9742d07020a6835f7a1855ef4f81c294">&#9670;&nbsp;</a></span>isParallelIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isParallelIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00060">60</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00108">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00078">mlir::getParallelIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00314">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00203">generateParallelLoopNest()</a>, and <a class="el" href="Sparsification_8cpp_source.html#l00663">genFor()</a>.</p>

</div>
</div>
<a id="a1a2959f54ccc7cabc35c9337f50c0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2959f54ccc7cabc35c9337f50c0734">&#9670;&nbsp;</a></span>isProducerLastWriteOfView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isProducerLastWriteOfView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>. </p>
<p>This checks structural dominance, that the dependence is a RAW without any interleaved write to any piece of <code>consumedView</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00300">300</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00221">mlir::linalg::LinalgDependenceGraph::findCoveringWrites()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00279">isStructurallyFusableProducer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00324">isFusableInto()</a>.</p>

</div>
</div>
<a id="af7bde6d8fa6533d77b1d706654f0f963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bde6d8fa6533d77b1d706654f0f963">&#9670;&nbsp;</a></span>isReductionIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isReductionIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00067">67</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00108">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00085">mlir::getReductionIteratorTypeName()</a>.</p>

</div>
</div>
<a id="ad0ecab0d508abda7349407fa91a3b47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecab0d508abda7349407fa91a3b47e">&#9670;&nbsp;</a></span>isWindowIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isWindowIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">74</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00108">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00092">mlir::getWindowIteratorTypeName()</a>.</p>

</div>
</div>
<a id="a6f06d90d0f4f8c54740c7387cc7a566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06d90d0f4f8c54740c7387cc7a566a">&#9670;&nbsp;</a></span>linalgLowerOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoopTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgLowerOpToLoops&lt; AffineForOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>LoopTy</code> with the proper body for <code>op</code>. </p>
<p>Emits a loop nest with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00657">657</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="a65b1ea88640f72268964910f4e170c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b1ea88640f72268964910f4e170c2b">&#9670;&nbsp;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>affine.for</code> with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00673">673</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a86639658ec94ada14e3a8569b62c5322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86639658ec94ada14e3a8569b62c5322">&#9670;&nbsp;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.for</code> with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00680">680</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a5ab13dd380c27183fb9cec5d731eacc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab13dd380c27183fb9cec5d731eacc9">&#9670;&nbsp;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00686">686</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&nbsp;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01351">1351</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="a8bb36f5e419e824d5003b53b922eebfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb36f5e419e824d5003b53b922eebfe">&#9670;&nbsp;</a></span>populateConvVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for vectorization of all ConvN-D ops. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00633">633</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a8893ac7d0de6eaaf5a82120404825665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8893ac7d0de6eaaf5a82120404825665">&#9670;&nbsp;</a></span>populateLinalgBufferizePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgBufferizePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns to bufferize linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00352">352</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00153">finalizeBufferAllocation()</a>.</p>

</div>
</div>
<a id="a77fe6c6c47d52860111960fc07d817ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fe6c6c47d52860111960fc07d817ed">&#9670;&nbsp;</a></span>populateLinalgConvGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgConvGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">linalg::LinalgMarker</a>&#160;</td>
          <td class="paramname"><em>marker</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns to convert linalg.conv ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00166">166</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Generalization_8cpp_source.html#l00033">createGenericOpFromNamedOp()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a64b26f2e4297d8349803cab2e1d9bf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b26f2e4297d8349803cab2e1d9bf32">&#9670;&nbsp;</a></span>populateLinalgNamedOpsGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">linalg::LinalgMarker</a>&#160;</td>
          <td class="paramname"><em>marker</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg generalization patterns. </p>
<p>Populates <code>patterns</code> with patterns to convert spec-generated named ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00172">172</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Generalization_8cpp_source.html#l00033">createGenericOpFromNamedOp()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a3476cd1399d5bcda0827220ea9c7f105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3476cd1399d5bcda0827220ea9c7f105">&#9670;&nbsp;</a></span>populateLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00561">561</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00555">getLinalgTilingCanonicalizationPatterns()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00379">mlir::linalg::LinalgTilingOptions::setDistributionOptions()</a>.</p>

</div>
</div>
<a id="a3da433fb329e5403a3aca8f2aff90201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da433fb329e5403a3aca8f2aff90201">&#9670;&nbsp;</a></span>populateLinalgToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to Standard. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00187">187</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00579">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02698">mlir::applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="ac77b24b8390edbdd1026ef6a2433534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b24b8390edbdd1026ef6a2433534c">&#9670;&nbsp;</a></span>populateSparsificationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateSparsificationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1SparsificationOptions.html">SparsificationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1linalg_1_1SparsificationOptions.html">SparsificationOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up sparsification rewriting rules with the given options. </p>
<p>Populates the given patterns list with rewriting rules required for the sparsification of linear algebra operations.</p>

<p class="definition">Definition at line <a class="el" href="Sparsification_8cpp_source.html#l01053">1053</a> of file <a class="el" href="Sparsification_8cpp_source.html">Sparsification.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>.</p>

</div>
</div>
<a id="a9d1995fb7a1d6a3a28e7607df02c8a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1995fb7a1d6a3a28e7607df02c8a7e">&#9670;&nbsp;</a></span>promoteSubviewAsNewBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt; mlir::linalg::promoteSubviewAsNewBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubViewOp&#160;</td>
          <td class="paramname"><em>subView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a6225c1f06228d3cabaf5367e60659b80">AllocBufferCallbackFn</a>&#160;</td>
          <td class="paramname"><em>allocationFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *&#160;</td>
          <td class="paramname"><em>folder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00231">231</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00050">extractSmallestConstantBoundingSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>.</p>

</div>
</div>
<a id="aea396843a4c8fce5aa96c6d49a483661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea396843a4c8fce5aa96c6d49a483661">&#9670;&nbsp;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *&#160;</td>
          <td class="paramname"><em>folder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it. Infers statically sized buffers from subViews unless <code>dynamicBuffers</code> is true.</li>
</ol>
<p>Returns the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00387">387</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00367">promoteSubviewsPrecondition()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00197">mlir::linalg::LinalgPromotionOptions::setDynamicBuffers()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00209">mlir::linalg::LinalgPromotionOptions::setUseAlloca()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00275">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&nbsp;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Promotion transformation enqueues a particular stage-1 pattern for Promote&lt;LinalgOpType&gt;with the appr...">Promote</a> std.subviews feeding linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00367">367</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00167">mlir::linalg::LinalgPromotionOptions::operandsToPromote</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00275">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00387">promoteSubViews()</a>.</p>

</div>
</div>
<a id="a0d0dffca46cdba77603c5b6b113d5c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0dffca46cdba77603c5b6b113d5c7a">&#9670;&nbsp;</a></span>tileAndFuseLinalgOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt; mlir::linalg::tileAndFuseLinalgOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>tilingOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00897">897</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00367">mlir::linalg::LinalgTilingOptions::loopType</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00163">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab2efdb9223f206f2d1f8f8ee6b27564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2efdb9223f206f2d1f8f8ee6b27564f">&#9670;&nbsp;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs standalone tiling of a single LinalgOp by <code>tileSizes</code>. </p>
<p>and permute the loop nest according to <code>interchangeVector</code> The permutation is expressed as a list of integers that specify the new ordering of the loop nest. The length of <code>interchangeVector</code> must be equal to the length of <code>tileSizes</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>Returns a struct containing the tiled loops in the specified order and the cloned op if successful, llvm::None otherwise.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed by <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>tileSizes.size()</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00499">499</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00688">mlir::Identifier::get()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00367">mlir::linalg::LinalgTilingOptions::loopType</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00163">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00119">mlir::linalg::LinalgBaseTilingPattern::matchAndRewriteBase()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00794">tileRootOperation()</a>.</p>

</div>
</div>
<a id="adde2ef42e2887221b469aa879f8e892a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde2ef42e2887221b469aa879f8e892a">&#9670;&nbsp;</a></span>updateBoundsForCyclicDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> mlir::linalg::updateBoundsForCyclicDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>procId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>nprocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00182">182</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00314">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a3fae5d2ec66e658cbabd89ea5c15a5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fae5d2ec66e658cbabd89ea5c15a5ef">&#9670;&nbsp;</a></span>vectorizeLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::vectorizeLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Linalg op with fully static shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00294">294</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00037">DEBUG_TYPE</a>, <a class="el" href="Vectorization_8cpp_source.html#l00122">extractVectorTypeFromScalarView()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00069">isContraction()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00101">isElementwise()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00129">transferReadVector()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00139">transferWriteVector()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00270">vectorizeElementwise()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00277">vectorizeLinalgOpPrecondition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00302">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a434bd78a651f6a42d01090db72bc039c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434bd78a651f6a42d01090db72bc039c">&#9670;&nbsp;</a></span>vectorizeLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a linalg.generic into a suitable vector.contraction op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00277">277</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00300">mlir::ShapedType::hasStaticShape()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00069">isContraction()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00101">isElementwise()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00302">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00294">vectorizeLinalgOp()</a>.</p>

</div>
</div>
<a id="ab5dd029acdda95eeb6887d0e169bcbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dd029acdda95eeb6887d0e169bcbb5">&#9670;&nbsp;</a></span>weightedPoolingInputIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PoolingOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::weightedPoolingInputIndex </td>
          <td>(</td>
          <td class="paramtype">PoolingOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>windowDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the indexing expressions for a ConvOp/PoolingOp <code>op</code>. </p>
<p>Returns the vector of AffineMaps representing: <code>stride[i] * outputDims[i] + dilation[i] * windowDims[i] - pad_low[i]</code> </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01362">1362</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 16 2020 12:50:41 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
