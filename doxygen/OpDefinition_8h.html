<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/IR/OpDefinition.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_84ef7c054b4edc3447cfba80cee80f65.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpDefinition.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Operation_8h_source.html">mlir/IR/Operation.h</a>&quot;</code><br />
<code>#include &quot;llvm/Support/PointerLikeTypeTraits.h&quot;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for OpDefinition.h:</div>
<div class="dyncontent">
<div class="center"><img src="OpDefinition_8h__incl.png" border="0" usemap="#include_2mlir_2IR_2OpDefinition_8h" alt=""/></div>
<map name="include_2mlir_2IR_2OpDefinition_8h" id="include_2mlir_2IR_2OpDefinition_8h">
<area shape="rect" id="node2" href="Operation_8h.html" title="mlir/IR/Operation.h" alt="" coords="449,80,581,107"/>
<area shape="rect" id="node3" href="Block_8h.html" title="mlir/IR/Block.h" alt="" coords="37,229,147,256"/>
<area shape="rect" id="node38" href="IR_2BuiltinAttributes_8h.html" title="mlir/IR/BuiltinAttributes.h" alt="" coords="431,155,599,181"/>
<area shape="rect" id="node42" href="IR_2Diagnostics_8h.html" title="mlir/IR/Diagnostics.h" alt="" coords="639,453,785,480"/>
<area shape="rect" id="node43" href="OperationSupport_8h.html" title="mlir/IR/OperationSupport.h" alt="" coords="1419,229,1597,256"/>
<area shape="rect" id="node49" href="IR_2Region_8h.html" title="mlir/IR/Region.h" alt="" coords="67,155,184,181"/>
<area shape="rect" id="node4" href="BlockSupport_8h.html" title="mlir/IR/BlockSupport.h" alt="" coords="817,304,972,331"/>
<area shape="rect" id="node36" href="Visitors_8h.html" title="mlir/IR/Visitors.h" alt="" coords="123,827,243,853"/>
<area shape="rect" id="node5" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="1289,379,1399,405"/>
<area shape="rect" id="node6" href="Types_8h.html" title="mlir/IR/Types.h" alt="" coords="1635,603,1747,629"/>
<area shape="rect" id="node9" href="LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="439,983,580,1010"/>
<area shape="rect" id="node27" href="UseDefLists_8h.html" title="mlir/IR/UseDefLists.h" alt="" coords="1235,453,1384,480"/>
<area shape="rect" id="node7" href="TypeSupport_8h.html" title="mlir/IR/TypeSupport.h" alt="" coords="1077,677,1227,704"/>
<area shape="rect" id="node8" href="MLIRContext_8h.html" title="mlir/IR/MLIRContext.h" alt="" coords="1179,752,1333,779"/>
<area shape="rect" id="node18" href="StorageUniquerSupport_8h.html" title="mlir/IR/StorageUniquerSupport.h" alt="" coords="944,752,1155,779"/>
<area shape="rect" id="node12" href="TypeID_8h.html" title="mlir/Support/TypeID.h" alt="" coords="1138,901,1289,928"/>
<area shape="rect" id="node19" href="InterfaceSupport_8h.html" title="mlir/Support/InterfaceSupport.h" alt="" coords="1459,827,1661,853"/>
<area shape="rect" id="node22" href="LogicalResult_8h.html" title="mlir/Support/LogicalResult.h" alt="" coords="235,901,421,928"/>
<area shape="rect" id="node24" href="StorageUniquer_8h.html" title="mlir/Support/StorageUniquer.h" alt="" coords="667,827,864,853"/>
<area shape="rect" id="node28" href="Location_8h.html" title="mlir/IR/Location.h" alt="" coords="1064,528,1189,555"/>
<area shape="rect" id="node29" href="Attributes_8h.html" title="mlir/IR/Attributes.h" alt="" coords="845,603,977,629"/>
<area shape="rect" id="node30" href="AttributeSupport_8h.html" title="mlir/IR/AttributeSupport.h" alt="" coords="825,677,996,704"/>
<area shape="rect" id="node44" href="Identifier_8h.html" title="mlir/IR/Identifier.h" alt="" coords="2041,901,2167,928"/>
<area shape="rect" id="node46" href="TypeRange_8h.html" title="mlir/IR/TypeRange.h" alt="" coords="1149,304,1291,331"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="OpDefinition_8h__dep__incl.png" border="0" usemap="#include_2mlir_2IR_2OpDefinition_8hdep" alt=""/></div>
<map name="include_2mlir_2IR_2OpDefinition_8hdep" id="include_2mlir_2IR_2OpDefinition_8hdep">
<area shape="rect" id="node2" href="AffineStructures_8h.html" title="include/mlir/Analysis\l/AffineStructures.h" alt="" coords="395,80,537,121"/>
<area shape="rect" id="node10" href="AffineMemoryOpInterfaces_8h.html" title="include/mlir/Dialect\l/Affine/IR/AffineMemoryOpInterfaces.h" alt="" coords="2159,80,2408,121"/>
<area shape="rect" id="node11" href="AffineOps_8h.html" title="include/mlir/Dialect\l/Affine/IR/AffineOps.h" alt="" coords="2185,169,2336,211"/>
<area shape="rect" id="node12" href="ArmNeonDialect_8h.html" title="include/mlir/Dialect\l/ArmNeon/ArmNeonDialect.h" alt="" coords="1369,169,1561,211"/>
<area shape="rect" id="node13" href="ArmSVEDialect_8h.html" title="include/mlir/Dialect\l/ArmSVE/ArmSVEDialect.h" alt="" coords="1774,169,1958,211"/>
<area shape="rect" id="node14" href="Async_8h.html" title="include/mlir/Dialect\l/Async/IR/Async.h" alt="" coords="2513,169,2646,211"/>
<area shape="rect" id="node15" href="AVX512Dialect_8h.html" title="include/mlir/Dialect\l/AVX512/AVX512Dialect.h" alt="" coords="1982,169,2161,211"/>
<area shape="rect" id="node16" href="GPUDialect_8h.html" title="include/mlir/Dialect\l/GPU/GPUDialect.h" alt="" coords="1153,169,1293,211"/>
<area shape="rect" id="node17" href="DependenceAnalysis_8h.html" title="include/mlir/Dialect\l/Linalg/Analysis/Dependence\lAnalysis.h" alt="" coords="3885,259,4076,315"/>
<area shape="rect" id="node18" href="LinalgOps_8h.html" title="include/mlir/Dialect\l/Linalg/IR/LinalgOps.h" alt="" coords="3905,169,4056,211"/>
<area shape="rect" id="node19" href="LinalgTraits_8h.html" title="include/mlir/Dialect\l/Linalg/IR/LinalgTraits.h" alt="" coords="3859,80,4019,121"/>
<area shape="rect" id="node20" href="LLVMArmNeonDialect_8h.html" title="include/mlir/Dialect\l/LLVMIR/LLVMArmNeonDialect.h" alt="" coords="4321,80,4539,121"/>
<area shape="rect" id="node21" href="LLVMArmSVEDialect_8h.html" title="include/mlir/Dialect\l/LLVMIR/LLVMArmSVEDialect.h" alt="" coords="4564,80,4779,121"/>
<area shape="rect" id="node22" href="LLVMAVX512Dialect_8h.html" title="include/mlir/Dialect\l/LLVMIR/LLVMAVX512Dialect.h" alt="" coords="4803,80,5015,121"/>
<area shape="rect" id="node23" href="LLVMDialect_8h.html" title="include/mlir/Dialect\l/LLVMIR/LLVMDialect.h" alt="" coords="1585,169,1749,211"/>
<area shape="rect" id="node24" href="NVVMDialect_8h.html" title="include/mlir/Dialect\l/LLVMIR/NVVMDialect.h" alt="" coords="1583,266,1752,307"/>
<area shape="rect" id="node25" href="ROCDLDialect_8h.html" title="include/mlir/Dialect\l/LLVMIR/ROCDLDialect.h" alt="" coords="2516,266,2693,307"/>
<area shape="rect" id="node26" href="OpenACC_8h.html" title="include/mlir/Dialect\l/OpenACC/OpenACC.h" alt="" coords="5039,80,5200,121"/>
<area shape="rect" id="node27" href="OpenMPDialect_8h.html" title="include/mlir/Dialect\l/OpenMP/OpenMPDialect.h" alt="" coords="2670,169,2854,211"/>
<area shape="rect" id="node28" href="QuantOps_8h.html" title="include/mlir/Dialect\l/Quant/QuantOps.h" alt="" coords="3188,169,3323,211"/>
<area shape="rect" id="node29" href="QuantTypes_8h.html" title="include/mlir/Dialect\l/Quant/QuantTypes.h" alt="" coords="3633,169,3779,211"/>
<area shape="rect" id="node30" href="SCF_8h.html" title="include/mlir/Dialect\l/SCF/SCF.h" alt="" coords="2929,169,3062,211"/>
<area shape="rect" id="node31" href="ParallelLoopFusion_8cpp.html" title="lib/Dialect/SCF/Transforms\l/ParallelLoopFusion.cpp" alt="" coords="3270,266,3451,307"/>
<area shape="rect" id="node32" href="Shape_8h.html" title="include/mlir/Dialect\l/Shape/IR/Shape.h" alt="" coords="2358,266,2491,307"/>
<area shape="rect" id="node33" href="ParserUtils_8h.html" title="include/mlir/Dialect\l/SPIRV/ParserUtils.h" alt="" coords="769,169,915,211"/>
<area shape="rect" id="node34" href="Tensor_8h.html" title="include/mlir/Dialect\l/Tensor/IR/Tensor.h" alt="" coords="939,169,1078,211"/>
<area shape="rect" id="node35" href="Traits_8h.html" title="include/mlir/Dialect\l/Traits.h" alt="" coords="5225,80,5358,121"/>
<area shape="rect" id="node36" href="VectorOps_8h.html" title="include/mlir/Dialect\l/Vector/VectorOps.h" alt="" coords="4131,169,4273,211"/>
<area shape="rect" id="node37" href="ControlFlowInterfaces_8h.html" title="include/mlir/Interfaces\l/ControlFlowInterfaces.h" alt="" coords="2670,80,2835,121"/>
<area shape="rect" id="node38" href="CopyOpInterface_8h.html" title="include/mlir/Interfaces\l/CopyOpInterface.h" alt="" coords="3633,80,3784,121"/>
<area shape="rect" id="node39" href="DerivedAttributeOpInterface_8h.html" title="include/mlir/Interfaces\l/DerivedAttributeOpInterface.h" alt="" coords="5383,80,5581,121"/>
<area shape="rect" id="node40" href="InferTypeOpInterface_8h.html" title="include/mlir/Interfaces\l/InferTypeOpInterface.h" alt="" coords="3449,169,3609,211"/>
<area shape="rect" id="node41" href="LoopLikeInterface_8h.html" title="include/mlir/Interfaces\l/LoopLikeInterface.h" alt="" coords="2860,80,3011,121"/>
<area shape="rect" id="node42" href="SideEffectInterfaces_8h.html" title="include/mlir/Interfaces\l/SideEffectInterfaces.h" alt="" coords="2432,80,2588,121"/>
<area shape="rect" id="node43" href="VectorInterfaces_8h.html" title="include/mlir/Interfaces\l/VectorInterfaces.h" alt="" coords="4145,80,4296,121"/>
<area shape="rect" id="node44" href="IR_2Builders_8h.html" title="include/mlir/IR/Builders.h" alt="" coords="3238,87,3406,114"/>
<area shape="rect" id="node45" href="FunctionSupport_8h.html" title="include/mlir/IR/Function\lSupport.h" alt="" coords="1345,80,1505,121"/>
<area shape="rect" id="node46" href="Matchers_8h.html" title="include/mlir/IR/Matchers.h" alt="" coords="5605,87,5780,114"/>
<area shape="rect" id="node47" href="OpImplementation_8h.html" title="include/mlir/IR/OpImplementation.h" alt="" coords="1094,87,1321,114"/>
<area shape="rect" id="node48" href="RegionKindInterface_8h.html" title="include/mlir/IR/RegionKind\lInterface.h" alt="" coords="5804,80,5981,121"/>
<area shape="rect" id="node49" href="SymbolTable_8h.html" title="include/mlir/IR/SymbolTable.h" alt="" coords="1579,87,1777,114"/>
<area shape="rect" id="node50" href="OperationSupport_8cpp.html" title="lib/IR/OperationSupport.cpp" alt="" coords="6005,87,6188,114"/>
<area shape="rect" id="node3" href="Simplex_8h.html" title="include/mlir/Analysis\l/Presburger/Simplex.h" alt="" coords="5,169,156,211"/>
<area shape="rect" id="node4" href="AffineStructures_8cpp.html" title="lib/Analysis/AffineStructures.cpp" alt="" coords="216,273,428,300"/>
<area shape="rect" id="node5" href="PresburgerSet_8h.html" title="include/mlir/Analysis\l/PresburgerSet.h" alt="" coords="180,169,323,211"/>
<area shape="rect" id="node6" href="Analysis_2Utils_8h.html" title="include/mlir/Analysis\l/Utils.h" alt="" coords="449,169,592,211"/>
<area shape="rect" id="node7" href="AffineLoopInvariantCodeMotion_8cpp.html" title="lib/Dialect/Affine\l/Transforms/AffineLoopInvariant\lCodeMotion.cpp" alt="" coords="830,259,1038,315"/>
<area shape="rect" id="node8" href="AffineParallelize_8cpp.html" title="lib/Dialect/Affine\l/Transforms/AffineParallelize.cpp" alt="" coords="452,266,667,307"/>
<area shape="rect" id="node9" href="LoopAnalysis_8cpp.html" title="lib/Analysis/LoopAnalysis.cpp" alt="" coords="1263,273,1459,300"/>
</map>
</div>
</div>
<p><a href="OpDefinition_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">mlir::OpTrait::OneResult&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParseResult.html">mlir::ParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents success/failure for operation parsing.  <a href="classmlir_1_1ParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">mlir::OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for <a class="el" href="classmlir_1_1ParseResult.html" title="This class represents success/failure for operation parsing. ">ParseResult</a>.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">mlir::OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html">mlir::OpTrait::detail::MultiOperandTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple operands.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroOperands.html">mlir::OpTrait::ZeroOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have no SSA operand.  <a href="classmlir_1_1OpTrait_1_1ZeroOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneOperand.html">mlir::OpTrait::OneOperand&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have exactly one SSA operand.  <a href="classmlir_1_1OpTrait_1_1OneOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands.html">mlir::OpTrait::NOperands&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1NOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands_1_1Impl.html">mlir::OpTrait::NOperands&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html">mlir::OpTrait::AtLeastNOperands&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a at least a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands_1_1Impl.html">mlir::OpTrait::AtLeastNOperands&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicOperands.html">mlir::OpTrait::VariadicOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of SSA operands.  <a href="classmlir_1_1OpTrait_1_1VariadicOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroRegion.html">mlir::OpTrait::ZeroRegion&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero regions.  <a href="classmlir_1_1OpTrait_1_1ZeroRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiRegionTraitBase.html">mlir::OpTrait::detail::MultiRegionTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple regions.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiRegionTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneRegion.html">mlir::OpTrait::OneRegion&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single region.  <a href="classmlir_1_1OpTrait_1_1OneRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions.html">mlir::OpTrait::NRegions&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1NRegions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions_1_1Impl.html">mlir::OpTrait::NRegions&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html">mlir::OpTrait::AtLeastNRegions&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions_1_1Impl.html">mlir::OpTrait::AtLeastNRegions&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicRegions.html">mlir::OpTrait::VariadicRegions&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of regions.  <a href="classmlir_1_1OpTrait_1_1VariadicRegions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroResult.html">mlir::OpTrait::ZeroResult&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have zero results.  <a href="classmlir_1_1OpTrait_1_1ZeroResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiResultTraitBase.html">mlir::OpTrait::detail::MultiResultTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple results.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiResultTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">mlir::OpTrait::OneResult&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults.html">mlir::OpTrait::NResults&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of results.  <a href="classmlir_1_1OpTrait_1_1NResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults_1_1Impl.html">mlir::OpTrait::NResults&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults.html">mlir::OpTrait::AtLeastNResults&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have at least a specified number of results.  <a href="classmlir_1_1OpTrait_1_1AtLeastNResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults_1_1Impl.html">mlir::OpTrait::AtLeastNResults&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicResults.html">mlir::OpTrait::VariadicResults&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of results.  <a href="classmlir_1_1OpTrait_1_1VariadicResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsTerminator.html">mlir::OpTrait::IsTerminator&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be terminators.  <a href="classmlir_1_1OpTrait_1_1IsTerminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroSuccessor.html">mlir::OpTrait::ZeroSuccessor&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero successors.  <a href="classmlir_1_1OpTrait_1_1ZeroSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiSuccessorTraitBase.html">mlir::OpTrait::detail::MultiSuccessorTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple successors.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiSuccessorTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneSuccessor.html">mlir::OpTrait::OneSuccessor&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single successor.  <a href="classmlir_1_1OpTrait_1_1OneSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors.html">mlir::OpTrait::NSuccessors&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1NSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors_1_1Impl.html">mlir::OpTrait::NSuccessors&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html">mlir::OpTrait::AtLeastNSuccessors&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors_1_1Impl.html">mlir::OpTrait::AtLeastNSuccessors&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html">mlir::OpTrait::VariadicSuccessors&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of successors.  <a href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block that must terminate with <code>TerminatorOpType</code>.  <a href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator_1_1Impl.html">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsShape.html">mlir::OpTrait::SameOperandsShape&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand shape: all operands are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html">mlir::OpTrait::SameOperandsAndResultShape&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result shape: both are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html">mlir::OpTrait::SameOperandsElementType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html">mlir::OpTrait::SameOperandsAndResultElementType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html">mlir::OpTrait::SameOperandsAndResultType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result type.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html">mlir::OpTrait::ResultsAreBoolLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a boolean type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html">mlir::OpTrait::ResultsAreFloatLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a floating point type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html">mlir::OpTrait::ResultsAreSignlessIntegerLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsCommutative.html">mlir::OpTrait::IsCommutative&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is commutative.  <a href="classmlir_1_1OpTrait_1_1IsCommutative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsInvolution.html">mlir::OpTrait::IsInvolution&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is an involution.  <a href="classmlir_1_1OpTrait_1_1IsInvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIdempotent.html">mlir::OpTrait::IsIdempotent&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is idempotent.  <a href="classmlir_1_1OpTrait_1_1IsIdempotent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html">mlir::OpTrait::OperandsAreFloatLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a float type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html">mlir::OpTrait::OperandsAreSignlessIntegerLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameTypeOperands.html">mlir::OpTrait::SameTypeOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have the same type.  <a href="classmlir_1_1OpTrait_1_1SameTypeOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ConstantLike.html">mlir::OpTrait::ConstantLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for a sub-set of ops that are known to be constant-like.  <a href="classmlir_1_1OpTrait_1_1ConstantLike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be isolated from above.  <a href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AffineScope.html">mlir::OpTrait::AffineScope&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that defines a new scope for polyhedral optimization purposes.  <a href="classmlir_1_1OpTrait_1_1AffineScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html">mlir::OpTrait::AutomaticAllocationScope&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that define a new scope for automatic allocations, i.e., allocations that are freed when control is transferred back from the operation's region.  <a href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1HasParent.html">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a verifier for ops that are expecting their parent to be one of the given parent ops.  <a href="structmlir_1_1OpTrait_1_1HasParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1HasParent_1_1Impl.html">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html">mlir::OpTrait::AttrSizedOperandSegments&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for operations that have an attribute specifying operand segments.  <a href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html">mlir::OpTrait::AttrSizedResultSegments&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html" title="A trait for operations that have an attribute specifying operand segments. ">AttrSizedOperandSegments</a> but used for results.  <a href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1NoRegionArguments.html">mlir::OpTrait::NoRegionArguments&lt; ConcrentType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait provides a verifier for ops that are expecting their regions to not have any arguments.  <a href="structmlir_1_1OpTrait_1_1NoRegionArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1MemRefsNormalizable.html">mlir::OpTrait::MemRefsNormalizable&lt; ConcrentType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html">mlir::OpTrait::ElementwiseMappable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags scalar ops that also can be applied to vectors/tensors, with their semantics on vectors/tensors being elementwise application.  <a href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; ConcreteType, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">mlir::OpInterface&lt; ConcreteType, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">mlir::OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">mlir::impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html">mlir::OpTrait::impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1detail.html">mlir::OpTrait::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1op__definition__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">mlir::op_definition_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab8e1b916f30dd4d7d9ba1977d36dc013">mlir::op_definition_impl::has_single_result_fold_trait</a> = decltype(T::foldTrait(std::declval&lt; Operation * &gt;(), std::declval&lt; ArrayRef&lt; Attribute &gt; &gt;()))</td></tr>
<tr class="memdesc:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a 'foldTrait' method for single result operations.  <a href="namespacemlir_1_1op__definition__impl.html#ab8e1b916f30dd4d7d9ba1977d36dc013">More...</a><br /></td></tr>
<tr class="separator:ab8e1b916f30dd4d7d9ba1977d36dc013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddad3225ec31fadb0caf5a7f18c8919"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ddad3225ec31fadb0caf5a7f18c8919"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a6ddad3225ec31fadb0caf5a7f18c8919">mlir::op_definition_impl::detect_has_single_result_fold_trait</a> = llvm::is_detected&lt; has_single_result_fold_trait, T &gt;</td></tr>
<tr class="separator:a6ddad3225ec31fadb0caf5a7f18c8919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b98e8eb901a799fde18726456effcc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a52b98e8eb901a799fde18726456effcc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a52b98e8eb901a799fde18726456effcc">mlir::op_definition_impl::has_fold_trait</a> = decltype(T::foldTrait(std::declval&lt; Operation * &gt;(), std::declval&lt; ArrayRef&lt; Attribute &gt; &gt;(), std::declval&lt; SmallVectorImpl&lt; OpFoldResult &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a52b98e8eb901a799fde18726456effcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a general 'foldTrait' method.  <a href="namespacemlir_1_1op__definition__impl.html#a52b98e8eb901a799fde18726456effcc">More...</a><br /></td></tr>
<tr class="separator:a52b98e8eb901a799fde18726456effcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f18a84fcbbcd4be33c2ef7f85067b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a141f18a84fcbbcd4be33c2ef7f85067b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a141f18a84fcbbcd4be33c2ef7f85067b">mlir::op_definition_impl::detect_has_fold_trait</a> = llvm::is_detected&lt; has_fold_trait, T &gt;</td></tr>
<tr class="separator:a141f18a84fcbbcd4be33c2ef7f85067b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd51a531c501776224e11ba1f0cf6b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cd51a531c501776224e11ba1f0cf6b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a3cd51a531c501776224e11ba1f0cf6b7">mlir::op_definition_impl::detect_has_any_fold_trait</a> = std::conditional_t&lt; bool(detect_has_fold_trait&lt; T &gt;::value), detect_has_fold_trait&lt; T &gt;, detect_has_single_result_fold_trait&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a3cd51a531c501776224e11ba1f0cf6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides any <code>foldTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a3cd51a531c501776224e11ba1f0cf6b7">More...</a><br /></td></tr>
<tr class="separator:a3cd51a531c501776224e11ba1f0cf6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbf446126af9171908237d8c8a8c309"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a3dbf446126af9171908237d8c8a8c309"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a3dbf446126af9171908237d8c8a8c309">mlir::op_definition_impl::has_get_trait_properties</a> = decltype(T::getTraitProperties())</td></tr>
<tr class="memdesc:a3dbf446126af9171908237d8c8a8c309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <code>getTraitProperties</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a3dbf446126af9171908237d8c8a8c309">More...</a><br /></td></tr>
<tr class="separator:a3dbf446126af9171908237d8c8a8c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f57eef6e90ef0c0a6806900c4edaf9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f57eef6e90ef0c0a6806900c4edaf9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a9f57eef6e90ef0c0a6806900c4edaf9f">mlir::op_definition_impl::detect_has_get_trait_properties</a> = llvm::is_detected&lt; has_get_trait_properties, T &gt;</td></tr>
<tr class="separator:a9f57eef6e90ef0c0a6806900c4edaf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb84c922f7efa8ee20bd2165b97733"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a48fb84c922f7efa8ee20bd2165b97733"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a48fb84c922f7efa8ee20bd2165b97733">mlir::op_definition_impl::has_verify_trait</a> = decltype(T::verifyTrait(std::declval&lt; Operation * &gt;()))</td></tr>
<tr class="memdesc:a48fb84c922f7efa8ee20bd2165b97733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <code>verifyTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a48fb84c922f7efa8ee20bd2165b97733">More...</a><br /></td></tr>
<tr class="separator:a48fb84c922f7efa8ee20bd2165b97733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1984f3eb75bc0cc029899eaeb9b1801a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1984f3eb75bc0cc029899eaeb9b1801a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a1984f3eb75bc0cc029899eaeb9b1801a">mlir::op_definition_impl::detect_has_verify_trait</a> = llvm::is_detected&lt; has_verify_trait, T &gt;</td></tr>
<tr class="separator:a1984f3eb75bc0cc029899eaeb9b1801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e7451c7364716df0ac50255d1bb0dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">mlir::impl::ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:a8e7451c7364716df0ac50255d1bb0dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an operation, generated by <code>buildTerminatorOp</code>, at the end of the region's only block if it does not have a terminator already.  <a href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">More...</a><br /></td></tr>
<tr class="separator:a8e7451c7364716df0ac50255d1bb0dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89ade716be6ba0ebae6e192aa722859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">mlir::impl::ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:ad89ade716be6ba0ebae6e192aa722859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simple <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> and forward to the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> version of this function.  <a href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">More...</a><br /></td></tr>
<tr class="separator:ad89ade716be6ba0ebae6e192aa722859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">mlir::operator==</a> (OpState lhs, OpState rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">mlir::operator!=</a> (OpState lhs, OpState rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310fba6c1ad548d4884cf850b4b7df08"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a310fba6c1ad548d4884cf850b4b7df08">mlir::operator&lt;&lt;</a> (raw_ostream &amp;os, OpState &amp;op)</td></tr>
<tr class="memdesc:a310fba6c1ad548d4884cf850b4b7df08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="namespacemlir.html#a310fba6c1ad548d4884cf850b4b7df08">More...</a><br /></td></tr>
<tr class="separator:a310fba6c1ad548d4884cf850b4b7df08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0132989f6240955f0653f9e2f544593e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a0132989f6240955f0653f9e2f544593e">mlir::OpTrait::impl::foldIdempotent</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a0132989f6240955f0653f9e2f544593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8adca9caae669acd6c6100fa24fe2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ad8adca9caae669acd6c6100fa24fe2ca">mlir::OpTrait::impl::foldInvolution</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ad8adca9caae669acd6c6100fa24fe2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8e54e8c1d63dcd42fb7b3035d0cdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a8dc8e54e8c1d63dcd42fb7b3035d0cdf">mlir::OpTrait::impl::verifyZeroOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a8dc8e54e8c1d63dcd42fb7b3035d0cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa809f4f4d8b09d82d6a8fd16dd2c9710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#aa809f4f4d8b09d82d6a8fd16dd2c9710">mlir::OpTrait::impl::verifyOneOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aa809f4f4d8b09d82d6a8fd16dd2c9710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0d9ddc91b449aa789d17f9586507fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a1e0d9ddc91b449aa789d17f9586507fe">mlir::OpTrait::impl::verifyNOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:a1e0d9ddc91b449aa789d17f9586507fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a23d65257edee446fa4d25c6d53bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a115a23d65257edee446fa4d25c6d53bf">mlir::OpTrait::impl::verifyIsIdempotent</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a115a23d65257edee446fa4d25c6d53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d96b2cde016d241b493b4ad3a97b1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a2d96b2cde016d241b493b4ad3a97b1e8">mlir::OpTrait::impl::verifyIsInvolution</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a2d96b2cde016d241b493b4ad3a97b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889058045dff9baa6b2a4a9950abbc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a889058045dff9baa6b2a4a9950abbc7a">mlir::OpTrait::impl::verifyAtLeastNOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:a889058045dff9baa6b2a4a9950abbc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cda488cf33c7043eb3a386c3cd4231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a34cda488cf33c7043eb3a386c3cd4231">mlir::OpTrait::impl::verifyOperandsAreFloatLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a34cda488cf33c7043eb3a386c3cd4231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd39e6ccba62558b270c9dad614273a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a1bd39e6ccba62558b270c9dad614273a">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a1bd39e6ccba62558b270c9dad614273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe4f6aa15d39476a2c01e85e7d52021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#aefe4f6aa15d39476a2c01e85e7d52021">mlir::OpTrait::impl::verifySameTypeOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aefe4f6aa15d39476a2c01e85e7d52021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d0b57f4f04dc210475a73d9db6b7d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a54d0b57f4f04dc210475a73d9db6b7d3">mlir::OpTrait::impl::verifyZeroRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a54d0b57f4f04dc210475a73d9db6b7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90522054e6b01d158e20f5a94e4b1aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a90522054e6b01d158e20f5a94e4b1aee">mlir::OpTrait::impl::verifyOneRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a90522054e6b01d158e20f5a94e4b1aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e80ada4c0550c82e88f4e4d840f4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ae3e80ada4c0550c82e88f4e4d840f4ad">mlir::OpTrait::impl::verifyNRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numRegions)</td></tr>
<tr class="separator:ae3e80ada4c0550c82e88f4e4d840f4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53730de6badc603ad6f726118d16f287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a53730de6badc603ad6f726118d16f287">mlir::OpTrait::impl::verifyAtLeastNRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numRegions)</td></tr>
<tr class="separator:a53730de6badc603ad6f726118d16f287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edb1eef6f45f7ecb9ce52f5748ba942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a3edb1eef6f45f7ecb9ce52f5748ba942">mlir::OpTrait::impl::verifyZeroResult</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a3edb1eef6f45f7ecb9ce52f5748ba942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95e50903d49322f2b78695b60b6bcc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ae95e50903d49322f2b78695b60b6bcc1">mlir::OpTrait::impl::verifyOneResult</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ae95e50903d49322f2b78695b60b6bcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d5eefac26d790469de86a7f077421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#add6d5eefac26d790469de86a7f077421">mlir::OpTrait::impl::verifyNResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:add6d5eefac26d790469de86a7f077421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110f9468129a20d2293ae53d7fe2ef0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a110f9468129a20d2293ae53d7fe2ef0a">mlir::OpTrait::impl::verifyAtLeastNResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="separator:a110f9468129a20d2293ae53d7fe2ef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e92618f861bedecfef4ad880f180081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a5e92618f861bedecfef4ad880f180081">mlir::OpTrait::impl::verifySameOperandsShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a5e92618f861bedecfef4ad880f180081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab88926993882bfc40c836a88e5fe66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#afab88926993882bfc40c836a88e5fe66">mlir::OpTrait::impl::verifySameOperandsAndResultShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:afab88926993882bfc40c836a88e5fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82438cfd273eb4a921e6e4bf7491daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ac82438cfd273eb4a921e6e4bf7491daa">mlir::OpTrait::impl::verifySameOperandsElementType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ac82438cfd273eb4a921e6e4bf7491daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a11e847e87cb0d535a2d211df24088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ad3a11e847e87cb0d535a2d211df24088">mlir::OpTrait::impl::verifySameOperandsAndResultElementType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ad3a11e847e87cb0d535a2d211df24088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e846953be56c5cd49c049e25d293d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a5e846953be56c5cd49c049e25d293d92">mlir::OpTrait::impl::verifySameOperandsAndResultType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a5e846953be56c5cd49c049e25d293d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d0fe5f6a3c7e9dcbef8c906538ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#add6d0fe5f6a3c7e9dcbef8c906538ecf">mlir::OpTrait::impl::verifyResultsAreBoolLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:add6d0fe5f6a3c7e9dcbef8c906538ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078673dba11a98a41584775609a09e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a078673dba11a98a41584775609a09e85">mlir::OpTrait::impl::verifyResultsAreFloatLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a078673dba11a98a41584775609a09e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3ceabf6cb31385e6c2f43371b614d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a2d3ceabf6cb31385e6c2f43371b614d3">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a2d3ceabf6cb31385e6c2f43371b614d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4b2825599a0e6a222707b3b6b53f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a7d4b2825599a0e6a222707b3b6b53f75">mlir::OpTrait::impl::verifyIsTerminator</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a7d4b2825599a0e6a222707b3b6b53f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2711dea34b2a506e453a07200e93b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a09b2711dea34b2a506e453a07200e93b">mlir::OpTrait::impl::verifyZeroSuccessor</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a09b2711dea34b2a506e453a07200e93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac938fc6e2ff3dc37694950498ae9dba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ac938fc6e2ff3dc37694950498ae9dba6">mlir::OpTrait::impl::verifyOneSuccessor</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ac938fc6e2ff3dc37694950498ae9dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403585b9eec4de7bddd7f41981c34b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a4403585b9eec4de7bddd7f41981c34b1">mlir::OpTrait::impl::verifyNSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numSuccessors)</td></tr>
<tr class="separator:a4403585b9eec4de7bddd7f41981c34b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cceb3d69b10bcd82a82246f93b967a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a6cceb3d69b10bcd82a82246f93b967a4">mlir::OpTrait::impl::verifyAtLeastNSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numSuccessors)</td></tr>
<tr class="separator:a6cceb3d69b10bcd82a82246f93b967a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbacb7693a2df8b34e96340ab89a94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a4fbacb7693a2df8b34e96340ab89a94a">mlir::OpTrait::impl::verifyOperandSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef sizeAttrName)</td></tr>
<tr class="separator:a4fbacb7693a2df8b34e96340ab89a94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade217d2c5c5168f9b61dd5a7c6c812de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ade217d2c5c5168f9b61dd5a7c6c812de">mlir::OpTrait::impl::verifyResultSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef sizeAttrName)</td></tr>
<tr class="separator:ade217d2c5c5168f9b61dd5a7c6c812de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232a88a3d7d7399639ab0a50678c305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a232a88a3d7d7399639ab0a50678c305e">mlir::OpTrait::impl::verifyNoRegionArguments</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a232a88a3d7d7399639ab0a50678c305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf9877f4c4c5d9888a29bede2755502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#abcf9877f4c4c5d9888a29bede2755502">mlir::OpTrait::impl::verifyElementwiseMappable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:abcf9877f4c4c5d9888a29bede2755502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a5c5901abcbc3fa45814cb4c4d0b27c28">mlir::op_definition_impl::hasTrait</a> (TypeID traitID)</td></tr>
<tr class="memdesc:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this given Trait ID matches the IDs of any of the provided trait types <code>Traits</code>.  <a href="namespacemlir_1_1op__definition__impl.html#a5c5901abcbc3fa45814cb4c4d0b27c28">More...</a><br /></td></tr>
<tr class="separator:a5c5901abcbc3fa45814cb4c4d0b27c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29daf4e8e7be567394da583d6fa7e35"><td class="memTemplParams" colspan="2">template&lt;typename Trait &gt; </td></tr>
<tr class="memitem:ab29daf4e8e7be567394da583d6fa7e35"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; detect_has_single_result_fold_trait&lt; Trait &gt;::value, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab29daf4e8e7be567394da583d6fa7e35">mlir::op_definition_impl::foldTrait</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:ab29daf4e8e7be567394da583d6fa7e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of folding a trait that implements a <code>foldTrait</code> function that is specialized for operations that have a single result.  <a href="namespacemlir_1_1op__definition__impl.html#ab29daf4e8e7be567394da583d6fa7e35">More...</a><br /></td></tr>
<tr class="separator:ab29daf4e8e7be567394da583d6fa7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c105b59443d003e7f7b6f898ae81c"><td class="memTemplParams" colspan="2">template&lt;typename Trait &gt; </td></tr>
<tr class="memitem:aab8c105b59443d003e7f7b6f898ae81c"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; detect_has_fold_trait&lt; Trait &gt;::value, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#aab8c105b59443d003e7f7b6f898ae81c">mlir::op_definition_impl::foldTrait</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:aab8c105b59443d003e7f7b6f898ae81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of folding a trait that implements a generalized <code>foldTrait</code> function that is supports any operation type.  <a href="namespacemlir_1_1op__definition__impl.html#aab8c105b59443d003e7f7b6f898ae81c">More...</a><br /></td></tr>
<tr class="separator:aab8c105b59443d003e7f7b6f898ae81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce940a857b9b45978d6dc2e48f4186"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab9ce940a857b9b45978d6dc2e48f4186"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab9ce940a857b9b45978d6dc2e48f4186">mlir::op_definition_impl::foldTraitsImpl</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results, std::tuple&lt; Ts... &gt; *)</td></tr>
<tr class="memdesc:ab9ce940a857b9b45978d6dc2e48f4186"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of <code>foldTraits</code> below that returns the result of folding a set of trait types <code>Ts</code> that implement a <code>foldTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#ab9ce940a857b9b45978d6dc2e48f4186">More...</a><br /></td></tr>
<tr class="separator:ab9ce940a857b9b45978d6dc2e48f4186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff66cc821b4e086d0421618c920a5f45"><td class="memTemplParams" colspan="2">template&lt;typename TraitTupleT &gt; </td></tr>
<tr class="memitem:aff66cc821b4e086d0421618c920a5f45"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::tuple_size&lt; TraitTupleT &gt;::value !=0, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#aff66cc821b4e086d0421618c920a5f45">mlir::op_definition_impl::foldTraits</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:aff66cc821b4e086d0421618c920a5f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple type containing a set of traits that contain a <code>foldTrait</code> method, return the result of folding the given operation.  <a href="namespacemlir_1_1op__definition__impl.html#aff66cc821b4e086d0421618c920a5f45">More...</a><br /></td></tr>
<tr class="separator:aff66cc821b4e086d0421618c920a5f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f6c798ce070e7fc51ec882316ec44e"><td class="memTemplParams" colspan="2">template&lt;typename TraitTupleT &gt; </td></tr>
<tr class="memitem:a69f6c798ce070e7fc51ec882316ec44e"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::tuple_size&lt; TraitTupleT &gt;::value==0, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a69f6c798ce070e7fc51ec882316ec44e">mlir::op_definition_impl::foldTraits</a> (Operation *op, ArrayRef&lt; Attribute &gt; operands, SmallVectorImpl&lt; OpFoldResult &gt; &amp;results)</td></tr>
<tr class="memdesc:a69f6c798ce070e7fc51ec882316ec44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of the method above that is specialized when there are no traits that contain a <code>foldTrait</code> method.  <a href="namespacemlir_1_1op__definition__impl.html#a69f6c798ce070e7fc51ec882316ec44e">More...</a><br /></td></tr>
<tr class="separator:a69f6c798ce070e7fc51ec882316ec44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d898a4d4c15afbe731aed4242fef9"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a256d898a4d4c15afbe731aed4242fef9"><td class="memTemplItemLeft" align="right" valign="top">static AbstractOperation::OperationProperties&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a256d898a4d4c15afbe731aed4242fef9">mlir::op_definition_impl::getTraitPropertiesImpl</a> (std::tuple&lt; Ts... &gt; *)</td></tr>
<tr class="memdesc:a256d898a4d4c15afbe731aed4242fef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of <code>getTraitProperties</code> below that returns the OR of invoking <code>getTraitProperties</code> on all of the provided trait types <code>Ts</code>.  <a href="namespacemlir_1_1op__definition__impl.html#a256d898a4d4c15afbe731aed4242fef9">More...</a><br /></td></tr>
<tr class="separator:a256d898a4d4c15afbe731aed4242fef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73daf7369d048bbdf962f5498693bc85"><td class="memTemplParams" colspan="2">template&lt;typename TraitTupleT &gt; </td></tr>
<tr class="memitem:a73daf7369d048bbdf962f5498693bc85"><td class="memTemplItemLeft" align="right" valign="top">static AbstractOperation::OperationProperties&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a73daf7369d048bbdf962f5498693bc85">mlir::op_definition_impl::getTraitProperties</a> ()</td></tr>
<tr class="memdesc:a73daf7369d048bbdf962f5498693bc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple type containing a set of traits that contain a <code>getTraitProperties</code> method, return the OR of all of the results of invoking those methods.  <a href="namespacemlir_1_1op__definition__impl.html#a73daf7369d048bbdf962f5498693bc85">More...</a><br /></td></tr>
<tr class="separator:a73daf7369d048bbdf962f5498693bc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41cfce2ed514a37696836725e4f19d6"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac41cfce2ed514a37696836725e4f19d6"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ac41cfce2ed514a37696836725e4f19d6">mlir::op_definition_impl::verifyTraitsImpl</a> (Operation *op, std::tuple&lt; Ts... &gt; *)</td></tr>
<tr class="memdesc:ac41cfce2ed514a37696836725e4f19d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of <code>verifyTraits</code> below that returns the result of verifying the current operation with all of the provided trait types <code>Ts</code>.  <a href="namespacemlir_1_1op__definition__impl.html#ac41cfce2ed514a37696836725e4f19d6">More...</a><br /></td></tr>
<tr class="separator:ac41cfce2ed514a37696836725e4f19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e70839d751a887a3ccae5438482d8f"><td class="memTemplParams" colspan="2">template&lt;typename TraitTupleT &gt; </td></tr>
<tr class="memitem:a56e70839d751a887a3ccae5438482d8f"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a56e70839d751a887a3ccae5438482d8f">mlir::op_definition_impl::verifyTraits</a> (Operation *op)</td></tr>
<tr class="memdesc:a56e70839d751a887a3ccae5438482d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple type containing a set of traits that contain a <code>verifyTrait</code> method, return the result of verifying the given operation.  <a href="namespacemlir_1_1op__definition__impl.html#a56e70839d751a887a3ccae5438482d8f">More...</a><br /></td></tr>
<tr class="separator:a56e70839d751a887a3ccae5438482d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba355ec72702cc639f877654f5e44e35"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#aba355ec72702cc639f877654f5e44e35">mlir::impl::parseOneResultOneOperandTypeOp</a> (OpAsmParser &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, OperationState &amp;result)</td></tr>
<tr class="separator:aba355ec72702cc639f877654f5e44e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea30eda77c9b51ac7d3e96b42449b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#afea30eda77c9b51ac7d3e96b42449b27">mlir::impl::buildBinaryOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1Value.html">Value</a> lhs, <a class="el" href="classmlir_1_1Value.html">Value</a> rhs)</td></tr>
<tr class="separator:afea30eda77c9b51ac7d3e96b42449b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fb8db1e9d3b1c83b20cc64b18e4e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a88fb8db1e9d3b1c83b20cc64b18e4e61">mlir::impl::parseOneResultSameOperandTypeOp</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:a88fb8db1e9d3b1c83b20cc64b18e4e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8f78deaf99931f8bce35cc110582ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a2b8f78deaf99931f8bce35cc110582ce">mlir::impl::printOneResultOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:a2b8f78deaf99931f8bce35cc110582ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1d5343b5f7efc411e47e528e970214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#afd1d5343b5f7efc411e47e528e970214">mlir::impl::buildCastOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Type.html">Type</a> destType)</td></tr>
<tr class="separator:afd1d5343b5f7efc411e47e528e970214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754d79975738d8cfa491035727cc0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ab754d79975738d8cfa491035727cc0b3">mlir::impl::parseCastOp</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:ab754d79975738d8cfa491035727cc0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa893e9929085181997438a8d5a9256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a6aa893e9929085181997438a8d5a9256">mlir::impl::printCastOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:a6aa893e9929085181997438a8d5a9256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf5021aeec7af7592bcb6c893952ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a3cf5021aeec7af7592bcb6c893952ae2">mlir::impl::foldCastOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a3cf5021aeec7af7592bcb6c893952ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 16 2020 12:50:39 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
