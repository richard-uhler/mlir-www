<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/Transforms/Fusion.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a class="el" href="dir_7e2f808e77498894ca0efbd745da2201.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fusion.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="lib_2Dialect_2Linalg_2Transforms_2PassDetail_8h_source.html">PassDetail.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DependenceAnalysis_8h_source.html">mlir/Dialect/Linalg/Analysis/DependenceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LinalgOps_8h_source.html">mlir/Dialect/Linalg/IR/LinalgOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LinalgTypes_8h_source.html">mlir/Dialect/Linalg/IR/LinalgTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">mlir/Dialect/Linalg/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Linalg/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">mlir/Dialect/Linalg/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StandardOps_2EDSC_2Intrinsics_8h_source.html">mlir/Dialect/StandardOps/EDSC/Intrinsics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/MapVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;set&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Fusion.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="Fusion_8cpp__incl.png" border="0" usemap="#lib_2Dialect_2Linalg_2Transforms_2Fusion_8cpp" alt=""/></div>
<map name="lib_2Dialect_2Linalg_2Transforms_2Fusion_8cpp" id="lib_2Dialect_2Linalg_2Transforms_2Fusion_8cpp">
<area shape="rect" id="node2" href="lib_2Dialect_2Linalg_2Transforms_2PassDetail_8h.html" title="PassDetail.h" alt="" coords="287,281,384,307"/>
<area shape="rect" id="node3" href="AffineOps_8h.html" title="mlir/Dialect/Affine\l/IR/AffineOps.h" alt="" coords="739,363,865,404"/>
<area shape="rect" id="node5" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="2852,638,2987,665"/>
<area shape="rect" id="node6" href="IR_2AffineExpr_8h.html" title="mlir/IR/AffineExpr.h" alt="" coords="3544,720,3681,747"/>
<area shape="rect" id="node7" href="LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="3542,795,3683,821"/>
<area shape="rect" id="node21" href="DependenceAnalysis_8h.html" title="mlir/Dialect/Linalg\l/Analysis/DependenceAnalysis.h" alt="" coords="1477,273,1692,315"/>
<area shape="rect" id="node22" href="LinalgOps_8h.html" title="mlir/Dialect/Linalg\l/IR/LinalgOps.h" alt="" coords="2337,363,2464,404"/>
<area shape="rect" id="node24" href="LinalgTypes_8h.html" title="mlir/Dialect/Linalg\l/IR/LinalgTypes.h" alt="" coords="3403,541,3529,583"/>
<area shape="rect" id="node35" href="Dialect_2Linalg_2Passes_8h.html" title="mlir/Dialect/Linalg\l/Passes.h" alt="" coords="136,273,263,315"/>
<area shape="rect" id="node36" href="Dialect_2Linalg_2Transforms_2Transforms_8h.html" title="mlir/Dialect/Linalg\l/Transforms/Transforms.h" alt="" coords="1991,95,2165,136"/>
<area shape="rect" id="node37" href="Dialect_2Linalg_2Utils_2Utils_8h.html" title="mlir/Dialect/Linalg\l/Utils/Utils.h" alt="" coords="1488,184,1615,225"/>
<area shape="rect" id="node38" href="StandardOps_2EDSC_2Intrinsics_8h.html" title="mlir/Dialect/StandardOps\l/EDSC/Intrinsics.h" alt="" coords="1005,273,1173,315"/>
<area shape="rect" id="node44" href="Dominance_8h.html" title="mlir/IR/Dominance.h" alt="" coords="2833,281,2976,307"/>
<area shape="rect" id="node47" href="GreedyPatternRewriteDriver_8h.html" title="mlir/Transforms/GreedyPattern\lRewriteDriver.h" alt="" coords="3960,95,4161,136"/>
<area shape="rect" id="node13" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="914,638,1031,665"/>
<area shape="rect" id="node19" href="include_2mlir_2Pass_2Pass_8h.html" title="mlir/Pass/Pass.h" alt="" coords="157,370,279,397"/>
<area shape="rect" id="node4" href="AffineMemoryOpInterfaces_8h.html" title="mlir/Dialect/Affine\l/IR/AffineMemoryOpInterfaces.h" alt="" coords="2306,541,2517,583"/>
<area shape="rect" id="node8" href="IR_2BuiltinTypes_8h.html" title="mlir/IR/BuiltinTypes.h" alt="" coords="2441,638,2589,665"/>
<area shape="rect" id="node10" href="OpDefinition_8h.html" title="mlir/IR/OpDefinition.h" alt="" coords="1512,720,1660,747"/>
<area shape="rect" id="node11" href="Ops_8h.html" title="mlir/Dialect/StandardOps\l/IR/Ops.h" alt="" coords="1279,452,1447,493"/>
<area shape="rect" id="node12" href="IR_2Builders_8h.html" title="mlir/IR/Builders.h" alt="" coords="1153,638,1275,665"/>
<area shape="rect" id="node14" href="SideEffectInterfaces_8h.html" title="mlir/Interfaces/SideEffect\lInterfaces.h" alt="" coords="1327,541,1498,583"/>
<area shape="rect" id="node16" href="LoopLikeInterface_8h.html" title="mlir/Interfaces/LoopLike\lInterface.h" alt="" coords="168,631,329,672"/>
<area shape="rect" id="node9" href="Types_8h.html" title="mlir/IR/Types.h" alt="" coords="3407,720,3519,747"/>
<area shape="rect" id="node15" href="ViewLikeInterface_8h.html" title="mlir/Interfaces/ViewLike\lInterface.h" alt="" coords="1725,541,1887,583"/>
<area shape="rect" id="node23" href="LinalgTraits_8h.html" title="mlir/Dialect/Linalg\l/IR/LinalgTraits.h" alt="" coords="2083,452,2209,493"/>
<area shape="rect" id="node26" href="StructuredOpsUtils_8h.html" title="mlir/Dialect/Utils\l/StructuredOpsUtils.h" alt="" coords="2845,541,2993,583"/>
<area shape="rect" id="node27" href="BlockAndValueMapping_8h.html" title="mlir/IR/BlockAndValueMapping.h" alt="" coords="2509,459,2724,486"/>
<area shape="rect" id="node28" href="BuiltinDialect_8h.html" title="mlir/IR/BuiltinDialect.h" alt="" coords="896,549,1049,575"/>
<area shape="rect" id="node29" href="TypeUtilities_8h.html" title="mlir/IR/TypeUtilities.h" alt="" coords="2335,459,2485,486"/>
<area shape="rect" id="node31" href="CopyOpInterface_8h.html" title="mlir/Interfaces/CopyOpInterface.h" alt="" coords="1962,549,2181,575"/>
<area shape="rect" id="node40" href="VectorOps_8h.html" title="mlir/Dialect/Vector\l/VectorOps.h" alt="" coords="1623,452,1754,493"/>
<area shape="rect" id="node41" href="Identifier_8h.html" title="mlir/IR/Identifier.h" alt="" coords="3757,720,3884,747"/>
<area shape="rect" id="node42" href="PatternMatch_8h.html" title="mlir/IR/PatternMatch.h" alt="" coords="890,370,1045,397"/>
<area shape="rect" id="node43" href="Bufferize_8h.html" title="mlir/Transforms/Bufferize.h" alt="" coords="1691,191,1871,218"/>
</map>
</div>
</div>
<p><a href="Fusion_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShapeDimension.html">ShapeDimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;linalg-fusion&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4eb24da25c230d006e357460cf60c675"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a4eb24da25c230d006e357460cf60c675">inferShapeComponents</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> permutationMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;offsets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;strides)</td></tr>
<tr class="memdesc:a4eb24da25c230d006e357460cf60c675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a simple high-level fusion pass on linalg structured operations.  <a href="#a4eb24da25c230d006e357460cf60c675">More...</a><br /></td></tr>
<tr class="separator:a4eb24da25c230d006e357460cf60c675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84145da67eb99009941856fddf1ab34"><td class="memItemLeft" align="right" valign="top">static LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ab84145da67eb99009941856fddf1ab34">cloneWithLoopRanges</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges)</td></tr>
<tr class="separator:ab84145da67eb99009941856fddf1ab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bda7c81ef2c40cf52452d003aa70e6a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structShapeDimension.html">ShapeDimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a8bda7c81ef2c40cf52452d003aa70e6a">getShapeDefiningLoopRange</a> (LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, bool fromSubViewOpOnly=false)</td></tr>
<tr class="separator:a8bda7c81ef2c40cf52452d003aa70e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2b2f86e222163675b7d2d3cc9a977"><td class="memItemLeft" align="right" valign="top">static LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a0ef2b2f86e222163675b7d2d3cc9a977">fuse</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp producer, const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &amp;fusedLoopsAndRanges)</td></tr>
<tr class="memdesc:a0ef2b2f86e222163675b7d2d3cc9a977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse the producer by cloning the <code>producer</code>.  <a href="#a0ef2b2f86e222163675b7d2d3cc9a977">More...</a><br /></td></tr>
<tr class="separator:a0ef2b2f86e222163675b7d2d3cc9a977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bf9c5713729b719d28d13b4ed76232"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ad9bf9c5713729b719d28d13b4ed76232">getRangeFromOperandShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedOperand, <a class="el" href="classunsigned.html">unsigned</a> dim)</td></tr>
<tr class="memdesc:ad9bf9c5713729b719d28d13b4ed76232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop range for a dimension <code>dim</code> based on the <code>shapedOperand</code>.  <a href="#ad9bf9c5713729b719d28d13b4ed76232">More...</a><br /></td></tr>
<tr class="separator:ad9bf9c5713729b719d28d13b4ed76232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82ee70a486805424ad7da7996aeb47d"><td class="memItemLeft" align="right" valign="top">static LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ae82ee70a486805424ad7da7996aeb47d">fuse</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp producer, <a class="el" href="classunsigned.html">unsigned</a> producerIdx, LinalgOp consumer, <a class="el" href="classunsigned.html">unsigned</a> consumerIdx)</td></tr>
<tr class="memdesc:ae82ee70a486805424ad7da7996aeb47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses the producer of <code>producerIdx</code> into the loop immediately enclosing <code>consumer</code>.  <a href="#ae82ee70a486805424ad7da7996aeb47d">More...</a><br /></td></tr>
<tr class="separator:ae82ee70a486805424ad7da7996aeb47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e2f0896470da6a34a6a40bfe55e957"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a73e2f0896470da6a34a6a40bfe55e957">isStructurallyFusableProducer</a> (LinalgOp producer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp consumer)</td></tr>
<tr class="separator:a73e2f0896470da6a34a6a40bfe55e957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad178c7e9306b3ef46879065e917a4dac"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ad178c7e9306b3ef46879065e917a4dac">isSameSubView</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> a, <a class="el" href="classmlir_1_1Value.html">Value</a> b)</td></tr>
<tr class="separator:ad178c7e9306b3ef46879065e917a4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd1277895813ac2c66c86cce2e2b1dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a0bd1277895813ac2c66c86cce2e2b1dc">findFusableProducer</a> (LinalgOp consumer, <a class="el" href="classunsigned.html">unsigned</a> consumerIdx, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph)</td></tr>
<tr class="separator:a0bd1277895813ac2c66c86cce2e2b1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a0c5dff1d702bfdc3416f5eb671be5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ae4a0c5dff1d702bfdc3416f5eb671be5">getProducerOfTensor</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> tensor, LinalgOp &amp;producer, <a class="el" href="classunsigned.html">unsigned</a> &amp;outputIndex)</td></tr>
<tr class="memdesc:ae4a0c5dff1d702bfdc3416f5eb671be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk back use-def chain through scf::For yields.  <a href="#ae4a0c5dff1d702bfdc3416f5eb671be5">More...</a><br /></td></tr>
<tr class="separator:ae4a0c5dff1d702bfdc3416f5eb671be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dca7e29a8de7e3d6608c35f2c50183f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a9dca7e29a8de7e3d6608c35f2c50183f">pruneReductionDimsFromMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; iteratorTypes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a9dca7e29a8de7e3d6608c35f2c50183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune all dimensions that are of reduction iterator type from <code>map</code>.  <a href="#a9dca7e29a8de7e3d6608c35f2c50183f">More...</a><br /></td></tr>
<tr class="separator:a9dca7e29a8de7e3d6608c35f2c50183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec972f6ba9f06a76c2da3fa7ebf0777"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a6ec972f6ba9f06a76c2da3fa7ebf0777">getConsumerLoopToProducerLoopMap</a> (<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a> dependence)</td></tr>
<tr class="memdesc:a6ec972f6ba9f06a76c2da3fa7ebf0777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from iterations in the consumer that write to the same location as the iterations in the producer.  <a href="#a6ec972f6ba9f06a76c2da3fa7ebf0777">More...</a><br /></td></tr>
<tr class="separator:a6ec972f6ba9f06a76c2da3fa7ebf0777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dcf4467f99f363f937474c3c3a9457"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a33dcf4467f99f363f937474c3c3a9457">doesTransposeAccess</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;fusableLoops)</td></tr>
<tr class="memdesc:a33dcf4467f99f363f937474c3c3a9457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a projected permutation <code>map</code>, returns true if the map changes the order in which the fused loop dimension appear.  <a href="#a33dcf4467f99f363f937474c3c3a9457">More...</a><br /></td></tr>
<tr class="separator:a33dcf4467f99f363f937474c3c3a9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91395f43bdb1d8532fc542fe70664577"><td class="memItemLeft" align="right" valign="top">static std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a91395f43bdb1d8532fc542fe70664577">collectFusableLoops</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;fusableDependences)</td></tr>
<tr class="memdesc:a91395f43bdb1d8532fc542fe70664577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positions of the loop in <code>op</code> that can be tiled based on the operations that are to be fused with it.  <a href="#a91395f43bdb1d8532fc542fe70664577">More...</a><br /></td></tr>
<tr class="separator:a91395f43bdb1d8532fc542fe70664577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac0e079e63c1d8cfd28ff76c499b15"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#aa9ac0e079e63c1d8cfd28ff76c499b15">tileRootOperation</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizeVector, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;fusedLoops)</td></tr>
<tr class="memdesc:aa9ac0e079e63c1d8cfd28ff76c499b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the fused loops in the root operation, by setting the tile sizes for all other loops to zero (those will be tiled later).  <a href="#aa9ac0e079e63c1d8cfd28ff76c499b15">More...</a><br /></td></tr>
<tr class="separator:aa9ac0e079e63c1d8cfd28ff76c499b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4989c5cb06b345448b44cc896708184"><td class="memItemLeft" align="right" valign="top">static SmallVector&lt; LinalgOp, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ab4989c5cb06b345448b44cc896708184">fuseOperations</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp tiledOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; fusionCandidates, const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;fusableDependences, const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;fusedLoops)</td></tr>
<tr class="memdesc:ab4989c5cb06b345448b44cc896708184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse the operations in <code>fusionCandidates</code> with <code>tiledOp</code>.  <a href="#ab4989c5cb06b345448b44cc896708184">More...</a><br /></td></tr>
<tr class="separator:ab4989c5cb06b345448b44cc896708184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f488ff6c90f88ca1d2e500913ea6f"><td class="memTemplParams" colspan="2">template&lt;typename LoopType &gt; </td></tr>
<tr class="memitem:a0d1f488ff6c90f88ca1d2e500913ea6f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a0d1f488ff6c90f88ca1d2e500913ea6f">tileAndFuseLinalgOpsImpl</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;tilingOptions)</td></tr>
<tr class="separator:a0d1f488ff6c90f88ca1d2e500913ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;linalg-fusion&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00033">33</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab84145da67eb99009941856fddf1ab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84145da67eb99009941856fddf1ab34">&#9670;&nbsp;</a></span>cloneWithLoopRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LinalgOp cloneWithLoopRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00090">90</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00642">mlir::Operation::clone()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Fusion_8cpp_source.html#l00060">inferShapeComponents()</a>, <a class="el" href="Types_8h_source.html#l00224">mlir::Type::isa()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00251">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00252">mlir::ShapedType::kDynamicStrideOrOffset</a>, <a class="el" href="Value_8cpp_source.html#l00131">mlir::Value::replaceAllUsesExcept()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00347">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00210">fuse()</a>.</p>

</div>
</div>
<a id="a91395f43bdb1d8532fc542fe70664577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91395f43bdb1d8532fc542fe70664577">&#9670;&nbsp;</a></span>collectFusableLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::set&lt;<a class="el" href="classunsigned.html">unsigned</a>&gt; collectFusableLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;&#160;</td>
          <td class="paramname"><em>fusableDependences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positions of the loop in <code>op</code> that can be tiled based on the operations that are to be fused with it. </p>
<p>For example, in a</p>
<p>linalg.matmul ins(a, b : ...) outs(c : ...)</p>
<p>if the producer of a needs to be fused with this op, only the <code>i</code> loop of the matmul can be tiled while fusing. If producer of a, and b are to be fused, then no loops can be tiled while fusing. The conditions used are:</p><ol type="1">
<li>Only parallel loops can be used for tile + fuse. Find the number of common outer parallel loops between the op and its producers being fused.</li>
<li>Of the parallel loops only some can be fused. Only those loops can be fused such where the fusable loops iteration space only touches one tile of the fused operation. This is because the producer (which is writing the fused subview) has update semantics.</li>
</ol>
<p>Since an inverse computation is needed, we need to consider the projection of the producerIndexMap w.r.t the parallel loops. The actual fusable loops are the dimensions of the consumerLoopToProducerLoop map that correspond to parallel loops and appear in the result of the map</p>
<p>Example 1: linalg.fill(c, cst) linalg.matmul ins(a, b) outs(c) Number of parallel loops : 2 producerIndexMap = affine_map&lt;(i, j) -&gt;(i , j)&gt; consumerIndexMap = affine_map&lt;(i, j, k) -&gt; (i, j)&gt; consumerLoopToProducerLoop = affine_map&lt;(i, j, k) -&gt; (i, j)&gt; Fused dimensions : i, j</p>
<p>Example 2: linalg.matmul ins(a, b) outs(c) linalg.generic {indexing_maps = [affine_map&lt;(i, j) -&gt; (j, i)&gt;, ... iterator_types = ["parallel", "parallel"]} ins(c) ...</p>
<p>Number of parallel loops = 2: producerIndexMap (projected to parallel loops) = affine_map&lt;(i, j) -&gt; (i, j)&gt; consumerLoopToProducerLoop2 = affine_map&lt;(i, j) -&gt; (j, i)&gt; Fused dimensions : i, j</p>
<p>Example 3: linalg.copy(s, b) linalg.matmul ins(a, b) outs(c)</p>
<p>Number of parallel loops = 2 produceIndexMap : affine_map&lt;(i, j) -&gt; (i, j)&gt; consumerLoopToProduceLoops = affine_map&lt;(i, j, k) -&gt; (k, j)&gt; submap with only parallel loops = affine_map&lt;(i, j) -&gt; (j)&gt; Fused dimensions : j </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00656">656</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00114">mlir::Attribute::cast()</a>, <a class="el" href="Fusion_8cpp_source.html#l00586">doesTransposeAccess()</a>, <a class="el" href="Fusion_8cpp_source.html#l00548">getConsumerLoopToProducerLoopMap()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00078">mlir::getParallelIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00836">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="a33dcf4467f99f363f937474c3c3a9457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dcf4467f99f363f937474c3c3a9457">&#9670;&nbsp;</a></span>doesTransposeAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool doesTransposeAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusableLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a projected permutation <code>map</code>, returns true if the map changes the order in which the fused loop dimension appear. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00586">586</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00656">collectFusableLoops()</a>.</p>

</div>
</div>
<a id="a0bd1277895813ac2c66c86cce2e2b1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd1277895813ac2c66c86cce2e2b1dc">&#9670;&nbsp;</a></span>findFusableProducer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>&gt; findFusableProducer </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>consumerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00381">381</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00150">mlir::linalg::LinalgDependenceGraph::getDependencesInto()</a>, <a class="el" href="Fusion_8cpp_source.html#l00324">mlir::linalg::isFusableInto()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00354">isSameSubView()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00726">mlir::linalg::findAllFusableDependences()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00427">mlir::linalg::fuseProducerOfBuffer()</a>.</p>

</div>
</div>
<a id="a0ef2b2f86e222163675b7d2d3cc9a977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2b2f86e222163675b7d2d3cc9a977">&#9670;&nbsp;</a></span>fuse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LinalgOp fuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusedLoopsAndRanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse the producer by cloning the <code>producer</code>. </p>
<p>The <code>fusedLoopsAndRanges</code> provides the loop range information for the fused loops. The rest are obtained from the producer itself, since they are not tiled + fused. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00210">210</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00090">cloneWithLoopRanges()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00166">getShapeDefiningLoopRange()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00261">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00812">fuseOperations()</a>, <a class="el" href="Fusion_8cpp_source.html#l00427">mlir::linalg::fuseProducerOfBuffer()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00490">mlir::linalg::fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="ae82ee70a486805424ad7da7996aeb47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82ee70a486805424ad7da7996aeb47d">&#9670;&nbsp;</a></span>fuse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LinalgOp fuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>producerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>consumerIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuses the producer of <code>producerIdx</code> into the loop immediately enclosing <code>consumer</code>. </p>
<p>This is achieved by "recomputing" the <code>producer</code> at the time it is needed just before the `consumer.</p>
<p>Depending on the type of <code>consumer.getShapedOperand(consumerIdx)</code>, there are 2 cases:</p><ol type="1">
<li>Buffer case: <code>producerIdx</code> is the index of the buffer in <code>producer.getOutputBuffers()</code>.</li>
<li>Tensor case: <code>producerIdx</code> is the index of the tensor in <code>producer.getResults()</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00261">261</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00096">mlir::Value::cast()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="Fusion_8cpp_source.html#l00210">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00241">getRangeFromOperandShape()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="ab4989c5cb06b345448b44cc896708184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4989c5cb06b345448b44cc896708184">&#9670;&nbsp;</a></span>fuseOperations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SmallVector&lt;LinalgOp, 1&gt; fuseOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>tiledOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>fusionCandidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;&#160;</td>
          <td class="paramname"><em>fusableDependences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusedLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse the operations in <code>fusionCandidates</code> with <code>tiledOp</code>. </p>
<p>Latter is expected to be a tiled operation such that it is valid to fuse all operations in <code>fusionCandidates</code>, i.e. move the operation within the inter-tile loops of <code>tiledOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00812">812</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00157">ShapeDimension::dimension</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="Fusion_8cpp_source.html#l00210">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00241">getRangeFromOperandShape()</a>, <a class="el" href="Fusion_8cpp_source.html#l00166">getShapeDefiningLoopRange()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00156">ShapeDimension::shape</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00836">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="a6ec972f6ba9f06a76c2da3fa7ebf0777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec972f6ba9f06a76c2da3fa7ebf0777">&#9670;&nbsp;</a></span>getConsumerLoopToProducerLoopMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&gt; getConsumerLoopToProducerLoopMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>&#160;</td>
          <td class="paramname"><em>dependence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mapping from iterations in the consumer that write to the same location as the iterations in the producer. </p>
<p>To do so use</p><ul>
<li>indexing map of the fused view in the consumer : consumerIndexMap</li>
<li>indexing map of the fused view in the producer : producerIndexMap consumerLoopToProducerLoop = inverse(producerIndexMap).compose(consumerIndexMap) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00548">548</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8h_source.html#l00056">mlir::linalg::LinalgDependenceGraph::LinalgDependenceGraphElem::dependentOpView</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="DependenceAnalysis_8h_source.html#l00060">mlir::linalg::LinalgDependenceGraph::LinalgDependenceGraphElem::indexingOpView</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00417">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00367">mlir::AffineMap::isPermutation()</a>, <a class="el" href="DependenceAnalysis_8h_source.html#l00049">mlir::linalg::LinalgDependenceGraph::LinalgOpView::op</a>, <a class="el" href="DependenceAnalysis_8h_source.html#l00050">mlir::linalg::LinalgDependenceGraph::LinalgOpView::operandIndex</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02554">mlir::AffineMap::print()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00532">pruneReductionDimsFromMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00656">collectFusableLoops()</a>.</p>

</div>
</div>
<a id="ae4a0c5dff1d702bfdc3416f5eb671be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a0c5dff1d702bfdc3416f5eb671be5">&#9670;&nbsp;</a></span>getProducerOfTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> getProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;&#160;</td>
          <td class="paramname"><em>outputIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk back use-def chain through scf::For yields. </p>
<p>Sets <code>producer</code> and <code>outputIndex</code> if it finds a producer LinalgOp </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00465">465</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00096">mlir::Value::cast()</a>, <a class="el" href="Value_8h_source.html#l00090">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, and <a class="el" href="Types_8h_source.html#l00224">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00490">mlir::linalg::fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="ad9bf9c5713729b719d28d13b4ed76232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bf9c5713729b719d28d13b4ed76232">&#9670;&nbsp;</a></span>getRangeFromOperandShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1Range.html">Range</a> getRangeFromOperandShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop range for a dimension <code>dim</code> based on the <code>shapedOperand</code>. </p>
<p>It is expected to be defined by a subview op or a subtensor op. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00241">241</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00261">fuse()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00812">fuseOperations()</a>.</p>

</div>
</div>
<a id="a8bda7c81ef2c40cf52452d003aa70e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bda7c81ef2c40cf52452d003aa70e6a">&#9670;&nbsp;</a></span>getShapeDefiningLoopRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structShapeDimension.html">ShapeDimension</a> getShapeDefiningLoopRange </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromSubViewOpOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00166">166</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00090">mlir::Value::dyn_cast()</a>, and <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00210">fuse()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00812">fuseOperations()</a>.</p>

</div>
</div>
<a id="a4eb24da25c230d006e357460cf60c675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb24da25c230d006e357460cf60c675">&#9670;&nbsp;</a></span>inferShapeComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> inferShapeComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>permutationMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a simple high-level fusion pass on linalg structured operations. </p>
<p>In each block, linalg ops are processed in reverse textual order. Given a linalg op <code>O</code>, fusion occurs by:</p><ol type="1">
<li>inspecting the linalg ops that write into the views read by <code>O</code>. There are 2 cases: a) buffer case: use the SSA value of the views and a simple alias analysis on subview ops to determine producer-consumer dependences; b) tensor case: use SSA use-def chains on subtensor ops;</li>
<li>greedily fuse the linalg ops that produce the subview/subtensor.</li>
<li>inspect the fused ops and determine whether they have other remaining LinalgOp uses. If not, then erase the original producing linalg op.</li>
</ol>
<p>More advanced use cases, analyses as well as profitability heuristics are left for future work. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00060">60</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00351">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00090">cloneWithLoopRanges()</a>.</p>

</div>
</div>
<a id="ad178c7e9306b3ef46879065e917a4dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad178c7e9306b3ef46879065e917a4dac">&#9670;&nbsp;</a></span>isSameSubView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isSameSubView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip the "source" operand. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00354">354</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00381">findFusableProducer()</a>.</p>

</div>
</div>
<a id="a73e2f0896470da6a34a6a40bfe55e957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e2f0896470da6a34a6a40bfe55e957">&#9670;&nbsp;</a></span>isStructurallyFusableProducer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isStructurallyFusableProducer </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00279">279</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00300">mlir::linalg::isProducerLastWriteOfView()</a>.</p>

</div>
</div>
<a id="a9dca7e29a8de7e3d6608c35f2c50183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dca7e29a8de7e3d6608c35f2c50183f">&#9670;&nbsp;</a></span>pruneReductionDimsFromMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> pruneReductionDimsFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prune all dimensions that are of reduction iterator type from <code>map</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00532">532</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00458">mlir::getProjectedMap()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">mlir::isParallelIterator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00548">getConsumerLoopToProducerLoopMap()</a>.</p>

</div>
</div>
<a id="a0d1f488ff6c90f88ca1d2e500913ea6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1f488ff6c90f88ca1d2e500913ea6f">&#9670;&nbsp;</a></span>tileAndFuseLinalgOpsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoopType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a>&gt; tileAndFuseLinalgOpsImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>tilingOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00836">836</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00656">collectFusableLoops()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="Fusion_8cpp_source.html#l00726">mlir::linalg::findAllFusableDependences()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00122">mlir::linalg::TiledAndFusedLinalgOps::fusedLoopDims</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00126">mlir::linalg::TiledAndFusedLinalgOps::fusedLoops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00124">mlir::linalg::TiledAndFusedLinalgOps::fusedProducers</a>, <a class="el" href="Fusion_8cpp_source.html#l00812">fuseOperations()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00359">mlir::linalg::LinalgTilingOptions::interchangeVector</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00120">mlir::linalg::TiledAndFusedLinalgOps::op</a>, <a class="el" href="IR_2Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Fusion_8cpp_source.html#l00794">tileRootOperation()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00339">mlir::linalg::LinalgTilingOptions::tileSizeComputationFunction</a>.</p>

</div>
</div>
<a id="aa9ac0e079e63c1d8cfd28ff76c499b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ac0e079e63c1d8cfd28ff76c499b15">&#9670;&nbsp;</a></span>tileRootOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a>&gt; tileRootOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusedLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tile the fused loops in the root operation, by setting the tile sizes for all other loops to zero (those will be tiled later). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00794">794</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00349">mlir::linalg::LinalgTilingOptions::setTileSizes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00499">mlir::linalg::tileLinalgOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00836">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 16 2020 12:50:39 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
