<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::OpTrait::ElementwiseMappable&lt; ConcreteType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></li><li class="navelem"><a class="el" href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html">ElementwiseMappable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structmlir_1_1OpTrait_1_1ElementwiseMappable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::OpTrait::ElementwiseMappable&lt; ConcreteType &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This trait tags scalar ops that also can be applied to vectors/tensors, with their semantics on vectors/tensors being elementwise application.  
 <a href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::OpTrait::ElementwiseMappable&lt; ConcreteType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1OpTrait_1_1ElementwiseMappable__inherit__graph.png" border="0" usemap="#mlir_1_1OpTrait_1_1ElementwiseMappable_3_01ConcreteType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1OpTrait_1_1ElementwiseMappable_3_01ConcreteType_01_4_inherit__map" id="mlir_1_1OpTrait_1_1ElementwiseMappable_3_01ConcreteType_01_4_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="mlir::OpTrait::TraitBase\l\&lt; ConcreteType, ElementwiseMappable \&gt;" alt="" coords="5,124,272,165"/>
<area shape="rect" id="node3" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="Helper class for implementing traits. " alt="" coords="43,5,234,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::OpTrait::ElementwiseMappable&lt; ConcreteType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1OpTrait_1_1ElementwiseMappable__coll__graph.png" border="0" usemap="#mlir_1_1OpTrait_1_1ElementwiseMappable_3_01ConcreteType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1OpTrait_1_1ElementwiseMappable_3_01ConcreteType_01_4_coll__map" id="mlir_1_1OpTrait_1_1ElementwiseMappable_3_01ConcreteType_01_4_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="mlir::OpTrait::TraitBase\l\&lt; ConcreteType, ElementwiseMappable \&gt;" alt="" coords="5,124,272,165"/>
<area shape="rect" id="node3" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="Helper class for implementing traits. " alt="" coords="43,5,234,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae3a721f34c4dff6b29fa06665ed236a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html#ae3a721f34c4dff6b29fa06665ed236a8">verifyTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ae3a721f34c4dff6b29fa06665ed236a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpTrait_1_1TraitBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; ConcreteType, ElementwiseMappable &gt;</a></td></tr>
<tr class="memitem:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">getOperation</a> ()</td></tr>
<tr class="memdesc:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ultimate Operation being worked on.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">More...</a><br /></td></tr>
<tr class="separator:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ConcreteType&gt;<br />
struct mlir::OpTrait::ElementwiseMappable&lt; ConcreteType &gt;</h3>

<p>This trait tags scalar ops that also can be applied to vectors/tensors, with their semantics on vectors/tensors being elementwise application. </p>
<p>NOTE: Not all ops that are "elementwise" in some abstract sense satisfy this trait. In particular, broadcasting behavior is not allowed. This trait describes a set of invariants that allow systematic vectorization/tensorization, and the reverse, scalarization. The properties needed for this also can be used to implement a number of transformations/analyses/interfaces.</p>
<p>An <code><a class="el" href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html" title="This trait tags scalar ops that also can be applied to vectors/tensors, with their semantics on vecto...">ElementwiseMappable</a></code> op must satisfy the following properties:</p>
<ol type="1">
<li>If any result is a vector (resp. tensor), then at least one operand must be a vector (resp. tensor).</li>
<li>If any operand is a vector (resp. tensor), then there must be at least one result, and all results must be vectors (resp. tensors).</li>
<li>The static types of all vector (resp. tensor) operands and results must have the same shape.</li>
<li>In the case of tensor operands, the dynamic shapes of all tensor operands must be the same, otherwise the op has undefined behavior.</li>
<li>("systematic scalarization" property) If an op has vector/tensor operands/results, then the same op, with the operand/result types changed to their corresponding element type, shall be a verifier-valid op.</li>
<li>The semantics of the op on vectors (resp. tensors) shall be the same as applying the scalarized version of the op for each corresponding element of the vector (resp. tensor) operands in parallel.</li>
<li>("systematic vectorization/tensorization" property) If an op has scalar operands/results, the op shall remain verifier-valid if all scalar operands are replaced with vectors/tensors of the same shape and corresponding element types.</li>
</ol>
<p>Together, these properties provide an easy way for scalar operations to conveniently generalize their behavior to vectors/tensors, and systematize conversion between these forms.</p>
<p>Examples: </p><div class="fragment"><div class="line">%scalar = <span class="stringliteral">&quot;std.addf&quot;</span>(%a, %b) : (f32, f32) -&gt; f32</div><div class="line"><span class="comment">// Applying the systematic vectorization/tensorization property, this op</span></div><div class="line"><span class="comment">// must also be valid:</span></div><div class="line">%tensor = <span class="stringliteral">&quot;std.addf&quot;</span>(%a_tensor, %b_tensor)</div><div class="line">          : (tensor&lt;?xf32&gt;, tensor&lt;?xf32&gt;) -&gt; tensor&lt;?xf32&gt;)</div><div class="line"></div><div class="line"><span class="comment">// These properties generalize well to the cases of non-scalar operands.</span></div><div class="line">%select_scalar_pred = <span class="stringliteral">&quot;std.select&quot;</span>(%pred, %true_val, %false_val)</div><div class="line">                      : (i1, tensor&lt;?xf32&gt;, tensor&lt;?xf32&gt;) -&gt; tensor&lt;?xf32&gt;</div><div class="line"><span class="comment">// Applying the systematic vectorization / tensorization property, this</span></div><div class="line"><span class="comment">// op must also be valid:</span></div><div class="line">%select_tensor_pred = <span class="stringliteral">&quot;std.select&quot;</span>(%pred_tensor, %true_val, %false_val)</div><div class="line">                      : (tensor&lt;?xi1&gt;, tensor&lt;?xf32&gt;, tensor&lt;?xf32&gt;)</div><div class="line">                      -&gt; tensor&lt;?xf32&gt;</div><div class="line"><span class="comment">// Applying the systematic scalarization property, this op must also</span></div><div class="line"><span class="comment">// be valid.</span></div><div class="line">%select_scalar = <span class="stringliteral">&quot;std.select&quot;</span>(%pred, %true_val_scalar, %false_val_scalar)</div><div class="line">                 : (i1, f32, f32) -&gt; f32</div></div><!-- fragment --><p>TODO: Avoid hardcoding vector/tensor, and generalize this to any type implementing a new "ElementwiseMappableTypeInterface" that describes types for which it makes sense to apply a scalar function to each element.</p>
<p>Rationale:</p><ul>
<li>1. and 2. guarantee a well-defined iteration space for 6.<ul>
<li>These also exclude the cases of 0 non-scalar operands or 0 non-scalar results, which complicate a generic definition of the iteration space.</li>
</ul>
</li>
<li>3. guarantees that folding can be done across scalars/vectors/tensors with the same pattern, as otherwise lots of special handling of type mismatches would be needed.</li>
<li>4. guarantees that no error handling cases need to be considered.<ul>
<li>Higher-level dialects should reify any needed guards / error handling code before lowering to an <a class="el" href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html" title="This trait tags scalar ops that also can be applied to vectors/tensors, with their semantics on vecto...">ElementwiseMappable</a> op.</li>
</ul>
</li>
<li>5. and 6. allow defining the semantics on vectors/tensors via the scalar semantics and provide a constructive procedure for IR transformations to e.g. create scalar loop bodies from tensor ops.</li>
<li>7. provides the reverse of 5., which when chained together allows reasoning about the relationship between the tensor and vector case. Additionally, it permits reasoning about promoting scalars to vectors/tensors via broadcasting in cases like <code>select_scalar_pred</code> above. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01328">1328</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3a721f34c4dff6b29fa06665ed236a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a721f34c4dff6b29fa06665ed236a8">&#9670;&nbsp;</a></span>verifyTrait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="el" href="structmlir_1_1OpTrait_1_1ElementwiseMappable.html">mlir::OpTrait::ElementwiseMappable</a>&lt; ConcreteType &gt;::verifyTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01330">1330</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l01095">mlir::OpTrait::impl::verifyElementwiseMappable()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/mlir/IR/<a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 16 2020 12:50:41 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
