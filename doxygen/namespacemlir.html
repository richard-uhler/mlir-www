<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Include the generated interface declarations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1__dlloader"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1__dlloader.html">_dlloader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1acc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1acc.html">acc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1async"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1async.html">async</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1AttributeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1AttributeTrait.html">AttributeTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1dialects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1dialects.html">dialects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1edsc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html">edsc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1gpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ir.html">ir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1LLVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matcher"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matchers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matchers.html">matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1MemoryEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1MemoryEffects.html">MemoryEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1NVVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1omp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1omp.html">omp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1op__definition__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">op_definition_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ops__assertions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ops__assertions.html">ops_assertions</a></td></tr>
<tr class="memdesc:namespacemlir_1_1ops__assertions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded arithmetic operators for <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> expressions asserting that their arguments have the proper <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> expression subtype. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1passmanager"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1passmanager.html">passmanager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl.html">pdl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__interp.html">pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1pdl__to__pdl__interp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html">pdl_to_pdl_interp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1python"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1python.html">python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1quant"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quant.html">quant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ReductionTreeUtils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ReductionTreeUtils.html">ReductionTreeUtils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ROCDL"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1scf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html">scf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1shape"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1shape.html">shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1SideEffects"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1SideEffects.html">SideEffects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1spirv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tblgen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tblgen.html">tblgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tosa"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tosa.html">tosa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1transforms"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transforms.html">transforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1TypeTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1TypeTrait.html">TypeTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractAttribute.html">AbstractAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>.  <a href="classmlir_1_1AbstractAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractOperation.html">AbstractOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "type erased" representation of a registered operation.  <a href="classmlir_1_1AbstractOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the static information common to all instances of a registered <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1AbstractType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html">AffineApplyNormalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="structmlir_1_1AffineApplyNormalizer.html" title="An AffineApplyNormalizer is a helper class that supports renumbering operands of AffineApplyOp. ">AffineApplyNormalizer</a></code> is a helper class that supports renumbering operands of AffineApplyOp.  <a href="structmlir_1_1AffineApplyNormalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBinaryOpExpr.html">AffineBinaryOpExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine binary operation expression.  <a href="classmlir_1_1AffineBinaryOpExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBound.html">AffineBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineBound.html" title="AffineBound represents a lower or upper bound in the for operation. ">AffineBound</a> represents a lower or upper bound in the for operation.  <a href="classmlir_1_1AffineBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineConstantExpr.html">AffineConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="classmlir_1_1AffineConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy / DMA generation options for <a class="el" href="namespacemlir.html#a6e92b2877dd22568dffce49e740b8d93" title="Performs explicit copying for the contiguous sequence of operations in the block iterator range [`beg...">mlir::affineDataCopyGenerate</a>.  <a href="structmlir_1_1AffineCopyOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional identifier appearing in an affine expression.  <a href="classmlir_1_1AffineDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  <a href="classmlir_1_1AffineDmaStartOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaWaitOp.html">AffineDmaWaitOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> blocks until the completion of a DMA operation associated with the tag element 'tag[index]'.  <a href="classmlir_1_1AffineDmaWaitOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for affine expression.  <a href="classmlir_1_1AffineExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor.html">AffineExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> visitors/walkers.  <a href="classmlir_1_1AffineExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  <a href="classmlir_1_1AffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineReadOpInterface.html">AffineReadOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineSymbolExpr.html">AffineSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic identifier appearing in an affine expression.  <a href="classmlir_1_1AffineSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> is an affine map plus its ML value operands and results for analysis purposes.  <a href="classmlir_1_1AffineValueMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineWriteOpInterface.html">AffineWriteOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisManager.html">AnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an analysis manager for a particular operation instance.  <a href="classmlir_1_1AnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array attributes are lists of other attributes.  <a href="classmlir_1_1ArrayAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides management for the lifetime of the state used when printing the IR.  <a href="classmlir_1_1AsmState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes are known-constant values of operations.  <a href="classmlir_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeInterface.html">AttributeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an attribute interface.  <a href="classmlir_1_1AttributeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an attribute.  <a href="classmlir_1_1AttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base MemRef for Ranked and Unranked variants.  <a href="classmlir_1_1BaseMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a></code> represents an ordered list of <code><a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a></code>s.  <a href="classmlir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> arguments are values.  <a href="classmlir_1_1BlockArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockNumberOfExecutionsInfo.html">BlockNumberOfExecutionsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents number of block executions information.  <a href="classmlir_1_1BlockNumberOfExecutionsInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockOperand.html">BlockOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminator operations can have <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> operands to represent successors.  <a href="classmlir_1_1BlockOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Blocks.  <a href="classmlir_1_1BlockRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case of <a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a> to represent boolean integers, i.e., signless i1 integers.  <a href="classmlir_1_1BoolAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferAliasAnalysis.html">BufferAliasAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A straight-forward alias analysis which ensures that all aliases of all values will be determined.  <a href="classmlir_1_1BufferAliasAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for bufferization.  <a href="classmlir_1_1BufferizeTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a general helper class for creating context-global objects like types, attributes, and affine expressions.  <a href="classmlir_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraphNode.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single callable in the callgraph.  <a href="classmlir_1_1CallGraphNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CallInterfaceCallable.html">CallInterfaceCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable is either a symbol, or an SSA value, that is referenced by a call-like operation.  <a href="structmlir_1_1CallInterfaceCallable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallSiteLoc.html">CallSiteLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location as call site.  <a href="classmlir_1_1CallSiteLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexStructBuilder.html">ComplexStructBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexType.html">ComplexType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'complex' type represents a complex number with a parameterized element type, which is composed of a real and imaginary value of that element type.  <a href="classmlir_1_1ComplexType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantFloatOp.html">ConstantFloatOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a refinement of the "constant" op for the case where it is returning a float value of <a class="el" href="classmlir_1_1FloatType.html">FloatType</a>.  <a href="classmlir_1_1ConstantFloatOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIndexOp.html">ConstantIndexOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a refinement of the "constant" op for the case where it is returning an integer value of Index type.  <a href="classmlir_1_1ConstantIndexOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIntOp.html">ConstantIntOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a refinement of the "constant" op for the case where it is returning an integer value of <a class="el" href="classmlir_1_1IntegerType.html" title="Integer types can have arbitrary bitwidth up to a large fixed limit. ">IntegerType</a>.  <a href="classmlir_1_1ConstantIntOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ContractionOpLowering.html">ContractionOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progressive lowering of ContractionOp.  <a href="classmlir_1_1ContractionOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ContractionOpToDotLowering.html">ContractionOpToDotLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progressive lowering of a <code>vector.contract a, b, c</code> with row-major matmul semantics to an output-size-unrolled sequence: ``` out = constant ...  <a href="classmlir_1_1ContractionOpToDotLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ContractionOpToMatmulOpLowering.html">ContractionOpToMatmulOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progressive lowering of a <code>vector.contract a, b, c</code> with row-major matmul semantics to: </p><div class="fragment"><div class="line">%flattened_a = vector.shape_cast %a</div><div class="line">%flattened_b = vector.shape_cast %b</div><div class="line">%flattened_d = vector.matmul %flattened_a, %flattened_b</div><div class="line">%d = vector.shape_cast %%flattened_d</div><div class="line">%e = add %c, %d</div></div><!-- fragment --><p> <code>vector.matmul</code> later lowers to <code>llvm.matrix.multiply</code>.  <a href="classmlir_1_1ContractionOpToMatmulOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ContractionOpToOuterProductOpLowering.html">ContractionOpToOuterProductOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progressive lowering of a <code>vector.contract a, b, c</code> with row-major matmul semantics to a reduction_size-unrolled sequence: ``` at = vector.transpose a, [1, 0] bRow0 = vector.extract b[0] atRow0 = vector.extract at[0] c0 = vector.outerproduct atRow0, bRow0, c ...  <a href="classmlir_1_1ContractionOpToOuterProductOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPattern.html">ConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the conversion patterns.  <a href="classmlir_1_1ConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pattern rewriter for use with ConversionPatterns.  <a href="classmlir_1_1ConversionPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a specific conversion target.  <a href="classmlir_1_1ConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertOpToLLVMPattern.html">ConvertOpToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect that match exactly one source operation.  <a href="classmlir_1_1ConvertOpToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConvertToLLVMPattern.html">ConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1ConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CopyGenerateResult.html">CopyGenerateResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result for calling generateCopyForMemRegion.  <a href="structmlir_1_1CopyGenerateResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense vector or tensor object.  <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense float vector or tensor object.  <a href="classmlir_1_1DenseFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense integer vector or tensor object.  <a href="classmlir_1_1DenseIntElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntOrFPElementsAttr.html">DenseIntOrFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute class for specializing behavior of Int and Floating-point densely packed string arrays.  <a href="classmlir_1_1DenseIntOrFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseStringElementsAttr.html">DenseStringElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute class for representing dense arrays of strings.  <a href="classmlir_1_1DenseStringElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two accesses to the same memref access the same element.  <a href="structmlir_1_1DependenceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the information necessary to report a diagnostic to the <a class="el" href="classmlir_1_1DiagnosticEngine.html" title="This class is the main interface for diagnostics. ">DiagnosticEngine</a>.  <a href="classmlir_1_1Diagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant type that holds a single argument for a diagnostic.  <a href="classmlir_1_1DiagnosticArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticEngine.html">DiagnosticEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the main interface for diagnostics.  <a href="classmlir_1_1DiagnosticEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the entire group.  <a href="classmlir_1_1Dialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmParser.html">DialectAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectAsmParser.html" title="The DialectAsmParser has methods for interacting with the asm parser: parsing things from it...">DialectAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1DialectAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom printAttribute/printType() method on a dialect.  <a href="classmlir_1_1DialectAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectDecodeAttributesInterface.html">DialectDecodeAttributesInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an interface to decode opaque constant tensor.  <a href="classmlir_1_1DialectDecodeAttributesInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectFoldInterface.html">DialectFoldInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a fold interface to allow for dialects to control specific aspects of the folding behavior for operations they define.  <a href="classmlir_1_1DialectFoldInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInlinerInterface.html">DialectInlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface that must be implemented by the dialects of operations to be inlined.  <a href="classmlir_1_1DialectInlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterface.html">DialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an interface overridden for a single dialect.  <a href="classmlir_1_1DialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterfaceCollection.html">DialectInterfaceCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of dialect interfaces within a context, for a given concrete interface type.  <a href="classmlir_1_1DialectInterfaceCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectRegistry.html" title="The DialectRegistry maps a dialect namespace to a constructor for the matching dialect. ">DialectRegistry</a> maps a dialect namespace to a constructor for the matching dialect.  <a href="classmlir_1_1DialectRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DictionaryAttr.html">DictionaryAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary attribute is an attribute that represents a sorted collection of named attribute values.  <a href="classmlir_1_1DictionaryAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DmaStartOp.html">DmaStartOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DmaWaitOp.html">DmaWaitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic dominance information.  <a href="classmlir_1_1DominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ElementsAttr.html">ElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base attribute that represents a reference to a static shaped tensor or vector constant.  <a href="classmlir_1_1ElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyPipelineOptions.html">EmptyPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default empty option struct to be used for passes that do not need to take any options.  <a href="structmlir_1_1EmptyPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExecutionEngine.html">ExecutionEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-backed execution engine for MLIR modules.  <a href="classmlir_1_1ExecutionEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for representing a failure result, or a valid value of type <code>T</code>.  <a href="classmlir_1_1FailureOr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FileLineColLoc.html">FileLineColLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location derived from a file/line/column location.  <a href="classmlir_1_1FileLineColLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FilteredValueUseIterator.html">FilteredValueUseIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flat list of affine equalities and inequalities in the form.  <a href="classmlir_1_1FlatAffineConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference with a reference path containing a single element.  <a href="classmlir_1_1FlatSymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatAttr.html">FloatAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent fractions.  <a href="structmlir_1_1Fraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a frozen set of patterns that can be processed by a pattern applicator.  <a href="classmlir_1_1FrozenRewritePatternList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A model for providing function pass specific utilities.  <a href="classmlir_1_1FunctionPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FunctionType.html">FunctionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function types map from a list of inputs to a list of results.  <a href="classmlir_1_1FunctionType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FusedLoc.html">FusedLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a value composed of multiple source constructs, with an optional metadata attribute.  <a href="classmlir_1_1FusedLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FusionStrategy.html">FusionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the fusion strategy to be used in the Affine loop fusion utilities.  <a href="structmlir_1_1FusionStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GBRSimplex.html">GBRSimplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a simplex for a polytope, construct a new simplex whose variables are identified with a pair of points (x, y) in the original polytope.  <a href="classmlir_1_1GBRSimplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenInfo.html">GenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a generator (argument to invoke via mlir-tblgen, description, and generator function).  <a href="classmlir_1_1GenInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenNameParser.html">GenNameParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds command line option for each registered generator.  <a href="structmlir_1_1GenNameParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenRegistration.html">GenRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function. ">GenRegistration</a> provides a global initializer that registers a generator function.  <a href="structmlir_1_1GenRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUFuncOpLowering.html">GPUFuncOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUIndexIntrinsicOpLowering.html">GPUIndexIntrinsicOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUReturnOpLowering.html">GPUReturnOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a uniqued string owned by an <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>.  <a href="classmlir_1_1Identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a diagnostic that is inflight and set to be reported.  <a href="classmlir_1_1InFlightDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides the hooks into the inlining interface.  <a href="classmlir_1_1InlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set representing a conjunction of one or more affine equalities and inequalities.  <a href="classmlir_1_1IntegerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSetAttr.html">IntegerSetAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerType.html">IntegerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer types can have arbitrary bitwidth up to a large fixed limit.  <a href="classmlir_1_1IntegerType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> to represent an integer with potentially infinite positive value.  <a href="classmlir_1_1IntInfty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRObjectWithUseList.html">IRObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single IR object that contains a use list.  <a href="classmlir_1_1IRObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IROperand.html">IROperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1IROperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Lexer.html">Lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class breaks up the current file into a token stream.  <a href="classmlir_1_1Lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Liveness.html">Liveness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing liveness information from a given top-level operation.  <a href="classmlir_1_1Liveness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LivenessBlockInfo.html">LivenessBlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents liveness information on block level.  <a href="classmlir_1_1LivenessBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMConversionTarget.html">LLVMConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class that automatically populates legalization information for different <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> ops.  <a href="classmlir_1_1LLVMConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from types in the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around a <a class="el" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR. ">LocationAttr</a>.  <a href="classmlir_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> objects represent source locations information in MLIR.  <a href="classmlir_1_1LocationAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that can be used to signal success/failure.  <a href="structmlir_1_1LogicalResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1LoopNestStats.html" title="LoopNestStats aggregates various per-loop statistics (eg. ">LoopNestStats</a> aggregates various per-loop statistics (eg.  <a href="structmlir_1_1LoopNestStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="structmlir_1_1LowerToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> lowering.  <a href="structmlir_1_1LowerVectorToLLVMOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple class to represent a resizable matrix.  <a href="classmlir_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a memref load or store access information.  <a href="structmlir_1_1MemRefAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptor.html">MemRefDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting elements of a MemRef descriptor.  <a href="classmlir_1_1MemRefDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptorView.html">MemRefDescriptorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class allowing the user to access a range of Values that correspond to an unpacked memref descriptor using named accessors.  <a href="classmlir_1_1MemRefDescriptorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemRef types represent a region of memory that have a shape with a fixed number of dimensions.  <a href="classmlir_1_1MemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> is the top-level object for a collection of MLIR operations.  <a href="classmlir_1_1MLIRContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContextImpl.html">MLIRContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> class, using the pImpl idiom.  <a href="classmlir_1_1MLIRContextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleAnalysisManager.html">ModuleAnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis manager class specifically for the top-level operation.  <a href="classmlir_1_1ModuleAnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable affine map. Its affine expressions are however unique.  <a href="structmlir_1_1MutableAffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableDictionaryAttr.html">MutableDictionaryAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1MutableDictionaryAttr.html" title="A MutableDictionaryAttr is a mutable wrapper around a DictionaryAttr. ">MutableDictionaryAttr</a> is a mutable wrapper around a <a class="el" href="classmlir_1_1DictionaryAttr.html" title="Dictionary attribute is an attribute that represents a sorted collection of named attribute values...">DictionaryAttr</a>.  <a href="classmlir_1_1MutableDictionaryAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a mutable adaptor for a range of operands.  <a href="classmlir_1_1MutableOperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> is array of NamedAttributes that tracks whether it is sorted and does some basic work to remain sorted.  <a href="classmlir_1_1NamedAttrList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NameLoc.html">NameLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an identity name attached to a child location.  <a href="classmlir_1_1NameLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedMatch.html">NestedMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> captures nested patterns in the IR.  <a href="classmlir_1_1NestedMatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedPatternContext.html">NestedPatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII structure to transparently manage the bump allocator for <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> and <a class="el" href="classmlir_1_1NestedMatch.html" title="An NestedPattern captures nested patterns in the IR. ">NestedMatch</a> classes.  <a href="classmlir_1_1NestedPatternContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NumberOfExecutions.html">NumberOfExecutions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing how many times a block or an operation within a region is executed <em>each time</em> that region is entered.  <a href="classmlir_1_1NumberOfExecutions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OneToOneConvertToLLVMPattern.html">OneToOneConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of one-to-one conversion from "SourceOp" to "TargetOp" where the latter belongs to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect or an equivalent.  <a href="classmlir_1_1OneToOneConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueAttr.html">OpaqueAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque attributes represent attributes of non-registered dialects.  <a href="classmlir_1_1OpaqueAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueElementsAttr.html">OpaqueElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque attribute that represents a reference to a vector or tensor constant with opaque content.  <a href="classmlir_1_1OpaqueElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueLoc.html">OpaqueLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location that is external to MLIR.  <a href="classmlir_1_1OpaqueLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueType.html">OpaqueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque types represent types of non-registered dialects.  <a href="classmlir_1_1OpaqueType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmDialectInterface.html">OpAsmDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1OpAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom <a class="el" href="AffineOps_8cpp.html#a3bcff90e274680d32eb177813e5f48b8">print()</a> method.  <a href="classmlir_1_1OpAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps build Operations.  <a href="classmlir_1_1OpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpConversionPattern.html">OpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpConversionPattern.html" title="OpConversionPattern is a wrapper around ConversionPattern that allows for matching and rewriting agai...">OpConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns. ">ConversionPattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="structmlir_1_1OpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the operand iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> class.  <a href="classmlir_1_1OperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> is a basic unit of execution within MLIR.  <a href="classmlir_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationEquivalence.html">OperationEquivalence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for computing if two operations are equivalent.  <a href="structmlir_1_1OperationEquivalence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for folding operations, and unifying duplicated constants generated along the way.  <a href="classmlir_1_1OperationFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation of a specific type.  <a href="classmlir_1_1OperationPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass_3_01void_01_4.html">OperationPass&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation.  <a href="classmlir_1_1OperationPass_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an operation in an abstracted form, suitable for use with the builder APIs.  <a href="structmlir_1_1OperationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">OpInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an operand of an operation.  <a href="classmlir_1_1OpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a pass manager that runs passes on a specific operation type.  <a href="classmlir_1_1OpPassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of flags used to control the behavior of the various IR print methods (e.g.  <a href="classmlir_1_1OpPrintingFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpReducer.html">OpReducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpReducer.html" title="The OpReducer class defines a variant generator method that produces multiple variants by eliminating...">OpReducer</a> class defines a variant generator method that produces multiple variants by eliminating different OpType operations from the parent module.  <a href="classmlir_1_1OpReducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpReducerImpl.html">OpReducerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a value defined by a result of an operation.  <a href="classmlir_1_1OpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpRewritePattern.html">OpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpRewritePattern.html" title="OpRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting against an...">OpRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="structmlir_1_1OpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for <a class="el" href="classmlir_1_1ParseResult.html" title="This class represents success/failure for operation parsing. ">ParseResult</a>.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpToFuncCallLowering.html">OpToFuncCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that replace SourceOp with a CallOp to <code>f32Func</code> or <code>f64Func</code> depending on the element type that <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have. ">Op</a> operates upon.  <a href="structmlir_1_1OpToFuncCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptReductionPass.html">OptReductionPass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to a module, and will automatically destroy the held module on destruction if the held module is valid.  <a href="classmlir_1_1OwningModuleRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to an op, and will automatically destroy the held op on destruction if the held op is valid.  <a href="classmlir_1_1OwningOpRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParallelDiagnosticHandler.html">ParallelDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use when multi-threading some part of the compiler where diagnostics may be emitted.  <a href="classmlir_1_1ParallelDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents success/failure for operation parsing.  <a href="classmlir_1_1ParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pass.html">Pass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base pass class.  <a href="classmlir_1_1Pass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInfo.html">PassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information for a derived pass class.  <a href="classmlir_1_1PassInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentation.html">PassInstrumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure. ">PassInstrumentation</a> provides several entry points into the pass manager infrastructure.  <a href="classmlir_1_1PassInstrumentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentor.html">PassInstrumentor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a collection of <a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure. ">PassInstrumentation</a> objects, and invokes their respective call backs.  <a href="classmlir_1_1PassInstrumentor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main pass manager and pipeline builder.  <a href="classmlir_1_1PassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassNameCLParser.html">PassNameCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser spefically for MLIR pass names.  <a href="classmlir_1_1PassNameCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser for MLIR passes.  <a href="classmlir_1_1PassPipelineCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineInfo.html">PassPipelineInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information of a registered pass pipeline.  <a href="classmlir_1_1PassPipelineInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineOptions.html">PassPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="classmlir_1_1PassPipelineOptions.html" title="Subclasses of PassPipelineOptions provide a set of options that can be used to initialize a pass pipe...">PassPipelineOptions</a> provide a set of options that can be used to initialize a pass pipeline.  <a href="classmlir_1_1PassPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration.html">PassPipelineRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> pipeline builder routine.  <a href="structmlir_1_1PassPipelineRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html">PassPipelineRegistration&lt; EmptyPipelineOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> for EmptyPassOptions that does not pass an empty options struct to the pass builder function.  <a href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassRegistration.html">PassRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> allocation routine for a concrete pass instance.  <a href="structmlir_1_1PassRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassRegistryEntry.html">PassRegistryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a passes and pass pipelines (argument to invoke via mlir-opt, description, pass pipeline builder).  <a href="classmlir_1_1PassRegistryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassWrapper.html">PassWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a CRTP wrapper around a base pass class to define several necessary utility methods.  <a href="classmlir_1_1PassWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the data related to a pattern, but does not contain any methods or logic for the actual matching.  <a href="classmlir_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternApplicator.html">PatternApplicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages the application of a group of rewrite patterns, with a user-provided cost model.  <a href="classmlir_1_1PatternApplicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the benefit of a pattern match in a unitless scheme that ranges from 0 (very little benefit) to 65K.  <a href="classmlir_1_1PatternBenefit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates the application of a pattern to the current function, providing a way to create operations and keep track of what gets deleted.  <a href="classmlir_1_1PatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLPatternModule.html">PDLPatternModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the necessary data for a set of PDL patterns, or pattern rewrites specified in the form of the PDL dialect.  <a href="classmlir_1_1PDLPatternModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage type of byte-code interpreter values.  <a href="classmlir_1_1PDLValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic postdominance information.  <a href="classmlir_1_1PostDominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PredecessorIterator.html">PredecessorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a predecessor iterator for blocks.  <a href="classmlir_1_1PredecessorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PresburgerSet.html">PresburgerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can represent a union of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>, with support for union, intersection, subtraction and complement operations, as well as sampling.  <a href="classmlir_1_1PresburgerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PyFileAccumulator.html">PyFileAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates int a python file-like object, either writing text (default) or binary.  <a href="classmlir_1_1PyFileAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PyPrintAccumulator.html">PyPrintAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that accepts an MlirStringCallback.  <a href="structmlir_1_1PyPrintAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PySinglePartStringAccumulator.html">PySinglePartStringAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates into a python string from a method that is expected to make one (no more, no less) call to the callback (asserts internally on violation).  <a href="structmlir_1_1PySinglePartStringAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples.  <a href="structmlir_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RankedTensorType.html">RankedTensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ranked tensor types represent multi-dimensional arrays that have a shape with a fixed number of dimensions.  <a href="classmlir_1_1RankedTensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw_ostream subclass that simplifies indention a sequence of code.  <a href="classmlir_1_1raw__indented__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ReductionNode.html">ReductionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the <a class="el" href="classmlir_1_1ReductionNode.html" title="This class defines the ReductionNode which is used to wrap the module of a generated variant and keep...">ReductionNode</a> which is used to wrap the module of a generated variant and keep track of the necessary metadata for the reduction pass.  <a href="classmlir_1_1ReductionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ReductionTreePass.html">ReductionTreePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the Reduction Tree <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a>.  <a href="classmlir_1_1ReductionTreePass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of basic blocks and a link to the parent operation it is attached to.  <a href="classmlir_1_1Region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Regions.  <a href="classmlir_1_1RegionRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionSuccessor.html">RegionSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a successor of a region.  <a href="classmlir_1_1RegionSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultRange.html">ResultRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the result iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> class.  <a href="classmlir_1_1ResultRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html">RewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> is the common base class for all DAG to DAG replacements.  <a href="classmlir_1_1RewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ScfToSPIRVContextImpl.html">ScfToSPIRVContextImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScopedDiagnosticHandler.html">ScopedDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This diagnostic handler is a simple RAII class that registers and erases a diagnostic handler on a given context.  <a href="classmlir_1_1ScopedDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBM.html">SDBM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs interpreted as inequalities "expr &lt;= 0".  <a href="classmlir_1_1SDBM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMConstantExpr.html">SDBMConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> constant expression, wraps a 64-bit integer.  <a href="classmlir_1_1SDBMConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDialect.html">SDBMDialect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDiffExpr.html">SDBMDiffExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> difference expression.  <a href="classmlir_1_1SDBMDiffExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDimExpr.html">SDBMDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> dimension expression.  <a href="classmlir_1_1SDBMDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDirectExpr.html">SDBMDirectExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> direct expression includes exactly one variable (symbol or dimension), which is not negated in the expression.  <a href="classmlir_1_1SDBMDirectExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMExpr.html">SDBMExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Striped Difference-Bounded <a class="el" href="classmlir_1_1Matrix.html" title="This is a simple class to represent a resizable matrix. ">Matrix</a> (<a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a>) expression is a base left-hand side expression for the <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> framework.  <a href="classmlir_1_1SDBMExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMInputExpr.html">SDBMInputExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> "input" variable expression can be either a dimension identifier or a symbol identifier.  <a href="classmlir_1_1SDBMInputExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMNegExpr.html">SDBMNegExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of an <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> variable expression.  <a href="classmlir_1_1SDBMNegExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMStripeExpr.html">SDBMStripeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> stripe expression "x # C" where "x" is a term expression, "C" is a constant expression and "#" is the stripe operator defined as: x # C = x - x mod C.  <a href="classmlir_1_1SDBMStripeExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMSumExpr.html">SDBMSumExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> sum expression. LHS is a term expression and RHS is a constant.  <a href="classmlir_1_1SDBMSumExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMSymbolExpr.html">SDBMSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> symbol expression.  <a href="classmlir_1_1SDBMSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMTermExpr.html">SDBMTermExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> term expression can be one of:  <a href="classmlir_1_1SDBMTermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMVaryingExpr.html">SDBMVaryingExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> varying expression can be one of:  <a href="classmlir_1_1SDBMVaryingExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMVisitor.html">SDBMVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor class for <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> expressions.  <a href="classmlir_1_1SDBMVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a common base class between <a class="el" href="structVector.html">Vector</a>, UnrankedTensor, RankedTensor, and MemRef types because they share behavior and semantics around shape, rank, and fixed element type.  <a href="classmlir_1_1ShapedType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType. ">ShapedTypeComponents</a> that represents the components of a <a class="el" href="classmlir_1_1ShapedType.html" title="This is a common base class between Vector, UnrankedTensor, RankedTensor, and MemRef types because th...">ShapedType</a>.  <a href="classmlir_1_1ShapedTypeComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html">SimpleAffineExprFlattener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleObjectCache.html">SimpleObjectCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple object cache following Lang's LLJITWithObjectCache example.  <a href="classmlir_1_1SimpleObjectCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html">Simplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a version of the <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities.  <a href="classmlir_1_1Simplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Sliceable.html">Sliceable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CRTP base class for pseudo-containers willing to support Python-type slicing access on top of indexed access.  <a href="classmlir_1_1Sliceable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html">SourceMgrDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr.  <a href="classmlir_1_1SourceMgrDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html">SourceMgrDiagnosticVerifierHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr that verifies that emitted diagnostics match 'expected-*' lines on the corresponding line of the source file.  <a href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseElementsAttr.html">SparseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a sparse vector or tensor object.  <a href="classmlir_1_1SparseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVOpLowering.html">SPIRVOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to define a conversion pattern to lower <code>SourceOp</code> into SPIR-V.  <a href="classmlir_1_1SPIRVOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVToLLVMConversion.html">SPIRVToLLVMConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion from builtin types to SPIR-V types for shader interface.  <a href="classmlir_1_1SPIRVTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the elements have the same value.  <a href="classmlir_1_1SplatElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get or create instances of "storage classes".  <a href="classmlir_1_1StorageUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StringAttr.html">StringAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructBuilder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting values to a struct.  <a href="classmlir_1_1StructBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorRange.html">SuccessorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the successor iterators for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="classmlir_1_1SuccessorRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolRefAttr.html">SymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference attribute represents a symbolic reference to another operation.  <a href="classmlir_1_1SymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for representing and managing the symbol table used by operations with the '<a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>' trait.  <a href="classmlir_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code>s.  <a href="classmlir_1_1SymbolTableCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor types represent multi-dimensional arrays, and have two variants: <a class="el" href="classmlir_1_1RankedTensorType.html" title="Ranked tensor types represent multi-dimensional arrays that have a shape with a fixed number of dimen...">RankedTensorType</a> and <a class="el" href="classmlir_1_1UnrankedTensorType.html" title="Unranked tensor types represent multi-dimensional arrays that have an unknown shape. ">UnrankedTensorType</a>.  <a href="classmlir_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Tester.html">Tester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the testing environment of the tool.  <a href="classmlir_1_1Tester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ThreadLocalCache.html">ThreadLocalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for defining a thread local object with non static storage duration.  <a href="classmlir_1_1ThreadLocalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a token in the MLIR syntax.  <a href="classmlir_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateFromMLIRRegistration.html">TranslateFromMLIRRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateRegistration.html">TranslateRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateToMLIRRegistration.html">TranslateToMLIRRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Translate[ToMLIR|FromMLIR]Registration as an initializer that registers a function and associates it with name.  <a href="structmlir_1_1TranslateToMLIRRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslationParser.html">TranslationParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A command line parser for translation functions.  <a href="structmlir_1_1TranslationParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TupleType.html">TupleType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple types represent a collection of other types.  <a href="classmlir_1_1TupleType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  <a href="classmlir_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeAttr.html">TypeAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class.  <a href="classmlir_1_1TypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient unique identifier for a specific C++ type.  <a href="classmlir_1_1TypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeInterface.html">TypeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of a type interface.  <a href="classmlir_1_1TypeInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the various different ranges of value types.  <a href="classmlir_1_1TypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in a <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>.  <a href="classmlir_1_1TypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnitAttr.html">UnitAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit attributes are attributes that hold no specific value and are given meaning by their existence.  <a href="classmlir_1_1UnitAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnknownLoc.html">UnknownLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unknown location.  <a href="classmlir_1_1UnknownLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefDescriptor.html">UnrankedMemRefDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefType.html">UnrankedMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unranked MemRef type represent multi-dimensional MemRefs that have an unknown rank.  <a href="classmlir_1_1UnrankedMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedTensorType.html">UnrankedTensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unranked tensor types represent multi-dimensional arrays that have an unknown shape.  <a href="classmlir_1_1UnrankedTensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of an SSA value in the MLIR system, representing a computable value that has a type and a set of users.  <a href="classmlir_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a hook that expands one <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> into multiple <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s, with a TypeConverter-inspired callback registration mechanism.  <a href="classmlir_1_1ValueDecomposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Values.  <a href="classmlir_1_1ValueRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUseIterator.html">ValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class that allows for iterating over the uses of an IR operand type.  <a href="classmlir_1_1ValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUserIterator.html">ValueUserIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the users of an IRObject.  <a href="classmlir_1_1ValueUserIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorConvertToLLVMPattern.html">VectorConvertToLLVMPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic lowering implementation to rewrite Ops with just one result to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a>.  <a href="classmlir_1_1VectorConvertToLLVMPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorizationStrategy.html">VectorizationStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds parameters to perform n-D vectorization on a single loop nest.  <a href="structmlir_1_1VectorizationStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html">VectorTransferRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements lowering of TransferReadOp and TransferWriteOp to a proper abstraction for the hardware.  <a href="structmlir_1_1VectorTransferRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control whether unrolling is used when lowering vector transfer ops to SCF.  <a href="structmlir_1_1VectorTransferToSCFOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVector.html">Vector</a> types represent multi-dimensional SIMD vectors, and have a fixed known constant shape with one or more dimension.  <a href="classmlir_1_1VectorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VulkanLayoutUtils.html">VulkanLayoutUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to the Vulkan spec "14.5.4. Offset and Stride Assignment": "There are different alignment requirements depending on the specific resources and on the features enabled on the device.  <a href="classmlir_1_1VulkanLayoutUtils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility result that is used to signal if a walk method should be interrupted or advance.  <a href="classmlir_1_1WalkResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa10a637dbeb6e0d2178032f95fb5ea1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa10a637dbeb6e0d2178032f95fb5ea1b">VectorizableLoopFun</a> = std::function&lt; bool(AffineForOp)&gt;</td></tr>
<tr class="separator:aa10a637dbeb6e0d2178032f95fb5ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a899fdaa9e41cd3d5abb2b4cc44dba232">FilterFunctionType</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that:  <a href="#a899fdaa9e41cd3d5abb2b4cc44dba232">More...</a><br /></td></tr>
<tr class="separator:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389845a5dc285d746b24f6012a0ca2e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="memdesc:a389845a5dc285d746b24f6012a0ca2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of the condition to limit the propagation of transitive use-defs.  <a href="#a389845a5dc285d746b24f6012a0ca2e3">More...</a><br /></td></tr>
<tr class="separator:a389845a5dc285d746b24f6012a0ca2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d8f38577d05b87e540d717a7ba9c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a> = std::unique_ptr&lt; std::vector&lt; char &gt; &gt;</td></tr>
<tr class="separator:afd0d8f38577d05b87e540d717a7ba9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aaca5fea0016501841c1e98a14e7ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">BlobGenerator</a> = std::function&lt; <a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td></tr>
<tr class="separator:af5aaca5fea0016501841c1e98a14e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a45ae9aa1ccffd960f369da94d156"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">LoweringCallback</a> = std::function&lt; std::unique_ptr&lt; llvm::Module &gt;(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td></tr>
<tr class="separator:a594a45ae9aa1ccffd960f369da94d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd440a077557b4421b2cfd06d48956a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> = std::pair&lt; <a class="el" href="classmlir_1_1Identifier.html">Identifier</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td></tr>
<tr class="memdesc:a2bd440a077557b4421b2cfd06d48956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">NamedAttribute is combination of a name, represented by an <a class="el" href="classmlir_1_1Identifier.html" title="This class represents a uniqued string owned by an MLIRContext. ">Identifier</a>, and a value, represented by an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>.  <a href="#a2bd440a077557b4421b2cfd06d48956a">More...</a><br /></td></tr>
<tr class="separator:a2bd440a077557b4421b2cfd06d48956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bdae349015b16ce375bdd46c1e16c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:a759bdae349015b16ce375bdd46c1e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for attributes that require no additional initialization or storage.  <a href="#a759bdae349015b16ce375bdd46c1e16c">More...</a><br /></td></tr>
<tr class="separator:a759bdae349015b16ce375bdd46c1e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5011648c4f698028afb8a96b31ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="separator:aad8f5011648c4f698028afb8a96b31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">DialectAllocatorFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a2e943fa4f63d44d69d846e504c16d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbc3d0362a57c5175f05dd95fb59641"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> &gt;</td></tr>
<tr class="separator:aedbc3d0362a57c5175f05dd95fb59641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0887111bf825d1f766ef9e0911394d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">OpAsmSetValueNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td></tr>
<tr class="memdesc:ab0887111bf825d1f766ef9e0911394d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the start of a result group of an operation.  <a href="#ab0887111bf825d1f766ef9e0911394d5">More...</a><br /></td></tr>
<tr class="separator:ab0887111bf825d1f766ef9e0911394d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b512697c8dadec5de092fbd243ab4f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b512697c8dadec5de092fbd243ab4f6">PDLConstraintFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a5b512697c8dadec5de092fbd243ab4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic PDL pattern constraint function.  <a href="#a5b512697c8dadec5de092fbd243ab4f6">More...</a><br /></td></tr>
<tr class="separator:a5b512697c8dadec5de092fbd243ab4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4515fd1b2926432504b2fc92363e50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acf4515fd1b2926432504b2fc92363e50">PDLCreateFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td></tr>
<tr class="memdesc:acf4515fd1b2926432504b2fc92363e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native PDL creation function.  <a href="#acf4515fd1b2926432504b2fc92363e50">More...</a><br /></td></tr>
<tr class="separator:acf4515fd1b2926432504b2fc92363e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b0c268d492a9759203e8be9992d2bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab2b0c268d492a9759203e8be9992d2bc">PDLRewriteFunction</a> = std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> &gt;, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td></tr>
<tr class="memdesc:ab2b0c268d492a9759203e8be9992d2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native PDL rewrite function.  <a href="#ab2b0c268d492a9759203e8be9992d2bc">More...</a><br /></td></tr>
<tr class="separator:ab2b0c268d492a9759203e8be9992d2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eb3af9c93fd73a80717bf5dc93276d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6eb3af9c93fd73a80717bf5dc93276d">PDLSingleEntityConstraintFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td></tr>
<tr class="memdesc:aa6eb3af9c93fd73a80717bf5dc93276d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic PDL pattern constraint function.  <a href="#aa6eb3af9c93fd73a80717bf5dc93276d">More...</a><br /></td></tr>
<tr class="separator:aa6eb3af9c93fd73a80717bf5dc93276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for types that require no additional initialization or storage.  <a href="#a8b36f0e85767ed4e793d86f40bd8fe55">More...</a><br /></td></tr>
<tr class="separator:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9069ef9040ccc727d541c02d49ecd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="memdesc:a01e9069ef9040ccc727d541c02d49ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived Types.  <a href="#a01e9069ef9040ccc727d541c02d49ecd">More...</a><br /></td></tr>
<tr class="separator:a01e9069ef9040ccc727d541c02d49ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; errorHandler)&gt;</td></tr>
<tr class="memdesc:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry function that adds passes to the given pass manager.  <a href="#af4ccb1e7accf2ec0c57b1aea967ccd02">More...</a><br /></td></tr>
<tr class="separator:af4ccb1e7accf2ec0c57b1aea967ccd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;()&gt;</td></tr>
<tr class="separator:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; KeyT, ValueT, KeyInfoT, BucketT &gt;</td></tr>
<tr class="separator:ad7f731697783a754f6f0e3821d1264b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; ValueT, ValueInfoT &gt;</td></tr>
<tr class="separator:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplParams" colspan="2">template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </td></tr>
<tr class="memitem:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">StringSet</a> = <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt; AllocatorTy &gt;</td></tr>
<tr class="separator:ac2b3592ab67f8512cb18e62375d7ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = T&gt; </td></tr>
<tr class="memitem:ac474b9f30a56412e090d9919e4dd8b34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">StringSwitch</a> = <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt; T, R &gt;</td></tr>
<tr class="separator:ac474b9f30a56412e090d9919e4dd8b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ResultT  = void&gt; </td></tr>
<tr class="memitem:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">TypeSwitch</a> = <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt; T, ResultT &gt;</td></tr>
<tr class="separator:abcf44d03780c99376ac0c1dd1caed0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; Fn &gt;</td></tr>
<tr class="separator:a0bff6226b7c81b6134b8c1130403a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0c2458571cd80ebb876d979e24346"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(std::unique_ptr&lt; llvm::MemoryBuffer &gt; chunkBuffer, raw_ostream &amp;os)&gt;</td></tr>
<tr class="separator:aafb0c2458571cd80ebb876d979e24346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">GenFunction</a> = std::function&lt; bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td></tr>
<tr class="memdesc:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function to invoke.  <a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">More...</a><br /></td></tr>
<tr class="separator:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8735b67af7a64e4deff16477a06eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp, 8 &gt;</td></tr>
<tr class="memdesc:ad5c8735b67af7a64e4deff16477a06eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="#ad5c8735b67af7a64e4deff16477a06eb">More...</a><br /></td></tr>
<tr class="separator:ad5c8735b67af7a64e4deff16477a06eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> = std::pair&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> &gt;</td></tr>
<tr class="separator:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16773901a5b8781f9be66507fad3c5b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16773901a5b8781f9be66507fad3c5b4">TranslateSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a16773901a5b8781f9be66507fad3c5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR.  <a href="#a16773901a5b8781f9be66507fad3c5b4">More...</a><br /></td></tr>
<tr class="separator:a16773901a5b8781f9be66507fad3c5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995eefe8643c3770dfe42925733c17f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a995eefe8643c3770dfe42925733c17f8">TranslateStringRefToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a995eefe8643c3770dfe42925733c17f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the given string to MLIR.  <a href="#a995eefe8643c3770dfe42925733c17f8">More...</a><br /></td></tr>
<tr class="separator:a995eefe8643c3770dfe42925733c17f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">TranslateFromMLIRFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classModuleOp.html">ModuleOp</a>, llvm::raw_ostream &amp;output)&gt;</td></tr>
<tr class="memdesc:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates MLIR to a different format and outputs the result to a stream.  <a href="#a13b54e61e2491e2bc91c54f8ef429cfa">More...</a><br /></td></tr>
<tr class="separator:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb54b5d484b1a53b08f04871fb0da8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">TranslateFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(llvm::SourceMgr &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:addbb54b5d484b1a53b08f04871fb0da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that performs file-to-file translation involving MLIR.  <a href="#addbb54b5d484b1a53b08f04871fb0da8">More...</a><br /></td></tr>
<tr class="separator:addbb54b5d484b1a53b08f04871fb0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76a6e97fdeb03ac678bde155e380b7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac76a6e97fdeb03ac678bde155e380b7f">Direction</a> = <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Simplex::Direction</a></td></tr>
<tr class="separator:ac76a6e97fdeb03ac678bde155e380b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae0a5f1311f5db69741663dd9e28a3c9b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9b">SDBMExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baec211f7c20af43e742bf2570c3cb84f9">SDBMExprKind::Add</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bace7566d1d08cc094b74cf283cf9c56a5">SDBMExprKind::Stripe</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9ba49630f5d7723e9b41474bd1cb1887b9d">SDBMExprKind::Diff</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bacb17869fe51048b5a5c4c6106551a255">SDBMExprKind::Constant</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bab49b848e4bb608f4d5650e4b2817c641">SDBMExprKind::DimId</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baea00d3c6059a4ff11d351696747fc7ff">SDBMExprKind::SymbolId</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bafb278fa5defd7e699fcbc930c3e76ccd">SDBMExprKind::Neg</a>
<br />
 }</td></tr>
<tr class="separator:ae0a5f1311f5db69741663dd9e28a3c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f701680752dfb55505285ab8ce8b55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a> { <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a98402eecfbcefc336954458a01752131">IteratorType::Parallel</a>, 
<a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a9e834f13e35e4edf64863ab414a6217a">IteratorType::Reduction</a>
 }<tr class="memdesc:a77f701680752dfb55505285ab8ce8b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed representation for loop type strings.  <a href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a77f701680752dfb55505285ab8ce8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b7fd763c24274db6c115579084133"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">AffineExprKind::Add</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">AffineExprKind::Mul</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">AffineExprKind::Mod</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">AffineExprKind::FloorDiv</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">AffineExprKind::CeilDiv</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24">AffineExprKind::LAST_AFFINE_BINARY_OP</a> = CeilDiv, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">AffineExprKind::Constant</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">AffineExprKind::DimId</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">AffineExprKind::SymbolId</a>
<br />
 }</td></tr>
<tr class="separator:a6d3b7fd763c24274db6c115579084133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">DiagnosticSeverity</a> { <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec">DiagnosticSeverity::Note</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">DiagnosticSeverity::Warning</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">DiagnosticSeverity::Error</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">DiagnosticSeverity::Remark</a>
 }<tr class="memdesc:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different supported severity of a diagnostic.  <a href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583774594e92d8af2d0884e3262d7e24"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24">OperationProperty</a> { <a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24ac9f87f9079df3ae77c58b9258f497dfb">OperationProperty::Commutative</a> = 0x1, 
<a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24ab420c1d31e69a823fbc30a434907c9c0">OperationProperty::Terminator</a> = 0x2, 
<a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24aee504cc3a721fbb8c7898dcc0798d273">OperationProperty::IsolatedFromAbove</a> = 0x4
 }</td></tr>
<tr class="separator:a583774594e92d8af2d0884e3262d7e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">RegionKind</a> { <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b">RegionKind::SSACFG</a>, 
<a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd">RegionKind::Graph</a>
 }<tr class="memdesc:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of regions contained in an operation.  <a href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:abeb30aa1b062bf437bf3ea2b843a2ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64460ede39d8480e398fd2e6810d95b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">PassDisplayMode</a> { <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135">PassDisplayMode::List</a>, 
<a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72">PassDisplayMode::Pipeline</a>
 }<tr class="memdesc:ab64460ede39d8480e398fd2e6810d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the different display modes for the information within the pass manager.  <a href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab64460ede39d8480e398fd2e6810d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">TraversalMode</a> { <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96">SinglePath</a>, 
<a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1">Backtrack</a>, 
<a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593">MultiPath</a>
 }<tr class="memdesc:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">traversal.  <a href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9e4d5a3d224089fd8a2ebc3e933d08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1522039bca148f6d365612eb404e0994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1522039bca148f6d365612eb404e0994">getReachableAffineApplyOps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;affineApplyOps)</td></tr>
<tr class="memdesc:a1522039bca148f6d365612eb404e0994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <code>affineApplyOps</code>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an AffineApplyOp.  <a href="#a1522039bca148f6d365612eb404e0994">More...</a><br /></td></tr>
<tr class="separator:a1522039bca148f6d365612eb404e0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f085159bef0da235a45ebac17172a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66f085159bef0da235a45ebac17172a9">getIndexSet</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *domain)</td></tr>
<tr class="memdesc:a66f085159bef0da235a45ebac17172a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order.  <a href="#a66f085159bef0da235a45ebac17172a9">More...</a><br /></td></tr>
<tr class="separator:a66f085159bef0da235a45ebac17172a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af210ccb9e9409d8494b8998f50b6d274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af210ccb9e9409d8494b8998f50b6d274">checkMemrefAccessDependence</a> (const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;dstAccess, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *dependenceConstraints, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *dependenceComponents, bool allowRAR=false)</td></tr>
<tr class="separator:af210ccb9e9409d8494b8998f50b6d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0139b17eb17bf529e630ec15f2051472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0139b17eb17bf529e630ec15f2051472">hasDependence</a> (<a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a> result)</td></tr>
<tr class="memdesc:a0139b17eb17bf529e630ec15f2051472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element. ">DependenceResult</a> corresponds to a dependence result.  <a href="#a0139b17eb17bf529e630ec15f2051472">More...</a><br /></td></tr>
<tr class="separator:a0139b17eb17bf529e630ec15f2051472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a72abd84dcc66c8c890fc6c5e0d24f8">getDependenceComponents</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> maxLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *depCompsVec)</td></tr>
<tr class="memdesc:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth].  <a href="#a7a72abd84dcc66c8c890fc6c5e0d24f8">More...</a><br /></td></tr>
<tr class="separator:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7746ab6b30038f20f1508c7821fa3052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7746ab6b30038f20f1508c7821fa3052">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *flattenedExpr, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:a7746ab6b30038f20f1508c7821fa3052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions.  <a href="#a7746ab6b30038f20f1508c7821fa3052">More...</a><br /></td></tr>
<tr class="separator:a7746ab6b30038f20f1508c7821fa3052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54668e284d7e980f404164472f75c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae54668e284d7e980f404164472f75c62">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:ae54668e284d7e980f404164472f75c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <a href="#ae54668e284d7e980f404164472f75c62">More...</a><br /></td></tr>
<tr class="separator:ae54668e284d7e980f404164472f75c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3de480d05c0d64fcc14fd29efde14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50f3de480d05c0d64fcc14fd29efde14">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst=nullptr)</td></tr>
<tr class="separator:a50f3de480d05c0d64fcc14fd29efde14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d90e917cd6d91240a86ce6e3c9a9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a90d90e917cd6d91240a86ce6e3c9a9c6">buildTripCountMapAndOperands</a> (AffineForOp forOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a90d90e917cd6d91240a86ce6e3c9a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise.  <a href="#a90d90e917cd6d91240a86ce6e3c9a9c6">More...</a><br /></td></tr>
<tr class="separator:a90d90e917cd6d91240a86ce6e3c9a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdcd2c284243df5d427fcdfe4edde75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8cdcd2c284243df5d427fcdfe4edde75">getConstantTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a8cdcd2c284243df5d427fcdfe4edde75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop if it's a constant, None otherwise.  <a href="#a8cdcd2c284243df5d427fcdfe4edde75">More...</a><br /></td></tr>
<tr class="separator:a8cdcd2c284243df5d427fcdfe4edde75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3272c7e5d627a525a70f55fb93fb57"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c3272c7e5d627a525a70f55fb93fb57">getLargestDivisorOfTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a8c3272c7e5d627a525a70f55fb93fb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest known integral divisor of the trip count.  <a href="#a8c3272c7e5d627a525a70f55fb93fb57">More...</a><br /></td></tr>
<tr class="separator:a8c3272c7e5d627a525a70f55fb93fb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4243a75480867bb61c05aa5879d2a32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="structllvm_1_1DenseMapInfo.html">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4243a75480867bb61c05aa5879d2a32f">getInvariantAccesses</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; indices)</td></tr>
<tr class="memdesc:a4243a75480867bb61c05aa5879d2a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type IndexType, returns the set of <code>indices</code> that are independent of <code>iv</code>.  <a href="#a4243a75480867bb61c05aa5879d2a32f">More...</a><br /></td></tr>
<tr class="separator:a4243a75480867bb61c05aa5879d2a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76b6d2ee408bfc5909eb81779da3e0f1">isVectorizableLoopBody</a> (AffineForOp loop, <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable; i.e.  <a href="#a76b6d2ee408bfc5909eb81779da3e0f1">More...</a><br /></td></tr>
<tr class="separator:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f2a9f8242f345de0163689c30304e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae13f2a9f8242f345de0163689c30304e">isVectorizableLoopBody</a> (AffineForOp loop, int *memRefDim, <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:ae13f2a9f8242f345de0163689c30304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are are either:  <a href="#ae13f2a9f8242f345de0163689c30304e">More...</a><br /></td></tr>
<tr class="separator:ae13f2a9f8242f345de0163689c30304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65079eba69cbd732d43736887a06bff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac65079eba69cbd732d43736887a06bff">isOpwiseShiftValid</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts)</td></tr>
<tr class="memdesc:ac65079eba69cbd732d43736887a06bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.  <a href="#ac65079eba69cbd732d43736887a06bff">More...</a><br /></td></tr>
<tr class="separator:ac65079eba69cbd732d43736887a06bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc425822a826dd76ea2e8185aeb9fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7dc425822a826dd76ea2e8185aeb9fab">defaultFilterFunction</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)</td></tr>
<tr class="separator:a7dc425822a826dd76ea2e8185aeb9fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69efac5a24f7fb5371ad005350219f7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69efac5a24f7fb5371ad005350219f7a">compare</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="memdesc:a69efac5a24f7fb5371ad005350219f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison between two fractions.  <a href="#a69efac5a24f7fb5371ad005350219f7a">More...</a><br /></td></tr>
<tr class="separator:a69efac5a24f7fb5371ad005350219f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad29aea3470290e8766e38917b9e65b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaad29aea3470290e8766e38917b9e65b">floor</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> f)</td></tr>
<tr class="separator:aaad29aea3470290e8766e38917b9e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb70330a9161c3ff1b6aa1f905e8f51b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb70330a9161c3ff1b6aa1f905e8f51b">ceil</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> f)</td></tr>
<tr class="separator:abb70330a9161c3ff1b6aa1f905e8f51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541b3ac36d683b618cd7dede91a50b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac541b3ac36d683b618cd7dede91a50b5">operator-</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x)</td></tr>
<tr class="separator:ac541b3ac36d683b618cd7dede91a50b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa2646a6fd6b2ed304e40fc8ad24f20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafa2646a6fd6b2ed304e40fc8ad24f20">operator&lt;</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="separator:aafa2646a6fd6b2ed304e40fc8ad24f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05e51a2c29b9ba3893b6217be170936"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa05e51a2c29b9ba3893b6217be170936">operator&lt;=</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="separator:aa05e51a2c29b9ba3893b6217be170936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db37cd8863ba3c235e95b092062c209"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0db37cd8863ba3c235e95b092062c209">operator==</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="separator:a0db37cd8863ba3c235e95b092062c209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21eef29c421651c18a73ff7949668e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee21eef29c421651c18a73ff7949668e">operator&gt;</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="separator:aee21eef29c421651c18a73ff7949668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcfbb1e7cb68e45a545a6c56207962a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abbcfbb1e7cb68e45a545a6c56207962a">operator&gt;=</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="separator:abbcfbb1e7cb68e45a545a6c56207962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6187ff461b8d15899e73b828f3bcecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6187ff461b8d15899e73b828f3bcecf0">operator*</a> (<a class="el" href="structmlir_1_1Fraction.html">Fraction</a> x, <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> y)</td></tr>
<tr class="separator:a6187ff461b8d15899e73b828f3bcecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c9138cd38e82a78b5895b0e606d5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab3c9138cd38e82a78b5895b0e606d5d6">getForwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *forwardSlice, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> filter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;})</td></tr>
<tr class="memdesc:ab3c9138cd38e82a78b5895b0e606d5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>forwardSlice</code> with the computed forward slice (i.e.  <a href="#ab3c9138cd38e82a78b5895b0e606d5d6">More...</a><br /></td></tr>
<tr class="separator:ab3c9138cd38e82a78b5895b0e606d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40741d257063d17fe7e8da3ebea443a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40741d257063d17fe7e8da3ebea443a3">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *backwardSlice, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> filter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;})</td></tr>
<tr class="memdesc:a40741d257063d17fe7e8da3ebea443a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>backwardSlice</code> with the computed backward slice (i.e.  <a href="#a40741d257063d17fe7e8da3ebea443a3">More...</a><br /></td></tr>
<tr class="separator:a40741d257063d17fe7e8da3ebea443a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7beb62292ad20dc8c447387c371f9a2"><td class="memItemLeft" align="right" valign="top">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae7beb62292ad20dc8c447387c371f9a2">getSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> backwardFilter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;}, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> forwardFilter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;})</td></tr>
<tr class="memdesc:ae7beb62292ad20dc8c447387c371f9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively computes backward slices and forward slices until a fixed point is reached.  <a href="#ae7beb62292ad20dc8c447387c371f9a2">More...</a><br /></td></tr>
<tr class="separator:ae7beb62292ad20dc8c447387c371f9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5deb263dc3ca56a8c5ae015cba4af"><td class="memItemLeft" align="right" valign="top">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a67f5deb263dc3ca56a8c5ae015cba4af">topologicalSort</a> (const llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;toSort)</td></tr>
<tr class="memdesc:a67f5deb263dc3ca56a8c5ae015cba4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-root DAG topological sort.  <a href="#a67f5deb263dc3ca56a8c5ae015cba4af">More...</a><br /></td></tr>
<tr class="separator:a67f5deb263dc3ca56a8c5ae015cba4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e7b35354627941316244640aa4392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a991e7b35354627941316244640aa4392">getLoopIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a991e7b35354627941316244640aa4392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one.  <a href="#a991e7b35354627941316244640aa4392">More...</a><br /></td></tr>
<tr class="separator:a991e7b35354627941316244640aa4392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1ccc3f1298ad67bd387a804aa82fa65">getEnclosingAffineForAndIfOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *ops)</td></tr>
<tr class="memdesc:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> or <code>affine.if</code> operation to the innermost one.  <a href="#ad1ccc3f1298ad67bd387a804aa82fa65">More...</a><br /></td></tr>
<tr class="separator:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2db02976864d1e32f9f500d9d719d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2db02976864d1e32f9f500d9d719d5a">getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac2db02976864d1e32f9f500d9d719d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <a href="#ac2db02976864d1e32f9f500d9d719d5a">More...</a><br /></td></tr>
<tr class="separator:ac2db02976864d1e32f9f500d9d719d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4052bdb6ce4bde76e5de054805848162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4052bdb6ce4bde76e5de054805848162">getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a4052bdb6ce4bde76e5de054805848162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <a href="#a4052bdb6ce4bde76e5de054805848162">More...</a><br /></td></tr>
<tr class="separator:a4052bdb6ce4bde76e5de054805848162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dfa6bfaaa9a03dcbfdaeee28dc80ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68dfa6bfaaa9a03dcbfdaeee28dc80ab">getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *dependenceConstraints, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:a68dfa6bfaaa9a03dcbfdaeee28dc80ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <a href="#a68dfa6bfaaa9a03dcbfdaeee28dc80ab">More...</a><br /></td></tr>
<tr class="separator:a68dfa6bfaaa9a03dcbfdaeee28dc80ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a5a18c2ea856568b0fbfb272e2b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa68a5a18c2ea856568b0fbfb272e2b0d">computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsB, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classunsigned.html">unsigned</a> numCommonLoops, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:aa68a5a18c2ea856568b0fbfb272e2b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB'.  <a href="#aa68a5a18c2ea856568b0fbfb272e2b0d">More...</a><br /></td></tr>
<tr class="separator:aa68a5a18c2ea856568b0fbfb272e2b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8c76f66345aba4e6cabb250bf7699c1">insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:aa8c76f66345aba4e6cabb250bf7699c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <a href="#aa8c76f66345aba4e6cabb250bf7699c1">More...</a><br /></td></tr>
<tr class="separator:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bd0c019a961c60a1fd09225b7dcd3be">getMemRefSizeInBytes</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> memRefType)</td></tr>
<tr class="memdesc:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of memref data in bytes if it's statically shaped, None otherwise.  <a href="#a5bd0c019a961c60a1fd09225b7dcd3be">More...</a><br /></td></tr>
<tr class="separator:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer &gt; </td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, bool <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>=true)</td></tr>
<tr class="memdesc:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <a href="#afdb92b40e131a0a6bd17fc39f1f3e371">More...</a><br /></td></tr>
<tr class="separator:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9ce1eb0663c1448ebc1bbeccc2b6bcf">getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;A, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;B)</td></tr>
<tr class="memdesc:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <a href="#af9ce1eb0663c1448ebc1bbeccc2b6bcf">More...</a><br /></td></tr>
<tr class="separator:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670cd81ab396ba425cd0063d516b9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1670cd81ab396ba425cd0063d516b9a9">getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a1670cd81ab396ba425cd0063d516b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <a href="#a1670cd81ab396ba425cd0063d516b9a9">More...</a><br /></td></tr>
<tr class="separator:a1670cd81ab396ba425cd0063d516b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9c4fc904589c35cd742b2f96393ee2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d9c4fc904589c35cd742b2f96393ee2">isLoopParallel</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a0d9c4fc904589c35cd742b2f96393ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if `forOp' is a parallel loop.  <a href="#a0d9c4fc904589c35cd742b2f96393ee2">More...</a><br /></td></tr>
<tr class="separator:a0d9c4fc904589c35cd742b2f96393ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1cab5a79af53f1bc236af0c5ba5e7b54">simplifyIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference.  <a href="#a1cab5a79af53f1bc236af0c5ba5e7b54">More...</a><br /></td></tr>
<tr class="separator:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde4236d0e9455a3983834b085f73224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abde4236d0e9455a3983834b085f73224">getInnermostCommonLoopDepth</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *surroundingLoops=nullptr)</td></tr>
<tr class="memdesc:abde4236d0e9455a3983834b085f73224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innermost common loop depth for the set of operations in 'ops'.  <a href="#abde4236d0e9455a3983834b085f73224">More...</a><br /></td></tr>
<tr class="separator:abde4236d0e9455a3983834b085f73224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dbba661e76a7e45c145e652fbcc853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9dbba661e76a7e45c145e652fbcc853">expandAffineExpr</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dimValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> symbolValues)</td></tr>
<tr class="memdesc:ab9dbba661e76a7e45c145e652fbcc853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values.  <a href="#ab9dbba661e76a7e45c145e652fbcc853">More...</a><br /></td></tr>
<tr class="separator:ab9dbba661e76a7e45c145e652fbcc853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c2a14651ef626d0d9fcee46698032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae58c2a14651ef626d0d9fcee46698032">expandAffineMap</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> affineMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae58c2a14651ef626d0d9fcee46698032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp).  <a href="#ae58c2a14651ef626d0d9fcee46698032">More...</a><br /></td></tr>
<tr class="separator:ae58c2a14651ef626d0d9fcee46698032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8c7352bef2e6ad933b0342ac148d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a8c7352bef2e6ad933b0342ac148d83">populateAffineToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a0a8c7352bef2e6ad933b0342ac148d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow.  <a href="#a0a8c7352bef2e6ad933b0342ac148d83">More...</a><br /></td></tr>
<tr class="separator:a0a8c7352bef2e6ad933b0342ac148d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028a748bab4727e3a069877feeb334a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a028a748bab4727e3a069877feeb334a0">populateAffineToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a028a748bab4727e3a069877feeb334a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect.  <a href="#a028a748bab4727e3a069877feeb334a0">More...</a><br /></td></tr>
<tr class="separator:a028a748bab4727e3a069877feeb334a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdf4bbbb9eb7a9678bd98d122b837cbd">lowerAffineLowerBound</a> (AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the lower bound of the given affine loop using standard arithmetic operations.  <a href="#afdf4bbbb9eb7a9678bd98d122b837cbd">More...</a><br /></td></tr>
<tr class="separator:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d924b9762c352e82e8fe0fb1e222288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d924b9762c352e82e8fe0fb1e222288">lowerAffineUpperBound</a> (AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a2d924b9762c352e82e8fe0fb1e222288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the upper bound of the given affine loop using standard arithmetic operations.  <a href="#a2d924b9762c352e82e8fe0fb1e222288">More...</a><br /></td></tr>
<tr class="separator:a2d924b9762c352e82e8fe0fb1e222288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09ce34232ab009ce688d7cdc63695a8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae09ce34232ab009ce688d7cdc63695a8">createLowerAffinePass</a> ()</td></tr>
<tr class="memdesc:ae09ce34232ab009ce688d7cdc63695a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives).  <a href="#ae09ce34232ab009ce688d7cdc63695a8">More...</a><br /></td></tr>
<tr class="separator:ae09ce34232ab009ce688d7cdc63695a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f580b687935c80164683be626191011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f580b687935c80164683be626191011">populateArmNeonToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6f580b687935c80164683be626191011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from theArmNeon dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a6f580b687935c80164683be626191011">More...</a><br /></td></tr>
<tr class="separator:a6f580b687935c80164683be626191011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cb4a6db7cb734a5397d6bd8ba95ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2cb4a6db7cb734a5397d6bd8ba95ed0">populateArmSVEToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac2cb4a6db7cb734a5397d6bd8ba95ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the ArmSVE dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#ac2cb4a6db7cb734a5397d6bd8ba95ed0">More...</a><br /></td></tr>
<tr class="separator:ac2cb4a6db7cb734a5397d6bd8ba95ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa49d15d05958ebff1ab8aac3e55cfc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4fa49d15d05958ebff1ab8aac3e55cfc">createConvertAsyncToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a4fa49d15d05958ebff1ab8aac3e55cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Async operations to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#a4fa49d15d05958ebff1ab8aac3e55cfc">More...</a><br /></td></tr>
<tr class="separator:a4fa49d15d05958ebff1ab8aac3e55cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1a01ce69d98daf0f1ff18f3382afef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7c1a01ce69d98daf0f1ff18f3382afef">populateAVX512ToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7c1a01ce69d98daf0f1ff18f3382afef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the AVX512 dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a7c1a01ce69d98daf0f1ff18f3382afef">More...</a><br /></td></tr>
<tr class="separator:a7c1a01ce69d98daf0f1ff18f3382afef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8557dc4a578cb4d61bd87ab914e6c3f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af8557dc4a578cb4d61bd87ab914e6c3f">createGpuToLLVMConversionPass</a> (StringRef gpuBinaryAnnotation=&quot;&quot;)</td></tr>
<tr class="memdesc:af8557dc4a578cb4d61bd87ab914e6c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert a gpu.launch_func operation into a sequence of GPU runtime calls.  <a href="#af8557dc4a578cb4d61bd87ab914e6c3f">More...</a><br /></td></tr>
<tr class="separator:af8557dc4a578cb4d61bd87ab914e6c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676c79a418c8cea488a81ca033f1bfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad676c79a418c8cea488a81ca033f1bfa">populateGpuToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, StringRef gpuBinaryAnnotation)</td></tr>
<tr class="memdesc:ad676c79a418c8cea488a81ca033f1bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#ad676c79a418c8cea488a81ca033f1bfa">More...</a><br /></td></tr>
<tr class="separator:ad676c79a418c8cea488a81ca033f1bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68415bea06e1d49a93ff20fd3c015fdf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68415bea06e1d49a93ff20fd3c015fdf">createConvertGPUKernelToBlobPass</a> (<a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">LoweringCallback</a> loweringCallback, <a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">BlobGenerator</a> blobGenerator, StringRef triple, StringRef targetChip, StringRef features, StringRef gpuBinaryAnnotation)</td></tr>
<tr class="memdesc:a68415bea06e1d49a93ff20fd3c015fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert kernel functions into GPU target object blobs.  <a href="#a68415bea06e1d49a93ff20fd3c015fdf">More...</a><br /></td></tr>
<tr class="separator:a68415bea06e1d49a93ff20fd3c015fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa896c9229c786edc4a7970b960b208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fa896c9229c786edc4a7970b960b208">configureGpuToNVVMConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a7fa896c9229c786edc4a7970b960b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="#a7fa896c9229c786edc4a7970b960b208">More...</a><br /></td></tr>
<tr class="separator:a7fa896c9229c786edc4a7970b960b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb104ff278ae6a462a7e4339637f405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2cb104ff278ae6a462a7e4339637f405">populateGpuToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2cb104ff278ae6a462a7e4339637f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="#a2cb104ff278ae6a462a7e4339637f405">More...</a><br /></td></tr>
<tr class="separator:a2cb104ff278ae6a462a7e4339637f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62610c48d7b8e08dfd726bdb51d433e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad62610c48d7b8e08dfd726bdb51d433e">createLowerGpuOpsToNVVMOpsPass</a> (<a class="el" href="classunsigned.html">unsigned</a> indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>)</td></tr>
<tr class="memdesc:ad62610c48d7b8e08dfd726bdb51d433e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts.  <a href="#ad62610c48d7b8e08dfd726bdb51d433e">More...</a><br /></td></tr>
<tr class="separator:ad62610c48d7b8e08dfd726bdb51d433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22a5016f3fa28ed9fb7b40a623953fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab22a5016f3fa28ed9fb7b40a623953fe">populateGpuToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab22a5016f3fa28ed9fb7b40a623953fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="#ab22a5016f3fa28ed9fb7b40a623953fe">More...</a><br /></td></tr>
<tr class="separator:ab22a5016f3fa28ed9fb7b40a623953fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a65c490624b02da7c5cb78aa071e0aa2a">configureGpuToROCDLConversionLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a65c490624b02da7c5cb78aa071e0aa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="#a65c490624b02da7c5cb78aa071e0aa2a">More...</a><br /></td></tr>
<tr class="separator:a65c490624b02da7c5cb78aa071e0aa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c22a8ed14d48069b4c811e1f61727e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31c22a8ed14d48069b4c811e1f61727e">createLowerGpuOpsToROCDLOpsPass</a> (<a class="el" href="classunsigned.html">unsigned</a> indexBitwidth=<a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a>)</td></tr>
<tr class="memdesc:a31c22a8ed14d48069b4c811e1f61727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts.  <a href="#a31c22a8ed14d48069b4c811e1f61727e">More...</a><br /></td></tr>
<tr class="separator:a31c22a8ed14d48069b4c811e1f61727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d6ea0d1589ae7c3f029568e10156d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7d6ea0d1589ae7c3f029568e10156d8">populateGPUToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:af7d6ea0d1589ae7c3f029568e10156d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops.  <a href="#af7d6ea0d1589ae7c3f029568e10156d8">More...</a><br /></td></tr>
<tr class="separator:af7d6ea0d1589ae7c3f029568e10156d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98081470e80af33268acc9e7463f4af1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98081470e80af33268acc9e7463f4af1">createConvertGPUToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a98081470e80af33268acc9e7463f4af1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert GPU Ops to SPIR-V ops.  <a href="#a98081470e80af33268acc9e7463f4af1">More...</a><br /></td></tr>
<tr class="separator:a98081470e80af33268acc9e7463f4af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85822fd77ee16dc5df2c93c9f56b4bf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa85822fd77ee16dc5df2c93c9f56b4bf">createConvertVulkanLaunchFuncToVulkanCallsPass</a> ()</td></tr>
<tr class="separator:aa85822fd77ee16dc5df2c93c9f56b4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad39c9d3321b2f5f4aee088b02b535f9b">createConvertGpuLaunchFuncToVulkanLaunchFuncPass</a> ()</td></tr>
<tr class="separator:ad39c9d3321b2f5f4aee088b02b535f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0a617ff9771ea0f0e89ff319e236f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb0a617ff9771ea0f0e89ff319e236f8">populateLinalgToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:abb0a617ff9771ea0f0e89ff319e236f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#abb0a617ff9771ea0f0e89ff319e236f8">More...</a><br /></td></tr>
<tr class="separator:abb0a617ff9771ea0f0e89ff319e236f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81cd941f78768bc9dd0cbaca49d45a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d81cd941f78768bc9dd0cbaca49d45a">createConvertLinalgToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a5d81cd941f78768bc9dd0cbaca49d45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the LLVMIR dialect.  <a href="#a5d81cd941f78768bc9dd0cbaca49d45a">More...</a><br /></td></tr>
<tr class="separator:a5d81cd941f78768bc9dd0cbaca49d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ab10075190617391facb4618b29149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9ab10075190617391facb4618b29149">populateLinalgToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac9ab10075190617391facb4618b29149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating Linalg ops to SPIR-V ops.  <a href="#ac9ab10075190617391facb4618b29149">More...</a><br /></td></tr>
<tr class="separator:ac9ab10075190617391facb4618b29149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7621ad17eef3b7af217a900ae413cfa5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7621ad17eef3b7af217a900ae413cfa5">createLinalgToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a7621ad17eef3b7af217a900ae413cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert Linalg ops to SPIR-V ops.  <a href="#a7621ad17eef3b7af217a900ae413cfa5">More...</a><br /></td></tr>
<tr class="separator:a7621ad17eef3b7af217a900ae413cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb33f39a4ad0d4d52396f132bee84cf">createConvertLinalgToStandardPass</a> ()</td></tr>
<tr class="memdesc:aefb33f39a4ad0d4d52396f132bee84cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the Standard dialect.  <a href="#aefb33f39a4ad0d4d52396f132bee84cf">More...</a><br /></td></tr>
<tr class="separator:aefb33f39a4ad0d4d52396f132bee84cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a78c19d5b35b9e7a4f83bf5a880a744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9a78c19d5b35b9e7a4f83bf5a880a744">populateOpenMPToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9a78c19d5b35b9e7a4f83bf5a880a744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a9a78c19d5b35b9e7a4f83bf5a880a744">More...</a><br /></td></tr>
<tr class="separator:a9a78c19d5b35b9e7a4f83bf5a880a744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53acb3c78e9695b7e30e1e9efec285a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53acb3c78e9695b7e30e1e9efec285a">createConvertOpenMPToLLVMPass</a> ()</td></tr>
<tr class="memdesc:ae53acb3c78e9695b7e30e1e9efec285a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert OpenMP operations to the LLVMIR dialect.  <a href="#ae53acb3c78e9695b7e30e1e9efec285a">More...</a><br /></td></tr>
<tr class="separator:ae53acb3c78e9695b7e30e1e9efec285a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882e712b4e426905d73c1c74bd0f353"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af882e712b4e426905d73c1c74bd0f353">createPDLToPDLInterpPass</a> ()</td></tr>
<tr class="memdesc:af882e712b4e426905d73c1c74bd0f353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a pass to convert PDL ops to PDL interpreter ops.  <a href="#af882e712b4e426905d73c1c74bd0f353">More...</a><br /></td></tr>
<tr class="separator:af882e712b4e426905d73c1c74bd0f353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe63747d3d90805543a5697ca8aca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addbe63747d3d90805543a5697ca8aca9">convertAffineLoopNestToGPULaunch</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> numBlockDims, <a class="el" href="classunsigned.html">unsigned</a> numThreadDims)</td></tr>
<tr class="memdesc:addbe63747d3d90805543a5697ca8aca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation.  <a href="#addbe63747d3d90805543a5697ca8aca9">More...</a><br /></td></tr>
<tr class="separator:addbe63747d3d90805543a5697ca8aca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4df81f80f7ca782e9d0486a651e3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a4df81f80f7ca782e9d0486a651e3ac">populateParallelLoopToGPUPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a2a4df81f80f7ca782e9d0486a651e3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list.  <a href="#a2a4df81f80f7ca782e9d0486a651e3ac">More...</a><br /></td></tr>
<tr class="separator:a2a4df81f80f7ca782e9d0486a651e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d59b73ef695a82338e96055101c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af01d59b73ef695a82338e96055101c16">configureParallelLoopToGPULegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:af01d59b73ef695a82338e96055101c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal.  <a href="#af01d59b73ef695a82338e96055101c16">More...</a><br /></td></tr>
<tr class="separator:af01d59b73ef695a82338e96055101c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9e1cdfc040345b0970e86449810d94"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5b9e1cdfc040345b0970e86449810d94">createAffineForToGPUPass</a> (<a class="el" href="classunsigned.html">unsigned</a> numBlockDims, <a class="el" href="classunsigned.html">unsigned</a> numThreadDims)</td></tr>
<tr class="memdesc:a5b9e1cdfc040345b0970e86449810d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that converts loop nests into GPU kernels.  <a href="#a5b9e1cdfc040345b0970e86449810d94">More...</a><br /></td></tr>
<tr class="separator:a5b9e1cdfc040345b0970e86449810d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4007a1734d8ad9d47b3dce58973adb40"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4007a1734d8ad9d47b3dce58973adb40">createAffineForToGPUPass</a> ()</td></tr>
<tr class="separator:a4007a1734d8ad9d47b3dce58973adb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2f36107d7ffc6c1f873c746385d9de0">createParallelLoopToGpuPass</a> ()</td></tr>
<tr class="memdesc:aa2f36107d7ffc6c1f873c746385d9de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts scf.parallel operations into a gpu.launch operation.  <a href="#aa2f36107d7ffc6c1f873c746385d9de0">More...</a><br /></td></tr>
<tr class="separator:aa2f36107d7ffc6c1f873c746385d9de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd4071e05737fd95c2e25e89bc4a96"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfd4071e05737fd95c2e25e89bc4a96">createConvertSCFToOpenMPPass</a> ()</td></tr>
<tr class="separator:addfd4071e05737fd95c2e25e89bc4a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae43dd9bce38e340317494194d891da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aae43dd9bce38e340317494194d891da8">populateSCFToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;scfToSPIRVContext, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:aae43dd9bce38e340317494194d891da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect.  <a href="#aae43dd9bce38e340317494194d891da8">More...</a><br /></td></tr>
<tr class="separator:aae43dd9bce38e340317494194d891da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca74253af65583026863be8081bbd84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ca74253af65583026863be8081bbd84">populateLoopToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a1ca74253af65583026863be8081bbd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the Standard dialect, in particular convert structured control flow into CFG branch-based control flow.  <a href="#a1ca74253af65583026863be8081bbd84">More...</a><br /></td></tr>
<tr class="separator:a1ca74253af65583026863be8081bbd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bcd86978ddc5c8c9eb55e995fa7d69"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa7bcd86978ddc5c8c9eb55e995fa7d69">createLowerToCFGPass</a> ()</td></tr>
<tr class="memdesc:aa7bcd86978ddc5c8c9eb55e995fa7d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert scf.for, scf.if and loop.terminator ops to CFG.  <a href="#aa7bcd86978ddc5c8c9eb55e995fa7d69">More...</a><br /></td></tr>
<tr class="separator:aa7bcd86978ddc5c8c9eb55e995fa7d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456e7de34f75066daa48f695a9aba0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a456e7de34f75066daa48f695a9aba0dc">populateShapeToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:a456e7de34f75066daa48f695a9aba0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ecc9afba558cb026032d0453a7c95"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc9ecc9afba558cb026032d0453a7c95">createConvertShapeToStandardPass</a> ()</td></tr>
<tr class="separator:abc9ecc9afba558cb026032d0453a7c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0412428031c74e126cc1967995b459f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0412428031c74e126cc1967995b459f1">populateConvertShapeConstraintsConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:a0412428031c74e126cc1967995b459f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476fec80d5042ee5602a8b7b97d8a023"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a476fec80d5042ee5602a8b7b97d8a023">createConvertShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:a476fec80d5042ee5602a8b7b97d8a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8075944125730fed529e3b93dcfed5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8075944125730fed529e3b93dcfed5b">encodeBindAttribute</a> (<a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> module)</td></tr>
<tr class="memdesc:ab8075944125730fed529e3b93dcfed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes global variable's descriptor set and binding into its name if they both exist.  <a href="#ab8075944125730fed529e3b93dcfed5b">More...</a><br /></td></tr>
<tr class="separator:ab8075944125730fed529e3b93dcfed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66c52897a19a19fdec8d7022372b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aae66c52897a19a19fdec8d7022372b7d">populateSPIRVToLLVMTypeConversion</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:aae66c52897a19a19fdec8d7022372b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates type conversions with additional SPIR-V types.  <a href="#aae66c52897a19a19fdec8d7022372b7d">More...</a><br /></td></tr>
<tr class="separator:aae66c52897a19a19fdec8d7022372b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a23ded9ba7f08763bf94ef83ed85778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a23ded9ba7f08763bf94ef83ed85778">populateSPIRVToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a4a23ded9ba7f08763bf94ef83ed85778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a4a23ded9ba7f08763bf94ef83ed85778">More...</a><br /></td></tr>
<tr class="separator:a4a23ded9ba7f08763bf94ef83ed85778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d44d746cb22b666fef3a65eff78cfdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d44d746cb22b666fef3a65eff78cfdd">populateSPIRVToLLVMFunctionConversionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0d44d746cb22b666fef3a65eff78cfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a0d44d746cb22b666fef3a65eff78cfdd">More...</a><br /></td></tr>
<tr class="separator:a0d44d746cb22b666fef3a65eff78cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae585d82693c911213445e9f79d1f0534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae585d82693c911213445e9f79d1f0534">populateSPIRVToLLVMModuleConversionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae585d82693c911213445e9f79d1f0534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#ae585d82693c911213445e9f79d1f0534">More...</a><br /></td></tr>
<tr class="separator:ae585d82693c911213445e9f79d1f0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712e219558e911fe489fefff81dd8365"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a712e219558e911fe489fefff81dd8365">createLowerHostCodeToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a712e219558e911fe489fefff81dd8365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to emulate <code>gpu.launch_func</code> call in <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and lower the host module code to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a712e219558e911fe489fefff81dd8365">More...</a><br /></td></tr>
<tr class="separator:a712e219558e911fe489fefff81dd8365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd8a621caca1db19e02a6933d28fb3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a41cd8a621caca1db19e02a6933d28fb3">createConvertSPIRVToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a41cd8a621caca1db19e02a6933d28fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert SPIR-V operations to the LLVMIR dialect.  <a href="#a41cd8a621caca1db19e02a6933d28fb3">More...</a><br /></td></tr>
<tr class="separator:a41cd8a621caca1db19e02a6933d28fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f16fcf3a83d26d5a59da3bf0138ca24">structFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="#a6f16fcf3a83d26d5a59da3bf0138ca24">More...</a><br /></td></tr>
<tr class="separator:a6f16fcf3a83d26d5a59da3bf0138ca24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d145c5b783b4fe092fc78fd6879ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a173d145c5b783b4fe092fc78fd6879ec">barePtrFuncArgTypeConverter</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a173d145c5b783b4fe092fc78fd6879ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to convert function argument types.  <a href="#a173d145c5b783b4fe092fc78fd6879ec">More...</a><br /></td></tr>
<tr class="separator:a173d145c5b783b4fe092fc78fd6879ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b9d5db7551c34987f32f7f15c67d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66b9d5db7551c34987f32f7f15c67d4c">populateStdToLLVMMemoryConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a66b9d5db7551c34987f32f7f15c67d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding non-memory-related operations and FuncOp.  <a href="#a66b9d5db7551c34987f32f7f15c67d4c">More...</a><br /></td></tr>
<tr class="separator:a66b9d5db7551c34987f32f7f15c67d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272d602be4199d577e0a2e42788c50d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac272d602be4199d577e0a2e42788c50d">populateStdToLLVMNonMemoryConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac272d602be4199d577e0a2e42788c50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding the memory-related operations.  <a href="#ac272d602be4199d577e0a2e42788c50d">More...</a><br /></td></tr>
<tr class="separator:ac272d602be4199d577e0a2e42788c50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bd1246643bea508b76bd6ce996a957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a37bd1246643bea508b76bd6ce996a957">populateStdToLLVMFuncOpConversionPattern</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a37bd1246643bea508b76bd6ce996a957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#a37bd1246643bea508b76bd6ce996a957">More...</a><br /></td></tr>
<tr class="separator:a37bd1246643bea508b76bd6ce996a957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595c6a19148f86b48b2121b201475618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a595c6a19148f86b48b2121b201475618">populateStdToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a595c6a19148f86b48b2121b201475618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the patterns to convert from the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a595c6a19148f86b48b2121b201475618">More...</a><br /></td></tr>
<tr class="separator:a595c6a19148f86b48b2121b201475618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649d6d11fb7af43b251d8664ed0202a8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a649d6d11fb7af43b251d8664ed0202a8">createLowerToLLVMPass</a> (const <a class="el" href="structmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1LowerToLLVMOptions.html#ac14fc13dfbd07ab39707b8400195db85">LowerToLLVMOptions::getDefaultOptions</a>())</td></tr>
<tr class="memdesc:a649d6d11fb7af43b251d8664ed0202a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert the Standard dialect into the LLVMIR dialect.  <a href="#a649d6d11fb7af43b251d8664ed0202a8">More...</a><br /></td></tr>
<tr class="separator:a649d6d11fb7af43b251d8664ed0202a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1de38d84e16c5c7e869995fb1c3605b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1de38d84e16c5c7e869995fb1c3605b">populateStandardToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad1de38d84e16c5c7e869995fb1c3605b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating StandardOps to SPIR-V ops.  <a href="#ad1de38d84e16c5c7e869995fb1c3605b">More...</a><br /></td></tr>
<tr class="separator:ad1de38d84e16c5c7e869995fb1c3605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac4da050bc6b23d395d3480f9dfae8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ac4da050bc6b23d395d3480f9dfae8a">populateStdLegalizationPatternsForSPIRVLowering</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6ac4da050bc6b23d395d3480f9dfae8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list patterns to legalize ops that are not directly lowered to SPIR-V.  <a href="#a6ac4da050bc6b23d395d3480f9dfae8a">More...</a><br /></td></tr>
<tr class="separator:a6ac4da050bc6b23d395d3480f9dfae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374133dc1b7dbc57586ad4cd57308ebb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a374133dc1b7dbc57586ad4cd57308ebb">createConvertStandardToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a374133dc1b7dbc57586ad4cd57308ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert StandardOps to SPIR-V ops.  <a href="#a374133dc1b7dbc57586ad4cd57308ebb">More...</a><br /></td></tr>
<tr class="separator:a374133dc1b7dbc57586ad4cd57308ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8665adb3fa2ac64504cfff30192ecb5e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8665adb3fa2ac64504cfff30192ecb5e">createLegalizeStdOpsForSPIRVLoweringPass</a> ()</td></tr>
<tr class="memdesc:a8665adb3fa2ac64504cfff30192ecb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to legalize ops that are not directly lowered to SPIR-V.  <a href="#a8665adb3fa2ac64504cfff30192ecb5e">More...</a><br /></td></tr>
<tr class="separator:a8665adb3fa2ac64504cfff30192ecb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eaf09c739bbea77d7d3bb88b07a559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1eaf09c739bbea77d7d3bb88b07a559">populateVectorToLLVMMatrixConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae1eaf09c739bbea77d7d3bb88b07a559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Matrix.html" title="This is a simple class to represent a resizable matrix. ">Matrix</a> Intrinsics.  <a href="#ae1eaf09c739bbea77d7d3bb88b07a559">More...</a><br /></td></tr>
<tr class="separator:ae1eaf09c739bbea77d7d3bb88b07a559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf243b415be4cf26241baecd91390df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abaf243b415be4cf26241baecd91390df">populateVectorToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, bool reassociateFPReductions=false, bool enableIndexOptimizations=true)</td></tr>
<tr class="memdesc:abaf243b415be4cf26241baecd91390df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#abaf243b415be4cf26241baecd91390df">More...</a><br /></td></tr>
<tr class="separator:abaf243b415be4cf26241baecd91390df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d0c2f42ef94e822f398d917b39184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa5d0c2f42ef94e822f398d917b39184">createConvertVectorToLLVMPass</a> (const <a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a>())</td></tr>
<tr class="memdesc:afa5d0c2f42ef94e822f398d917b39184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert vector operations to the LLVMIR dialect.  <a href="#afa5d0c2f42ef94e822f398d917b39184">More...</a><br /></td></tr>
<tr class="separator:afa5d0c2f42ef94e822f398d917b39184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794a7c16b04bc9cb75603da29f2444a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8794a7c16b04bc9cb75603da29f2444a">populateVectorToROCDLConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a8794a7c16b04bc9cb75603da29f2444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>.  <a href="#a8794a7c16b04bc9cb75603da29f2444a">More...</a><br /></td></tr>
<tr class="separator:a8794a7c16b04bc9cb75603da29f2444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2e8d8175dd430cb8048a29596d6ce3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c2e8d8175dd430cb8048a29596d6ce3">createConvertVectorToROCDLPass</a> ()</td></tr>
<tr class="memdesc:a4c2e8d8175dd430cb8048a29596d6ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert vector operations to the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect.  <a href="#a4c2e8d8175dd430cb8048a29596d6ce3">More...</a><br /></td></tr>
<tr class="separator:a4c2e8d8175dd430cb8048a29596d6ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542b1f7e2ff91696f54fad650bfa71ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a542b1f7e2ff91696f54fad650bfa71ee">populateVectorToSCFConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:a542b1f7e2ff91696f54fad650bfa71ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + std.  <a href="#a542b1f7e2ff91696f54fad650bfa71ee">More...</a><br /></td></tr>
<tr class="separator:a542b1f7e2ff91696f54fad650bfa71ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5c71e471d7d8cdda288a27d1ae75642">createConvertVectorToSCFPass</a> (const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>())</td></tr>
<tr class="memdesc:ac5c71e471d7d8cdda288a27d1ae75642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert a subset of vector ops to SCF.  <a href="#ac5c71e471d7d8cdda288a27d1ae75642">More...</a><br /></td></tr>
<tr class="separator:ac5c71e471d7d8cdda288a27d1ae75642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e6faa1f5b7ff8d09e45e83a39b86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab65e6faa1f5b7ff8d09e45e83a39b86d">populateVectorToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab65e6faa1f5b7ff8d09e45e83a39b86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="#ab65e6faa1f5b7ff8d09e45e83a39b86d">More...</a><br /></td></tr>
<tr class="separator:ab65e6faa1f5b7ff8d09e45e83a39b86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e215016b82bc3a02bddb450f68fdaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a30e215016b82bc3a02bddb450f68fdaf">createConvertVectorToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:a30e215016b82bc3a02bddb450f68fdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops.  <a href="#a30e215016b82bc3a02bddb450f68fdaf">More...</a><br /></td></tr>
<tr class="separator:a30e215016b82bc3a02bddb450f68fdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa36b5164871eaf1d6423cd0a2eb4e4fd">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code> or is a region argument for such an op.  <a href="#aa36b5164871eaf1d6423cd0a2eb4e4fd">More...</a><br /></td></tr>
<tr class="separator:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e447f320894cc02bbaeff66dd31ccee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e447f320894cc02bbaeff66dd31ccee">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a9e447f320894cc02bbaeff66dd31ccee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <code>AffineScope</code>.  <a href="#a9e447f320894cc02bbaeff66dd31ccee">More...</a><br /></td></tr>
<tr class="separator:a9e447f320894cc02bbaeff66dd31ccee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31448f2e1927a26095c872bbfb4683a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31448f2e1927a26095c872bbfb4683a1">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a31448f2e1927a26095c872bbfb4683a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <code>region</code>, i.e., for all its uses in <code>region</code>.  <a href="#a31448f2e1927a26095c872bbfb4683a1">More...</a><br /></td></tr>
<tr class="separator:a31448f2e1927a26095c872bbfb4683a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f320624f15a47e5732c1142f99dc144"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f320624f15a47e5732c1142f99dc144">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a6f320624f15a47e5732c1142f99dc144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <code>AffineScope</code>.  <a href="#a6f320624f15a47e5732c1142f99dc144">More...</a><br /></td></tr>
<tr class="separator:a6f320624f15a47e5732c1142f99dc144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfdb250aa76df12c7f6a5727e7ceb4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bfdb250aa76df12c7f6a5727e7ceb4b">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a6bfdb250aa76df12c7f6a5727e7ceb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <code>region</code>, i.e., for all its uses in <code>region</code>.  <a href="#a6bfdb250aa76df12c7f6a5727e7ceb4b">More...</a><br /></td></tr>
<tr class="separator:a6bfdb250aa76df12c7f6a5727e7ceb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d0c425094498fc25bf4856eb029c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc3d0c425094498fc25bf4856eb029c8">parseDimAndSymbolList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, <a class="el" href="classunsigned.html">unsigned</a> &amp;numDims)</td></tr>
<tr class="memdesc:adc3d0c425094498fc25bf4856eb029c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses dimension and symbol list and returns true if parsing failed.  <a href="#adc3d0c425094498fc25bf4856eb029c8">More...</a><br /></td></tr>
<tr class="separator:adc3d0c425094498fc25bf4856eb029c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bde50e2368b8864c8bc070a11fdd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8bde50e2368b8864c8bc070a11fdd71">canonicalizeMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:ad8bde50e2368b8864c8bc070a11fdd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies both <code>map</code> and <code>operands</code> in-place so as to:  <a href="#ad8bde50e2368b8864c8bc070a11fdd71">More...</a><br /></td></tr>
<tr class="separator:ad8bde50e2368b8864c8bc070a11fdd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d761b15655cb81ff4b40dbf49445db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a02d761b15655cb81ff4b40dbf49445db">canonicalizeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a02d761b15655cb81ff4b40dbf49445db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps.  <a href="#a02d761b15655cb81ff4b40dbf49445db">More...</a><br /></td></tr>
<tr class="separator:a02d761b15655cb81ff4b40dbf49445db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1186a736d12d4f188f6eac3c02a11b0f"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1186a736d12d4f188f6eac3c02a11b0f">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a1186a736d12d4f188f6eac3c02a11b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a composed AffineApplyOp by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands.  <a href="#a1186a736d12d4f188f6eac3c02a11b0f">More...</a><br /></td></tr>
<tr class="separator:a1186a736d12d4f188f6eac3c02a11b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80da81dcbeeee5cc76ed25a83f10200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab80da81dcbeeee5cc76ed25a83f10200">fullyComposeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:ab80da81dcbeeee5cc76ed25a83f10200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an AffineApplyOp.  <a href="#ab80da81dcbeeee5cc76ed25a83f10200">More...</a><br /></td></tr>
<tr class="separator:ab80da81dcbeeee5cc76ed25a83f10200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd391dd6c617912e9c5e70caa5fb513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dd391dd6c617912e9c5e70caa5fb513">isForInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a0dd391dd6c617912e9c5e70caa5fb513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is the induction variable of a AffineForOp.  <a href="#a0dd391dd6c617912e9c5e70caa5fb513">More...</a><br /></td></tr>
<tr class="separator:a0dd391dd6c617912e9c5e70caa5fb513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="#a7e4957ac11a0c4d95f6a1494c808b392">More...</a><br /></td></tr>
<tr class="separator:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13093ebea6c814674ee1668daf5f81f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13093ebea6c814674ee1668daf5f81f8">extractForInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forInsts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *ivs)</td></tr>
<tr class="memdesc:a13093ebea6c814674ee1668daf5f81f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>.  <a href="#a13093ebea6c814674ee1668daf5f81f8">More...</a><br /></td></tr>
<tr class="separator:a13093ebea6c814674ee1668daf5f81f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63560e053a2ecec5eae27d99fe6d72c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a63560e053a2ecec5eae27d99fe6d72c7">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="memdesc:a63560e053a2ecec5eae27d99fe6d72c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a perfect nest of affine "for" loops, i.e.  <a href="#a63560e053a2ecec5eae27d99fe6d72c7">More...</a><br /></td></tr>
<tr class="separator:a63560e053a2ecec5eae27d99fe6d72c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0366913a08a55f407cca2775a169d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0366913a08a55f407cca2775a169d7e">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="separator:ac0366913a08a55f407cca2775a169d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a370cf9eebe697f8b1a61109360b5e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a370cf9eebe697f8b1a61109360b5e0">createSimplifyAffineStructuresPass</a> ()</td></tr>
<tr class="memdesc:a7a370cf9eebe697f8b1a61109360b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simplification pass for affine structures (maps and sets).  <a href="#a7a370cf9eebe697f8b1a61109360b5e0">More...</a><br /></td></tr>
<tr class="separator:a7a370cf9eebe697f8b1a61109360b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6822d49e5cfc93f8de6b655124dd6da"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6822d49e5cfc93f8de6b655124dd6da">createAffineLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:ad6822d49e5cfc93f8de6b655124dd6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops.  <a href="#ad6822d49e5cfc93f8de6b655124dd6da">More...</a><br /></td></tr>
<tr class="separator:ad6822d49e5cfc93f8de6b655124dd6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4e2c9a83970c5a5b838fe89beeb046"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b4e2c9a83970c5a5b838fe89beeb046">createAffineParallelizePass</a> ()</td></tr>
<tr class="memdesc:a2b4e2c9a83970c5a5b838fe89beeb046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops.  <a href="#a2b4e2c9a83970c5a5b838fe89beeb046">More...</a><br /></td></tr>
<tr class="separator:a2b4e2c9a83970c5a5b838fe89beeb046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bf3d0a1c7cbdb9df414f8f86e58531"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3bf3d0a1c7cbdb9df414f8f86e58531">createAffineLoopNormalizePass</a> ()</td></tr>
<tr class="memdesc:af3bf3d0a1c7cbdb9df414f8f86e58531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply normalization transformations to affine loop-like ops.  <a href="#af3bf3d0a1c7cbdb9df414f8f86e58531">More...</a><br /></td></tr>
<tr class="separator:af3bf3d0a1c7cbdb9df414f8f86e58531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bd90d9233f88fee90fddb8a63e6a14"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a71bd90d9233f88fee90fddb8a63e6a14">createAffineDataCopyGenerationPass</a> (<a class="el" href="classunsigned.html">unsigned</a> slowMemorySpace, <a class="el" href="classunsigned.html">unsigned</a> fastMemorySpace, <a class="el" href="classunsigned.html">unsigned</a> tagMemorySpace=0, int minDmaTransferSize=1024, uint64_t fastMemCapacityBytes=std::numeric_limits&lt; uint64_t &gt;::max())</td></tr>
<tr class="memdesc:a71bd90d9233f88fee90fddb8a63e6a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations.  <a href="#a71bd90d9233f88fee90fddb8a63e6a14">More...</a><br /></td></tr>
<tr class="separator:a71bd90d9233f88fee90fddb8a63e6a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce0e77d2011d2b90e06e51817718d59"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ce0e77d2011d2b90e06e51817718d59">createAffineDataCopyGenerationPass</a> ()</td></tr>
<tr class="memdesc:a7ce0e77d2011d2b90e06e51817718d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="#a7ce0e77d2011d2b90e06e51817718d59">More...</a><br /></td></tr>
<tr class="separator:a7ce0e77d2011d2b90e06e51817718d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea1632e318442ba6dcd15c498791cd3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ea1632e318442ba6dcd15c498791cd3">createLoopTilingPass</a> (uint64_t cacheSizeBytes)</td></tr>
<tr class="memdesc:a6ea1632e318442ba6dcd15c498791cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform tiling on loop nests.  <a href="#a6ea1632e318442ba6dcd15c498791cd3">More...</a><br /></td></tr>
<tr class="separator:a6ea1632e318442ba6dcd15c498791cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ffa270502198f1d63f696a16abe59"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa3ffa270502198f1d63f696a16abe59">createLoopTilingPass</a> ()</td></tr>
<tr class="memdesc:aaa3ffa270502198f1d63f696a16abe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="#aaa3ffa270502198f1d63f696a16abe59">More...</a><br /></td></tr>
<tr class="separator:aaa3ffa270502198f1d63f696a16abe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e1b2ed676bd820564178e64886bbfd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9e1b2ed676bd820564178e64886bbfd">createLoopUnrollPass</a> (int unrollFactor=-1, bool unrollUpToFactor=false, bool unrollFull=false, const std::function&lt; <a class="el" href="classunsigned.html">unsigned</a>(AffineForOp)&gt; &amp;getUnrollFactor=nullptr)</td></tr>
<tr class="memdesc:aa9e1b2ed676bd820564178e64886bbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unrolling pass with the provided parameters.  <a href="#aa9e1b2ed676bd820564178e64886bbfd">More...</a><br /></td></tr>
<tr class="separator:aa9e1b2ed676bd820564178e64886bbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bed21f88cd230f8184ec74c8bd19e4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a54bed21f88cd230f8184ec74c8bd19e4">createLoopUnrollAndJamPass</a> (int unrollJamFactor=-1)</td></tr>
<tr class="memdesc:a54bed21f88cd230f8184ec74c8bd19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unroll jam pass to unroll jam by the specified factor.  <a href="#a54bed21f88cd230f8184ec74c8bd19e4">More...</a><br /></td></tr>
<tr class="separator:a54bed21f88cd230f8184ec74c8bd19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f35ed77a2654a16846d52d1c49f6866"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f35ed77a2654a16846d52d1c49f6866">createSuperVectorizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; virtualVectorSize)</td></tr>
<tr class="memdesc:a6f35ed77a2654a16846d52d1c49f6866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to vectorize loops, operations and data types using a target-independent, n-D super-vector abstraction.  <a href="#a6f35ed77a2654a16846d52d1c49f6866">More...</a><br /></td></tr>
<tr class="separator:a6f35ed77a2654a16846d52d1c49f6866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7544cfaf2c45f493fa03ceec3e976eb2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7544cfaf2c45f493fa03ceec3e976eb2">createSuperVectorizePass</a> ()</td></tr>
<tr class="memdesc:a7544cfaf2c45f493fa03ceec3e976eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="#a7544cfaf2c45f493fa03ceec3e976eb2">More...</a><br /></td></tr>
<tr class="separator:a7544cfaf2c45f493fa03ceec3e976eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1784af818174409b28cc34095d17bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab1784af818174409b28cc34095d17bc0">affineParallelize</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ab1784af818174409b28cc34095d17bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces parallel affine.for op with 1-d affine.parallel op.  <a href="#ab1784af818174409b28cc34095d17bc0">More...</a><br /></td></tr>
<tr class="separator:ab1784af818174409b28cc34095d17bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bafa91f432ad40bb6246fbcbd555fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57bafa91f432ad40bb6246fbcbd555fe">hoistAffineIfOp</a> (AffineIfOp ifOp, bool *folded=nullptr)</td></tr>
<tr class="memdesc:a57bafa91f432ad40bb6246fbcbd555fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's.  <a href="#a57bafa91f432ad40bb6246fbcbd555fe">More...</a><br /></td></tr>
<tr class="separator:a57bafa91f432ad40bb6246fbcbd555fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ea06720de269b4ecd1ed463263dd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab1ea06720de269b4ecd1ed463263dd7c">vectorizeAffineLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="structllvm_1_1DenseMapInfo.html">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fastestVaryingPattern)</td></tr>
<tr class="memdesc:ab1ea06720de269b4ecd1ed463263dd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <a href="#ab1ea06720de269b4ecd1ed463263dd7c">More...</a><br /></td></tr>
<tr class="separator:ab1ea06720de269b4ecd1ed463263dd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d7280c80aed8b236533289e9d327be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4d7280c80aed8b236533289e9d327be">vectorizeAffineLoopNest</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;loops, const <a class="el" href="structmlir_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;strategy)</td></tr>
<tr class="memdesc:ae4d7280c80aed8b236533289e9d327be"><td class="mdescLeft">&#160;</td><td class="mdescRight">External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest. ">VectorizationStrategy</a> definition).  <a href="#ae4d7280c80aed8b236533289e9d327be">More...</a><br /></td></tr>
<tr class="separator:ae4d7280c80aed8b236533289e9d327be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1fe4deb3e0ecb3d92460a0ffec72e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0a1fe4deb3e0ecb3d92460a0ffec72e">normalizeAffineParallel</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:ac0a1fe4deb3e0ecb3d92460a0ffec72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a affine.parallel op so that lower bounds are 0 and steps are 1.  <a href="#ac0a1fe4deb3e0ecb3d92460a0ffec72e">More...</a><br /></td></tr>
<tr class="separator:ac0a1fe4deb3e0ecb3d92460a0ffec72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a424dd79d80784b6e20585650e2189"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99a424dd79d80784b6e20585650e2189">createAsyncParallelForPass</a> ()</td></tr>
<tr class="separator:a99a424dd79d80784b6e20585650e2189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66616cf55b8e82b53029bf262b40924e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a66616cf55b8e82b53029bf262b40924e">createAsyncParallelForPass</a> (int numWorkerThreads)</td></tr>
<tr class="separator:a66616cf55b8e82b53029bf262b40924e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72abf12aa165b47dcbe308e65b981bcf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72abf12aa165b47dcbe308e65b981bcf">createAsyncRefCountingPass</a> ()</td></tr>
<tr class="separator:a72abf12aa165b47dcbe308e65b981bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577355fd96e48e20bee59e467d111a29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a577355fd96e48e20bee59e467d111a29">createAsyncRefCountingOptimizationPass</a> ()</td></tr>
<tr class="separator:a577355fd96e48e20bee59e467d111a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d3b3bbe9e749975af2eb5358df6f5fe">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;calculate)</td></tr>
<tr class="memdesc:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">More...</a><br /></td></tr>
<tr class="separator:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7173c36d6b113dcdb0599eb672526b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">promoteToWorkgroupMemory</a> (gpu::GPUFuncOp op, <a class="el" href="classunsigned.html">unsigned</a> arg)</td></tr>
<tr class="memdesc:a7173c36d6b113dcdb0599eb672526b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a function argument to workgroup memory in the given function.  <a href="#a7173c36d6b113dcdb0599eb672526b43">More...</a><br /></td></tr>
<tr class="separator:a7173c36d6b113dcdb0599eb672526b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d787cb93ed1e8219f6cf6b2572d30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa3d787cb93ed1e8219f6cf6b2572d30f">greedilyMapParallelSCFToGPU</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:aa3d787cb93ed1e8219f6cf6b2572d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the parallel loops found in the given function to workgroups.  <a href="#aa3d787cb93ed1e8219f6cf6b2572d30f">More...</a><br /></td></tr>
<tr class="separator:aa3d787cb93ed1e8219f6cf6b2572d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b9dda21074b16b5b4c9b72449883a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a84b9dda21074b16b5b4c9b72449883a3">createGpuKernelOutliningPass</a> ()</td></tr>
<tr class="memdesc:a84b9dda21074b16b5b4c9b72449883a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function.  <a href="#a84b9dda21074b16b5b4c9b72449883a3">More...</a><br /></td></tr>
<tr class="separator:a84b9dda21074b16b5b4c9b72449883a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d51e9993163b996f97d9c444de9bff"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1d51e9993163b996f97d9c444de9bff">createGpuAsyncRegionPass</a> ()</td></tr>
<tr class="memdesc:ad1d51e9993163b996f97d9c444de9bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a function region so that GPU ops execute asynchronously.  <a href="#ad1d51e9993163b996f97d9c444de9bff">More...</a><br /></td></tr>
<tr class="separator:ad1d51e9993163b996f97d9c444de9bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfabbc14219f84bd165b16d8d3f0d2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abfabbc14219f84bd165b16d8d3f0d2be">populateGpuAllReducePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:abfabbc14219f84bd165b16d8d3f0d2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite all-reduce ops within the GPU dialect.  <a href="#abfabbc14219f84bd165b16d8d3f0d2be">More...</a><br /></td></tr>
<tr class="separator:abfabbc14219f84bd165b16d8d3f0d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6199c25bfc092bd63f31f982855e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd6199c25bfc092bd63f31f982855e1c">populateGpuRewritePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:acd6199c25bfc092bd63f31f982855e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all patterns to rewrite ops within the GPU dialect.  <a href="#acd6199c25bfc092bd63f31f982855e1c">More...</a><br /></td></tr>
<tr class="separator:acd6199c25bfc092bd63f31f982855e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9152a09d079148a1a2f40d4946f7c17"><td class="memItemLeft" align="right" valign="top">gpu::GPUFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae9152a09d079148a1a2f40d4946f7c17">outlineKernelFunc</a> (gpu::LaunchOp launchOp, StringRef kernelFnName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:ae9152a09d079148a1a2f40d4946f7c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>.  <a href="#ae9152a09d079148a1a2f40d4946f7c17">More...</a><br /></td></tr>
<tr class="separator:ae9152a09d079148a1a2f40d4946f7c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae2e212298fb235973e9d43f98849e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a18ae2e212298fb235973e9d43f98849e">sinkOperationsIntoLaunchOp</a> (gpu::LaunchOp launchOp)</td></tr>
<tr class="memdesc:a18ae2e212298fb235973e9d43f98849e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region.  <a href="#a18ae2e212298fb235973e9d43f98849e">More...</a><br /></td></tr>
<tr class="separator:a18ae2e212298fb235973e9d43f98849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54c51849e4c06810c12ec1e96b6f259"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af54c51849e4c06810c12ec1e96b6f259">createConvertElementwiseToLinalgPass</a> ()</td></tr>
<tr class="separator:af54c51849e4c06810c12ec1e96b6f259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e44d45d1d785d7118a3eff2c95baab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae5e44d45d1d785d7118a3eff2c95baab">createLinalgFoldUnitExtentDimsPass</a> ()</td></tr>
<tr class="separator:ae5e44d45d1d785d7118a3eff2c95baab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064ade44b33729c9389df10558e6e3e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a064ade44b33729c9389df10558e6e3e9">createLinalgFusionOfTensorOpsPass</a> ()</td></tr>
<tr class="separator:a064ade44b33729c9389df10558e6e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04e9e0b0d3deab87baf02639705782e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af04e9e0b0d3deab87baf02639705782e">createFoldReshapeOpsByLinearizationPass</a> ()</td></tr>
<tr class="separator:af04e9e0b0d3deab87baf02639705782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5ca0de1aea770790d0177e20d4046b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a5ca0de1aea770790d0177e20d4046b">createLinalgTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes={})</td></tr>
<tr class="separator:a0a5ca0de1aea770790d0177e20d4046b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b643d974d1e381b31c4468ed3cc44ab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7b643d974d1e381b31c4468ed3cc44ab">createLinalgTilingToParallelLoopsPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes={})</td></tr>
<tr class="separator:a7b643d974d1e381b31c4468ed3cc44ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90f2f907477a4e94ccd0f3dd4cdad97"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae90f2f907477a4e94ccd0f3dd4cdad97">createLinalgPromotionPass</a> (bool dynamicBuffers, bool useAlloca)</td></tr>
<tr class="separator:ae90f2f907477a4e94ccd0f3dd4cdad97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d8740521bec1c043bfa8f2e36c3f6d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94d8740521bec1c043bfa8f2e36c3f6d">createLinalgPromotionPass</a> ()</td></tr>
<tr class="separator:a94d8740521bec1c043bfa8f2e36c3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc31af884ed2445efac7962abbbebdd7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc31af884ed2445efac7962abbbebdd7">createConvertLinalgToLoopsPass</a> ()</td></tr>
<tr class="memdesc:adc31af884ed2445efac7962abbbebdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to scf.for loops and std.load/std.store accesses.  <a href="#adc31af884ed2445efac7962abbbebdd7">More...</a><br /></td></tr>
<tr class="separator:adc31af884ed2445efac7962abbbebdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f0386f22f7191ef34da794fbb52331"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af0f0386f22f7191ef34da794fbb52331">createConvertLinalgToParallelLoopsPass</a> ()</td></tr>
<tr class="memdesc:af0f0386f22f7191ef34da794fbb52331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to scf.parallel loops and std.load/std.store accesses.  <a href="#af0f0386f22f7191ef34da794fbb52331">More...</a><br /></td></tr>
<tr class="separator:af0f0386f22f7191ef34da794fbb52331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c92dd67a98755cd2ef9b4590197aba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99c92dd67a98755cd2ef9b4590197aba">createConvertLinalgToAffineLoopsPass</a> ()</td></tr>
<tr class="memdesc:a99c92dd67a98755cd2ef9b4590197aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses.  <a href="#a99c92dd67a98755cd2ef9b4590197aba">More...</a><br /></td></tr>
<tr class="separator:a99c92dd67a98755cd2ef9b4590197aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207e1131b41e4217e146a70bd150d803"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a207e1131b41e4217e146a70bd150d803">createLinalgBufferizePass</a> ()</td></tr>
<tr class="memdesc:a207e1131b41e4217e146a70bd150d803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations which work on tensors to use buffers instead.  <a href="#a207e1131b41e4217e146a70bd150d803">More...</a><br /></td></tr>
<tr class="separator:a207e1131b41e4217e146a70bd150d803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0016623ea2aef0f1011f6ab86c292d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac0016623ea2aef0f1011f6ab86c292d">populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:aac0016623ea2aef0f1011f6ab86c292d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops.  <a href="#aac0016623ea2aef0f1011f6ab86c292d">More...</a><br /></td></tr>
<tr class="separator:aac0016623ea2aef0f1011f6ab86c292d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913354f530de23d05fb673dc3f173925"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a913354f530de23d05fb673dc3f173925">createLinalgGeneralizationPass</a> ()</td></tr>
<tr class="memdesc:a913354f530de23d05fb673dc3f173925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to conver named Linalg operations to Linalg generic operations.  <a href="#a913354f530de23d05fb673dc3f173925">More...</a><br /></td></tr>
<tr class="separator:a913354f530de23d05fb673dc3f173925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76943f37953fdc699537f96e8cc88e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76943f37953fdc699537f96e8cc88e73">populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a76943f37953fdc699537f96e8cc88e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <a href="#a76943f37953fdc699537f96e8cc88e73">More...</a><br /></td></tr>
<tr class="separator:a76943f37953fdc699537f96e8cc88e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674e12e2081908fa2a5f013000135528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a674e12e2081908fa2a5f013000135528">populateFoldReshapeOpsByLinearizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a674e12e2081908fa2a5f013000135528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic/indexed_generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic/indexed_generic operation.  <a href="#a674e12e2081908fa2a5f013000135528">More...</a><br /></td></tr>
<tr class="separator:a674e12e2081908fa2a5f013000135528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebcf7e9ee4c9709c85fb51110677d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acebcf7e9ee4c9709c85fb51110677d91">populateLinalgTensorOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:acebcf7e9ee4c9709c85fb51110677d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <a href="#acebcf7e9ee4c9709c85fb51110677d91">More...</a><br /></td></tr>
<tr class="separator:acebcf7e9ee4c9709c85fb51110677d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad494366e45b9b08aabb18c7172ed2603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad494366e45b9b08aabb18c7172ed2603">populateLinalgFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad494366e45b9b08aabb18c7172ed2603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors.  <a href="#ad494366e45b9b08aabb18c7172ed2603">More...</a><br /></td></tr>
<tr class="separator:ad494366e45b9b08aabb18c7172ed2603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c2a7464fefab1d85cec445e487f0d0c">createSCFBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8c2a7464fefab1d85cec445e487f0d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that bufferizes the SCF dialect.  <a href="#a8c2a7464fefab1d85cec445e487f0d0c">More...</a><br /></td></tr>
<tr class="separator:a8c2a7464fefab1d85cec445e487f0d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1d49e4ae28aeaaa552466850cc5e04ec">createForLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes for loop for unrolling and vectorization.  <a href="#a1d49e4ae28aeaaa552466850cc5e04ec">More...</a><br /></td></tr>
<tr class="separator:a1d49e4ae28aeaaa552466850cc5e04ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00701d01638289dd08ec9e255076f50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad00701d01638289dd08ec9e255076f50">createParallelLoopFusionPass</a> ()</td></tr>
<tr class="memdesc:ad00701d01638289dd08ec9e255076f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses parallel loops.  <a href="#ad00701d01638289dd08ec9e255076f50">More...</a><br /></td></tr>
<tr class="separator:ad00701d01638289dd08ec9e255076f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b9f8678ec66eed9c66536834540184"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16b9f8678ec66eed9c66536834540184">createParallelLoopSpecializationPass</a> ()</td></tr>
<tr class="memdesc:a16b9f8678ec66eed9c66536834540184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that specializes parallel loop for unrolling and vectorization.  <a href="#a16b9f8678ec66eed9c66536834540184">More...</a><br /></td></tr>
<tr class="separator:a16b9f8678ec66eed9c66536834540184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376762082da3778ea351a8c9e1db5f23"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a376762082da3778ea351a8c9e1db5f23">createParallelLoopTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSize={})</td></tr>
<tr class="memdesc:a376762082da3778ea351a8c9e1db5f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which tiles innermost parallel loops.  <a href="#a376762082da3778ea351a8c9e1db5f23">More...</a><br /></td></tr>
<tr class="separator:a376762082da3778ea351a8c9e1db5f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8502dc067cc5f52028a818a810146a59"><td class="memItemLeft" align="right" valign="top">scf::ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8502dc067cc5f52028a818a810146a59">cloneWithNewYields</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, scf::ForOp loop, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newIterOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newYieldedValues, bool replaceLoopResults=true)</td></tr>
<tr class="memdesc:a8502dc067cc5f52028a818a810146a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of <code>loop</code> with <code>newIterOperands</code> added as new initialization values and <code>newYieldedValues</code> added as new yielded values.  <a href="#a8502dc067cc5f52028a818a810146a59">More...</a><br /></td></tr>
<tr class="separator:a8502dc067cc5f52028a818a810146a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4acbd7bfe2fc80c3ab32756218d9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abd4acbd7bfe2fc80c3ab32756218d9d6">outlineIfOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, scf::IfOp ifOp, FuncOp *thenFn, StringRef thenFnName, FuncOp *elseFn, StringRef elseFnName)</td></tr>
<tr class="memdesc:abd4acbd7bfe2fc80c3ab32756218d9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outline the then and/or else regions of <code>ifOp</code> as follows:  <a href="#abd4acbd7bfe2fc80c3ab32756218d9d6">More...</a><br /></td></tr>
<tr class="separator:abd4acbd7bfe2fc80c3ab32756218d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014242a015c4e9c9aa58c829af2fc4d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014242a015c4e9c9aa58c829af2fc4d4">operator+</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a014242a015c4e9c9aa58c829af2fc4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e28263eb0fcf092160b8a9e0f6ce8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f5e28263eb0fcf092160b8a9e0f6ce8">operator&lt;</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a9f5e28263eb0fcf092160b8a9e0f6ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8491b7c1cf514aa1510eb26fd5003c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8491b7c1cf514aa1510eb26fd5003c18">operator&lt;=</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a8491b7c1cf514aa1510eb26fd5003c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572d4713cebe03e129bef601d1041f0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a572d4713cebe03e129bef601d1041f0f">operator==</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a572d4713cebe03e129bef601d1041f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d0033d79ef89bd4fe840819c0e5b44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8d0033d79ef89bd4fe840819c0e5b44">operator!=</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:ab8d0033d79ef89bd4fe840819c0e5b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e7653e9cef5f155370ca0425994e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a050e7653e9cef5f155370ca0425994e9">createShapeToShapeLowering</a> ()</td></tr>
<tr class="memdesc:a050e7653e9cef5f155370ca0425994e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Standard.  <a href="#a050e7653e9cef5f155370ca0425994e9">More...</a><br /></td></tr>
<tr class="separator:a050e7653e9cef5f155370ca0425994e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae7578d528972d48e7413de4f08df04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeae7578d528972d48e7413de4f08df04">populateShapeRewritePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:aeae7578d528972d48e7413de4f08df04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the Shape dialect.  <a href="#aeae7578d528972d48e7413de4f08df04">More...</a><br /></td></tr>
<tr class="separator:aeae7578d528972d48e7413de4f08df04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eba89fba5bddc4eb0e616f6af054159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5eba89fba5bddc4eb0e616f6af054159">populateRemoveShapeConstraintsPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:a5eba89fba5bddc4eb0e616f6af054159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe31940e952ad0bd9566f70265c59a9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adfe31940e952ad0bd9566f70265c59a9">createRemoveShapeConstraintsPass</a> ()</td></tr>
<tr class="separator:adfe31940e952ad0bd9566f70265c59a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11736fc91b1321cd777e3af89bcff3c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a11736fc91b1321cd777e3af89bcff3c8">populateShapeStructuralTypeConversionsAndLegality</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a11736fc91b1321cd777e3af89bcff3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for shape dialect structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly.  <a href="#a11736fc91b1321cd777e3af89bcff3c8">More...</a><br /></td></tr>
<tr class="separator:a11736fc91b1321cd777e3af89bcff3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef79e69a6b8ca521bbf9bc4a48937e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abef79e69a6b8ca521bbf9bc4a48937e9">createShapeBufferizePass</a> ()</td></tr>
<tr class="separator:abef79e69a6b8ca521bbf9bc4a48937e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memTemplParams" colspan="2">template&lt;typename EnumClass , typename ParserType &gt; </td></tr>
<tr class="memitem:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cdbef9427aac1eeac4dbf017bae583b">parseEnumKeywordAttr</a> (EnumClass &amp;value, ParserType &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, StringRef attrName=spirv::attributeName&lt; EnumClass &gt;())</td></tr>
<tr class="memdesc:a4cdbef9427aac1eeac4dbf017bae583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>.  <a href="#a4cdbef9427aac1eeac4dbf017bae583b">More...</a><br /></td></tr>
<tr class="separator:a4cdbef9427aac1eeac4dbf017bae583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe385239da2dd1c47fa998533a19f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae6fe385239da2dd1c47fa998533a19f6">populateBuiltinFuncToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae6fe385239da2dd1c47fa998533a19f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect.  <a href="#ae6fe385239da2dd1c47fa998533a19f6">More...</a><br /></td></tr>
<tr class="separator:ae6fe385239da2dd1c47fa998533a19f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96266cfa6acb9131f4beeb8b5b4db9b4"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a96266cfa6acb9131f4beeb8b5b4db9b4">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:a96266cfa6acb9131f4beeb8b5b4db9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e134959101de052e7dbfd12610b5d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45e134959101de052e7dbfd12610b5d6">getOrCreateRanges</a> (OffsetSizeAndStrideOpInterface op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a45e134959101de052e7dbfd12610b5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of <a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> (i.e.  <a href="#a45e134959101de052e7dbfd12610b5d6">More...</a><br /></td></tr>
<tr class="separator:a45e134959101de052e7dbfd12610b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae672104d54f3fa1333ad2295d16f8985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; bool, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae672104d54f3fa1333ad2295d16f8985">computeRankReductionMask</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; originalShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; reducedShape)</td></tr>
<tr class="memdesc:ae672104d54f3fa1333ad2295d16f8985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the vector of booleans that specifies which of the entries of <code>originalShape</code> are keep to obtain <code>reducedShape</code>.  <a href="#ae672104d54f3fa1333ad2295d16f8985">More...</a><br /></td></tr>
<tr class="separator:ae672104d54f3fa1333ad2295d16f8985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701b6225d36b98c4157a1f80810d0c44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a701b6225d36b98c4157a1f80810d0c44">canFoldIntoConsumerOp</a> (MemRefCastOp castOp)</td></tr>
<tr class="memdesc:a701b6225d36b98c4157a1f80810d0c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether MemRefCastOp casts to a more dynamic version of the source memref.  <a href="#a701b6225d36b98c4157a1f80810d0c44">More...</a><br /></td></tr>
<tr class="separator:a701b6225d36b98c4157a1f80810d0c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0879aa569e9a89496a46fe007ac6885"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac0879aa569e9a89496a46fe007ac6885">canFoldIntoConsumerOp</a> (TensorCastOp castOp)</td></tr>
<tr class="memdesc:ac0879aa569e9a89496a46fe007ac6885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counterpart of <code><a class="el" href="namespacemlir.html#a701b6225d36b98c4157a1f80810d0c44" title="Determines whether MemRefCastOp casts to a more dynamic version of the source memref. ">canFoldIntoConsumerOp(MemRefCastOp castOp)</a></code> for tensors.  <a href="#ac0879aa569e9a89496a46fe007ac6885">More...</a><br /></td></tr>
<tr class="separator:ac0879aa569e9a89496a46fe007ac6885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba549e24352340ea200e631850a404e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abba549e24352340ea200e631850a404e">applyCmpPredicate</a> (CmpIPredicate predicate, const APInt &amp;lhs, const APInt &amp;rhs)</td></tr>
<tr class="memdesc:abba549e24352340ea200e631850a404e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <code>lhs</code> <code>pred</code> <code>rhs</code>, where <code>pred</code> is one of the known integer comparison predicates.  <a href="#abba549e24352340ea200e631850a404e">More...</a><br /></td></tr>
<tr class="separator:abba549e24352340ea200e631850a404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af079cfe2148bdcfafea66ac62d3407"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6af079cfe2148bdcfafea66ac62d3407">applyCmpPredicate</a> (CmpFPredicate predicate, const APFloat &amp;lhs, const APFloat &amp;rhs)</td></tr>
<tr class="memdesc:a6af079cfe2148bdcfafea66ac62d3407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <code>lhs</code> <code>pred</code> <code>rhs</code>, where <code>pred</code> is one of the known floating point comparison predicates.  <a href="#a6af079cfe2148bdcfafea66ac62d3407">More...</a><br /></td></tr>
<tr class="separator:a6af079cfe2148bdcfafea66ac62d3407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e29398e22218a20f0655d54f4ad42f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a17e29398e22218a20f0655d54f4ad42f">populateDecomposeCallGraphTypesPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;decomposer, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a17e29398e22218a20f0655d54f4ad42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>.  <a href="#a17e29398e22218a20f0655d54f4ad42f">More...</a><br /></td></tr>
<tr class="separator:a17e29398e22218a20f0655d54f4ad42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb68d915d09e2a565b90cab3e063725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5eb68d915d09e2a565b90cab3e063725">populateCallOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a5eb68d915d09e2a565b90cab3e063725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter.  <a href="#a5eb68d915d09e2a565b90cab3e063725">More...</a><br /></td></tr>
<tr class="separator:a5eb68d915d09e2a565b90cab3e063725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5908d0edfe85968d0e0931fac2662a1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5908d0edfe85968d0e0931fac2662a1a">populateBranchOpInterfaceAndReturnOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a5908d0edfe85968d0e0931fac2662a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to rewrite branch operations and <code>return</code> to use operands that have been legalized by the conversion framework.  <a href="#a5908d0edfe85968d0e0931fac2662a1a">More...</a><br /></td></tr>
<tr class="separator:a5908d0edfe85968d0e0931fac2662a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb6843e869e5285c6352a08eb16990b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3eb6843e869e5285c6352a08eb16990b">populateExpandTanhPattern</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:a3eb6843e869e5285c6352a08eb16990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b90bd952df62128137a6a57a1b45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a976b90bd952df62128137a6a57a1b45f">populateStdBufferizePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="separator:a976b90bd952df62128137a6a57a1b45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92beb0911d97bc65a57ee92a77c231ba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a92beb0911d97bc65a57ee92a77c231ba">createStdBufferizePass</a> ()</td></tr>
<tr class="memdesc:a92beb0911d97bc65a57ee92a77c231ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of std bufferization pass.  <a href="#a92beb0911d97bc65a57ee92a77c231ba">More...</a><br /></td></tr>
<tr class="separator:a92beb0911d97bc65a57ee92a77c231ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7e5f540e0e85d59b26385c04930822"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a7e5f540e0e85d59b26385c04930822">createFuncBufferizePass</a> ()</td></tr>
<tr class="memdesc:a2a7e5f540e0e85d59b26385c04930822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of func bufferization pass.  <a href="#a2a7e5f540e0e85d59b26385c04930822">More...</a><br /></td></tr>
<tr class="separator:a2a7e5f540e0e85d59b26385c04930822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5634dcc1162f90dc6df439f3edb444df"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5634dcc1162f90dc6df439f3edb444df">createTensorConstantBufferizePass</a> ()</td></tr>
<tr class="memdesc:a5634dcc1162f90dc6df439f3edb444df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of tensor constant bufferization pass.  <a href="#a5634dcc1162f90dc6df439f3edb444df">More...</a><br /></td></tr>
<tr class="separator:a5634dcc1162f90dc6df439f3edb444df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352a64edaea4b4e39b617a7ca6cdf5e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6352a64edaea4b4e39b617a7ca6cdf5e">createStdExpandOpsPass</a> ()</td></tr>
<tr class="memdesc:a6352a64edaea4b4e39b617a7ca6cdf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the StdExpand pass that legalizes Std dialect ops to be convertible to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a6352a64edaea4b4e39b617a7ca6cdf5e">More...</a><br /></td></tr>
<tr class="separator:a6352a64edaea4b4e39b617a7ca6cdf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad459188a76d182c2f61e1aa1a903bef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad459188a76d182c2f61e1aa1a903bef0">populateStdExpandOpsPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad459188a76d182c2f61e1aa1a903bef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the Std dialect.  <a href="#ad459188a76d182c2f61e1aa1a903bef0">More...</a><br /></td></tr>
<tr class="separator:ad459188a76d182c2f61e1aa1a903bef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fef8af390494abff0a5c260e79a5527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fef8af390494abff0a5c260e79a5527">populateTensorBufferizePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="separator:a7fef8af390494abff0a5c260e79a5527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae811b6513cd07f50d4b60bcd270d4171"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae811b6513cd07f50d4b60bcd270d4171">createTensorBufferizePass</a> ()</td></tr>
<tr class="memdesc:ae811b6513cd07f50d4b60bcd270d4171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of <code>tensor</code> dialect bufferization pass.  <a href="#ae811b6513cd07f50d4b60bcd270d4171">More...</a><br /></td></tr>
<tr class="separator:ae811b6513cd07f50d4b60bcd270d4171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f9bcf99efe125a11237ad6b64642c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae53f9bcf99efe125a11237ad6b64642c">isRowMajorMatmul</a> (<a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="separator:ae53f9bcf99efe125a11237ad6b64642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dfea8ee2dd0eba944b0cd299591ccf9">isColumnMajorMatmul</a> (<a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> indexingMaps)</td></tr>
<tr class="separator:a0dfea8ee2dd0eba944b0cd299591ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348eec2f2303d75aeea3e11b11a9b864"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a348eec2f2303d75aeea3e11b11a9b864">getIndexingMapsAttrName</a> ()</td></tr>
<tr class="memdesc:a348eec2f2303d75aeea3e11b11a9b864"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the AffineArrayAttr which encodes the relationship between a structured op iterators' and its operands.  <a href="#a348eec2f2303d75aeea3e11b11a9b864">More...</a><br /></td></tr>
<tr class="separator:a348eec2f2303d75aeea3e11b11a9b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb614cbb4a83d4b3ec1ef9b5c7cade43"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeb614cbb4a83d4b3ec1ef9b5c7cade43">getIteratorTypesAttrName</a> ()</td></tr>
<tr class="memdesc:aeb614cbb4a83d4b3ec1ef9b5c7cade43"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the type of a structured op's iterators.  <a href="#aeb614cbb4a83d4b3ec1ef9b5c7cade43">More...</a><br /></td></tr>
<tr class="separator:aeb614cbb4a83d4b3ec1ef9b5c7cade43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6eb5b9274486d9ed3f4dff655d4cbd"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c6eb5b9274486d9ed3f4dff655d4cbd">getDocAttrName</a> ()</td></tr>
<tr class="memdesc:a8c6eb5b9274486d9ed3f4dff655d4cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the <a class="el" href="classmlir_1_1StringAttr.html">StringAttr</a> which encodes an optional documentation string of the structured op.  <a href="#a8c6eb5b9274486d9ed3f4dff655d4cbd">More...</a><br /></td></tr>
<tr class="separator:a8c6eb5b9274486d9ed3f4dff655d4cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d25e27ccff1d123995abe189add986"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a39d25e27ccff1d123995abe189add986">getLibraryCallAttrName</a> ()</td></tr>
<tr class="memdesc:a39d25e27ccff1d123995abe189add986"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the external library function that implements the structured op.  <a href="#a39d25e27ccff1d123995abe189add986">More...</a><br /></td></tr>
<tr class="separator:a39d25e27ccff1d123995abe189add986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b10f5ff1eb61aeea833de1628d38a9e"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0b10f5ff1eb61aeea833de1628d38a9e">getSparseAttrName</a> ()</td></tr>
<tr class="memdesc:a0b10f5ff1eb61aeea833de1628d38a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the <a class="el" href="classmlir_1_1ArrayAttr.html" title="Array attributes are lists of other attributes. ">ArrayAttr</a> of StrArrayAttr that encodes sparsity.  <a href="#a0b10f5ff1eb61aeea833de1628d38a9e">More...</a><br /></td></tr>
<tr class="separator:a0b10f5ff1eb61aeea833de1628d38a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3fe0298dee33ee77887d8ad11cc67c"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aed3fe0298dee33ee77887d8ad11cc67c">getStridesAttrName</a> ()</td></tr>
<tr class="memdesc:aed3fe0298dee33ee77887d8ad11cc67c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of strides.  <a href="#aed3fe0298dee33ee77887d8ad11cc67c">More...</a><br /></td></tr>
<tr class="separator:aed3fe0298dee33ee77887d8ad11cc67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4509af87b284808008015597b3f96a"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a4509af87b284808008015597b3f96a">getDilationsAttrName</a> ()</td></tr>
<tr class="memdesc:a4a4509af87b284808008015597b3f96a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of dilations.  <a href="#a4a4509af87b284808008015597b3f96a">More...</a><br /></td></tr>
<tr class="separator:a4a4509af87b284808008015597b3f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef47d572d82ccbf6419876301669cd6a"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef47d572d82ccbf6419876301669cd6a">getPaddingAttrName</a> ()</td></tr>
<tr class="memdesc:aef47d572d82ccbf6419876301669cd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of paddings.  <a href="#aef47d572d82ccbf6419876301669cd6a">More...</a><br /></td></tr>
<tr class="separator:aef47d572d82ccbf6419876301669cd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf9bb42bc7ec9e1668e6e121d0b69b0"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3cf9bb42bc7ec9e1668e6e121d0b69b0">getParallelIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a3cf9bb42bc7ec9e1668e6e121d0b69b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has parallel semantics.  <a href="#a3cf9bb42bc7ec9e1668e6e121d0b69b0">More...</a><br /></td></tr>
<tr class="separator:a3cf9bb42bc7ec9e1668e6e121d0b69b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d7472008e08ed39dd3e9d83c42775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a588d7472008e08ed39dd3e9d83c42775">isParallelIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a588d7472008e08ed39dd3e9d83c42775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c9b6dd4f7515747a96c7de3ed325f9"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52c9b6dd4f7515747a96c7de3ed325f9">getReductionIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a52c9b6dd4f7515747a96c7de3ed325f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has reduction semantics.  <a href="#a52c9b6dd4f7515747a96c7de3ed325f9">More...</a><br /></td></tr>
<tr class="separator:a52c9b6dd4f7515747a96c7de3ed325f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea20c60a2e61974ab7981f341e562c4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aea20c60a2e61974ab7981f341e562c4c">isReductionIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:aea20c60a2e61974ab7981f341e562c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14df83d38352e9dfc0eb0e01fc86230"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae14df83d38352e9dfc0eb0e01fc86230">getWindowIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:ae14df83d38352e9dfc0eb0e01fc86230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has window semantics.  <a href="#ae14df83d38352e9dfc0eb0e01fc86230">More...</a><br /></td></tr>
<tr class="separator:ae14df83d38352e9dfc0eb0e01fc86230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af846930bde2aa600816a8dadd31bbddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af846930bde2aa600816a8dadd31bbddc">isWindowIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:af846930bde2aa600816a8dadd31bbddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79d3eafe91790995ee06ed0e61ebc82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac79d3eafe91790995ee06ed0e61ebc82">getAllIteratorTypeNames</a> ()</td></tr>
<tr class="memdesc:ac79d3eafe91790995ee06ed0e61ebc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has window semantics.  <a href="#ac79d3eafe91790995ee06ed0e61ebc82">More...</a><br /></td></tr>
<tr class="separator:ac79d3eafe91790995ee06ed0e61ebc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729f6e1552c6df7db231ce20f67947b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a729f6e1552c6df7db231ce20f67947b2">getNumIterators</a> (StringRef name, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> iteratorTypes)</td></tr>
<tr class="memdesc:a729f6e1552c6df7db231ce20f67947b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator of a certain type.  <a href="#a729f6e1552c6df7db231ce20f67947b2">More...</a><br /></td></tr>
<tr class="separator:a729f6e1552c6df7db231ce20f67947b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d068f0cba2b5a92fe603c4118664b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d068f0cba2b5a92fe603c4118664b61">getNumIterators</a> (<a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> iteratorTypes)</td></tr>
<tr class="separator:a6d068f0cba2b5a92fe603c4118664b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1515f52892c837f5105efe3f5c5c060"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1515f52892c837f5105efe3f5c5c060">toString</a> (<a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a> t)</td></tr>
<tr class="separator:ae1515f52892c837f5105efe3f5c5c060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f435eb0710ccc0f46b59f9dd25e7d20"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f435eb0710ccc0f46b59f9dd25e7d20">getSparseDimName</a> ()</td></tr>
<tr class="memdesc:a6f435eb0710ccc0f46b59f9dd25e7d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode a dense or sparse dimension.  <a href="#a6f435eb0710ccc0f46b59f9dd25e7d20">More...</a><br /></td></tr>
<tr class="separator:a6f435eb0710ccc0f46b59f9dd25e7d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dce5ff52e3d7a08fcef27fce25edba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9dce5ff52e3d7a08fcef27fce25edba5">isSparseDim</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a9dce5ff52e3d7a08fcef27fce25edba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35604920235d89beb11e9bc64ae45a33"><td class="memItemLeft" align="right" valign="top">constexpr StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a35604920235d89beb11e9bc64ae45a33">getDenseDimName</a> ()</td></tr>
<tr class="separator:a35604920235d89beb11e9bc64ae45a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828a1d51b7a77220cf332221beaa3411"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a828a1d51b7a77220cf332221beaa3411">isDenseDim</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a828a1d51b7a77220cf332221beaa3411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cc57e028b9dcf6b1d9dc54b6489c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a32cc57e028b9dcf6b1d9dc54b6489c58">populateVectorToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; coarseVectorShape={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fineVectorShape={})</td></tr>
<tr class="memdesc:a32cc57e028b9dcf6b1d9dc54b6489c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to itself.  <a href="#a32cc57e028b9dcf6b1d9dc54b6489c58">More...</a><br /></td></tr>
<tr class="separator:a32cc57e028b9dcf6b1d9dc54b6489c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c157bd2c9cf4949b45235593f6ef994"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c157bd2c9cf4949b45235593f6ef994">computeMaxLinearIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:a9c157bd2c9cf4949b45235593f6ef994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements of basis, <code>0</code> if empty.  <a href="#a9c157bd2c9cf4949b45235593f6ef994">More...</a><br /></td></tr>
<tr class="separator:a9c157bd2c9cf4949b45235593f6ef994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceb28e02820023acb8c3efd2a689e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ceb28e02820023acb8c3efd2a689e0b">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:a4ceb28e02820023acb8c3efd2a689e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a shape with sizes greater than 0 along all dimensions, return the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension.  <a href="#a4ceb28e02820023acb8c3efd2a689e0b">More...</a><br /></td></tr>
<tr class="separator:a4ceb28e02820023acb8c3efd2a689e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a5f445f0e1451c0dde7b93a2e1d7ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1a5f445f0e1451c0dde7b93a2e1d7ab">computeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="memdesc:af1a5f445f0e1451c0dde7b93a2e1d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the shape and sizes of a vector, returns the corresponding strides for each dimension.  <a href="#af1a5f445f0e1451c0dde7b93a2e1d7ab">More...</a><br /></td></tr>
<tr class="separator:af1a5f445f0e1451c0dde7b93a2e1d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac84b6a6dfd9d9eb78ca02c17cabbebed">linearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; basis)</td></tr>
<tr class="memdesc:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the linearized index of 'offsets' w.r.t. 'basis'.  <a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">More...</a><br /></td></tr>
<tr class="separator:ac84b6a6dfd9d9eb78ca02c17cabbebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6910a7b4e1cce403814b5dfd894d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0f6910a7b4e1cce403814b5dfd894d90">delinearize</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t linearIndex)</td></tr>
<tr class="memdesc:a0f6910a7b4e1cce403814b5dfd894d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the strides together with a linear index in the dimension space, returns the vector-space offsets in each dimension for a de-linearized index.  <a href="#a0f6910a7b4e1cce403814b5dfd894d90">More...</a><br /></td></tr>
<tr class="separator:a0f6910a7b4e1cce403814b5dfd894d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138bbf83686d046fd85553cdd10eaf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a138bbf83686d046fd85553cdd10eaf18">computeElementOffsetsFromVectorSliceOffsets</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorOffsets)</td></tr>
<tr class="memdesc:a138bbf83686d046fd85553cdd10eaf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the target sizes of a vector, together with vector-space offsets, returns the element-space offsets for each dimension.  <a href="#a138bbf83686d046fd85553cdd10eaf18">More...</a><br /></td></tr>
<tr class="separator:a138bbf83686d046fd85553cdd10eaf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db2dac35fa151fba5d1114497897f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3db2dac35fa151fba5d1114497897f50">computeSliceSizes</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; elementOffsets)</td></tr>
<tr class="memdesc:a3db2dac35fa151fba5d1114497897f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the shape, sizes, and element-space offsets of a vector, returns the slize sizes for each dimension.  <a href="#a3db2dac35fa151fba5d1114497897f50">More...</a><br /></td></tr>
<tr class="separator:a3db2dac35fa151fba5d1114497897f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3741dc3ccffcfafa71e4540ba59f08c0">shapeRatio</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; superShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; subShape)</td></tr>
<tr class="memdesc:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the multi-dimensional ratio of <code>superShape</code> to <code>subShape</code>.  <a href="#a3741dc3ccffcfafa71e4540ba59f08c0">More...</a><br /></td></tr>
<tr class="separator:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937430eb9b6e13bfb05e6ecc5649a816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a937430eb9b6e13bfb05e6ecc5649a816">shapeRatio</a> (<a class="el" href="classmlir_1_1VectorType.html">VectorType</a> superVectorType, <a class="el" href="classmlir_1_1VectorType.html">VectorType</a> subVectorType)</td></tr>
<tr class="memdesc:a937430eb9b6e13bfb05e6ecc5649a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the multi-dimensional ratio of the shapes of <code>superVector</code> to <code>subVector</code>.  <a href="#a937430eb9b6e13bfb05e6ecc5649a816">More...</a><br /></td></tr>
<tr class="separator:a937430eb9b6e13bfb05e6ecc5649a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc028da483ef6cf650439fa8b30eae79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc028da483ef6cf650439fa8b30eae79">JitRunnerMain</a> (int argc, char **argv, <a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a> config={})</td></tr>
<tr class="memdesc:afc028da483ef6cf650439fa8b30eae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for all CPU runners.  <a href="#afc028da483ef6cf650439fa8b30eae79">More...</a><br /></td></tr>
<tr class="separator:afc028da483ef6cf650439fa8b30eae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ea257fc0167ade93ef4d07cdd98af8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51ea257fc0167ade93ef4d07cdd98af8">initializeLLVMPasses</a> ()</td></tr>
<tr class="memdesc:a51ea257fc0167ade93ef4d07cdd98af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> passes that can be used when running MLIR code using <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a>.  <a href="#a51ea257fc0167ade93ef4d07cdd98af8">More...</a><br /></td></tr>
<tr class="separator:a51ea257fc0167ade93ef4d07cdd98af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe55df95d48191f0fa2c5ab8f4e81e34">registerAllDialects</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:afe55df95d48191f0fa2c5ab8f4e81e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afb552a159c6c887b98b3583dfd5cbe5d">registerAllPasses</a> ()</td></tr>
<tr class="separator:afb552a159c6c887b98b3583dfd5cbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a267e7e7ec38e0a09285a20831414d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a267e7e7ec38e0a09285a20831414d3">registerFromLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a7a267e7e7ec38e0a09285a20831414d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ef91a9901d4d87a042990ccb79f2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51ef91a9901d4d87a042990ccb79f2be">registerFromSPIRVTranslation</a> ()</td></tr>
<tr class="separator:a51ef91a9901d4d87a042990ccb79f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d72c96a8bffacc207ba165212e2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a003d72c96a8bffacc207ba165212e2db">registerToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a003d72c96a8bffacc207ba165212e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af7f5d34c37689ae9b05537a040d9e0a0">registerToSPIRVTranslation</a> ()</td></tr>
<tr class="separator:af7f5d34c37689ae9b05537a040d9e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db7f6440d3749bb04fc783871b7b93b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5db7f6440d3749bb04fc783871b7b93b">registerToNVVMIRTranslation</a> ()</td></tr>
<tr class="separator:a5db7f6440d3749bb04fc783871b7b93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed3ae8b1ba3c9068710028ae3afbc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae1ed3ae8b1ba3c9068710028ae3afbc3">registerToROCDLIRTranslation</a> ()</td></tr>
<tr class="separator:ae1ed3ae8b1ba3c9068710028ae3afbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7dbdbbeef63c0597b8f9949126a24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f7dbdbbeef63c0597b8f9949126a24e">registerArmNeonToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a2f7dbdbbeef63c0597b8f9949126a24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa837e2927c0f27e9bff6711e40a90492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa837e2927c0f27e9bff6711e40a90492">registerAVX512ToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:aa837e2927c0f27e9bff6711e40a90492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b72741d6e7f2256ad4856beaaa6bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50b72741d6e7f2256ad4856beaaa6bf5">registerArmSVEToLLVMIRTranslation</a> ()</td></tr>
<tr class="separator:a50b72741d6e7f2256ad4856beaaa6bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d16808b31b66905b067720d428adf61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d16808b31b66905b067720d428adf61">registerAllTranslations</a> ()</td></tr>
<tr class="separator:a8d16808b31b66905b067720d428adf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8583719d6a8f0699c36ac4c4b53057f2">isOpTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8583719d6a8f0699c36ac4c4b53057f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation is unused, and has no side effects on memory that prevent erasing.  <a href="#a8583719d6a8f0699c36ac4c4b53057f2">More...</a><br /></td></tr>
<tr class="separator:a8583719d6a8f0699c36ac4c4b53057f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655db45ed8c23d04d5ed5ee0abe041ad">wouldOpBeTriviallyDead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing.  <a href="#a655db45ed8c23d04d5ed5ee0abe041ad">More...</a><br /></td></tr>
<tr class="separator:a655db45ed8c23d04d5ed5ee0abe041ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f4c1929cc819247d6e7b515554733f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad9f4c1929cc819247d6e7b515554733f">verify</a> (OffsetSizeAndStrideOpInterface op)</td></tr>
<tr class="separator:ad9f4c1929cc819247d6e7b515554733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cebee2d47d356a33b95207e67cfe6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0cebee2d47d356a33b95207e67cfe6e0">printOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, OffsetSizeAndStrideOpInterface op, StringRef offsetPrefix=&quot;&quot;, StringRef sizePrefix=&quot; &quot;, StringRef stridePrefix=&quot; &quot;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedAttrs=OffsetSizeAndStrideOpInterface::getSpecialAttrNames())</td></tr>
<tr class="memdesc:a0cebee2d47d356a33b95207e67cfe6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print part of an op of the form: ``<code> &lt;optional-offset-prefix&gt;</code>[<code>offset-list</code>]<code> &lt;optional-size-prefix&gt;</code>[<code>size-list</code>]<code> &lt;optional-stride-prefix&gt;[</code> stride-list <code>]</code> ```.  <a href="#a0cebee2d47d356a33b95207e67cfe6e0">More...</a><br /></td></tr>
<tr class="separator:a0cebee2d47d356a33b95207e67cfe6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e17f4db35d6a73c034b1878320a9e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2e17f4db35d6a73c034b1878320a9e13">parseOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; segmentSizes, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;)&gt; preResolutionFn=nullptr, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt; parseOptionalOffsetPrefix=nullptr, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt; parseOptionalSizePrefix=nullptr, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt; parseOptionalStridePrefix=nullptr)</td></tr>
<tr class="memdesc:a2e17f4db35d6a73c034b1878320a9e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse trailing part of an op of the form: ``<code> &lt;optional-offset-prefix&gt;</code>[<code>offset-list</code>]<code> &lt;optional-size-prefix&gt;</code>[<code>size-list</code>]<code> &lt;optional-stride-prefix&gt;[</code> stride-list <code>]</code> ``` Each entry in the offset, size and stride list either resolves to an integer constant or an operand of index type.  <a href="#a2e17f4db35d6a73c034b1878320a9e13">More...</a><br /></td></tr>
<tr class="separator:a2e17f4db35d6a73c034b1878320a9e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5e9dc6800ed6910aa89b8598e2046a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2a5e9dc6800ed6910aa89b8598e2046a">parseOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; segmentSizes, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt; parseOptionalOffsetPrefix=nullptr, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt; parseOptionalSizePrefix=nullptr, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt; parseOptionalStridePrefix=nullptr)</td></tr>
<tr class="memdesc:a2a5e9dc6800ed6910aa89b8598e2046a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>preResolutionFn</code>-less version of <code>parseOffsetsSizesAndStrides</code>.  <a href="#a2a5e9dc6800ed6910aa89b8598e2046a">More...</a><br /></td></tr>
<tr class="separator:a2a5e9dc6800ed6910aa89b8598e2046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9141d8b586a68549d2ecaccbce99a69"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">hash_value</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> arg)</td></tr>
<tr class="memdesc:ad9141d8b586a68549d2ecaccbce99a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> hashable.  <a href="#ad9141d8b586a68549d2ecaccbce99a69">More...</a><br /></td></tr>
<tr class="separator:ad9141d8b586a68549d2ecaccbce99a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f6f52bcd2d859c9d9a6f393ad5481c1">operator+</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137193b56dc5134c3092273b13e3f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9137193b56dc5134c3092273b13e3f47">operator*</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a9137193b56dc5134c3092273b13e3f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72aa3fc8e169b33e5d4a63f593172d4e">operator-</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd4323ef72147332661606b030d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">getAffineDimExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:addfd4323ef72147332661606b030d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These free functions allow clients of the API to not use classes in detail.  <a href="#addfd4323ef72147332661606b030d04d">More...</a><br /></td></tr>
<tr class="separator:addfd4323ef72147332661606b030d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7ba5a55b4f16631528884d3617a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr</a> (<a class="el" href="classunsigned.html">unsigned</a> position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:aefb7ba5a55b4f16631528884d3617a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cdced424aa629fde4150cc8674d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr</a> (int64_t constant, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:ab26cdced424aa629fde4150cc8674d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a0f44c623301035b6151ca51cca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e8a0f44c623301035b6151ca51cca4d">getAffineBinaryOpExpr</a> (<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> lhs, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> rhs)</td></tr>
<tr class="separator:a6e8a0f44c623301035b6151ca51cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad71c14bebce843758768ff160e2283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ad71c14bebce843758768ff160e2283">getAffineExprFromFlatForm</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; flatExprs, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a8ad71c14bebce843758768ff160e2283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an affine expression from a flat ArrayRef.  <a href="#a8ad71c14bebce843758768ff160e2283">More...</a><br /></td></tr>
<tr class="separator:a8ad71c14bebce843758768ff160e2283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69078b1d3f3263a1769df2e0f1730df"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae69078b1d3f3263a1769df2e0f1730df">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:ae69078b1d3f3263a1769df2e0f1730df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf369c69cfb613cd018ef4ce188809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">simplifyAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols)</td></tr>
<tr class="memdesc:acbf369c69cfb613cd018ef4ce188809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine expression by flattening and some amount of simple analysis.  <a href="#acbf369c69cfb613cd018ef4ce188809c">More...</a><br /></td></tr>
<tr class="separator:acbf369c69cfb613cd018ef4ce188809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97905517c34a363dacccfe12bb2fcc14"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a97905517c34a363dacccfe12bb2fcc14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97905517c34a363dacccfe12bb2fcc14">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;... exprs)</td></tr>
<tr class="memdesc:a97905517c34a363dacccfe12bb2fcc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to DimExpr at positions: [0 .  <a href="#a97905517c34a363dacccfe12bb2fcc14">More...</a><br /></td></tr>
<tr class="separator:a97905517c34a363dacccfe12bb2fcc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a032c893ca9a2fff3b16e5a7cb6d413cd">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d8e82c51794d145267690b2b5bd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">simplifyAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a014d8e82c51794d145267690b2b5bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> results.  <a href="#a014d8e82c51794d145267690b2b5bd58">More...</a><br /></td></tr>
<tr class="separator:a014d8e82c51794d145267690b2b5bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">removeDuplicateExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>.  <a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">More...</a><br /></td></tr>
<tr class="separator:a1fa0a7e84eb2af3d70c98d59fc9ccbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b322818d83a2256d4e4391acbf78a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">inversePermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a52b322818d83a2256d4e4391acbf78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected.  <a href="#a52b322818d83a2256d4e4391acbf78a2">More...</a><br /></td></tr>
<tr class="separator:a52b322818d83a2256d4e4391acbf78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">concatAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a6d24d64d6db077b8d5c88316b0d6c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, stepping over potentially empty maps.  <a href="#a6d24d64d6db077b8d5c88316b0d6c717">More...</a><br /></td></tr>
<tr class="separator:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab221e5dde89586cce7d959284af9f05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab221e5dde89586cce7d959284af9f05e">getProjectedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; projectedDimensions)</td></tr>
<tr class="separator:ab221e5dde89586cce7d959284af9f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f93a44db5e2d93372201d5a594e51cd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f93a44db5e2d93372201d5a594e51cd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a6f93a44db5e2d93372201d5a594e51cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a08aa6ed051f55e57bc35859a379f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a894a08aa6ed051f55e57bc35859a379f">registerAsmPrinterCLOptions</a> ()</td></tr>
<tr class="memdesc:a894a08aa6ed051f55e57bc35859a379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the AsmPrinter.  <a href="#a894a08aa6ed051f55e57bc35859a379f">More...</a><br /></td></tr>
<tr class="separator:a894a08aa6ed051f55e57bc35859a379f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e8f0e932c305de3ac1584560d1b03d0">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bae84b1d7cdba11b048d9af3478a07"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68bae84b1d7cdba11b048d9af3478a07">hash_value</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> arg)</td></tr>
<tr class="separator:a68bae84b1d7cdba11b048d9af3478a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db54f641a4e3e28ebdf5a3e42e9964b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9db54f641a4e3e28ebdf5a3e42e9964b">operator&lt;</a> (const <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &amp;lhs, const <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &amp;rhs)</td></tr>
<tr class="separator:a9db54f641a4e3e28ebdf5a3e42e9964b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54da410db8d38b2bacd3bb5e5045582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae54da410db8d38b2bacd3bb5e5045582">operator&lt;</a> (const <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &amp;lhs, StringRef rhs)</td></tr>
<tr class="separator:ae54da410db8d38b2bacd3bb5e5045582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248f26067c1829c0eb6c4c440865811d"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a248f26067c1829c0eb6c4c440865811d">hash_value</a> (const <a class="el" href="classmlir_1_1MutableDictionaryAttr.html">MutableDictionaryAttr</a> &amp;arg)</td></tr>
<tr class="separator:a248f26067c1829c0eb6c4c440865811d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c478f802ab2f874c0b34a18bc091b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">getStridesAndOffset</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides, int64_t &amp;offset)</td></tr>
<tr class="memdesc:a506c478f802ab2f874c0b34a18bc091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strides of the MemRef if the layout map is in strided form.  <a href="#a506c478f802ab2f874c0b34a18bc091b">More...</a><br /></td></tr>
<tr class="separator:a506c478f802ab2f874c0b34a18bc091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d8af8a280cbdd7ffbf4629ee82ccc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9d8af8a280cbdd7ffbf4629ee82ccc4">getStridesAndOffset</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;strides, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;offset)</td></tr>
<tr class="separator:ab9d8af8a280cbdd7ffbf4629ee82ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">makeStridedLinearLayoutMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of strides (in which <a class="el" href="classmlir_1_1MemRefType.html#acbdbbe58df49b67438c3c03507d0c8b3">MemRefType::getDynamicStrideOrOffset()</a> represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> which represents the linearized strided layout map.  <a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">More...</a><br /></td></tr>
<tr class="separator:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcfbd64b4c5038926d874e46edeea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">canonicalizeStridedLayout</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t)</td></tr>
<tr class="memdesc:a80dcfbd64b4c5038926d874e46edeea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout.  <a href="#a80dcfbd64b4c5038926d874e46edeea2">More...</a><br /></td></tr>
<tr class="separator:a80dcfbd64b4c5038926d874e46edeea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f2978611fa2c3143d6ea5ea01cd041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a47f2978611fa2c3143d6ea5ea01cd041">eraseStridedLayout</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t)</td></tr>
<tr class="memdesc:a47f2978611fa2c3143d6ea5ea01cd041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with a layout that has all dynamic offset and strides.  <a href="#a47f2978611fa2c3143d6ea5ea01cd041">More...</a><br /></td></tr>
<tr class="separator:a47f2978611fa2c3143d6ea5ea01cd041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac603376cc0dac0b2bd27c2dcde3c2e14">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; exprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>.  <a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">More...</a><br /></td></tr>
<tr class="separator:ac603376cc0dac0b2bd27c2dcde3c2e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad25cd8672ecb721d7a4f0ecd22bac6e8">makeCanonicalStridedLayoutExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}.  <a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">More...</a><br /></td></tr>
<tr class="separator:ad25cd8672ecb721d7a4f0ecd22bac6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c26bcf64137533f38f2cda9abd75af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">isStrided</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t)</td></tr>
<tr class="memdesc:ad0c26bcf64137533f38f2cda9abd75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the layout for <code>t</code> is compatible with strided semantics.  <a href="#ad0c26bcf64137533f38f2cda9abd75af">More...</a><br /></td></tr>
<tr class="separator:ad0c26bcf64137533f38f2cda9abd75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e36349258a6b2baeae78188a74550"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae72e36349258a6b2baeae78188a74550">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;arg)</td></tr>
<tr class="separator:ae72e36349258a6b2baeae78188a74550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a85b9a8e647d5e73b7e107b0669ec9e29">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;<a class="el" href="ConvertFromLLVMIR_8cpp.html#a6d80ed55125bb93b1e2eb58f0827ce39">diag</a>)</td></tr>
<tr class="separator:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4e96b0c437652eb5a4890734bb6bcee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit an error message using this location.  <a href="#a4e96b0c437652eb5a4890734bb6bcee7">More...</a><br /></td></tr>
<tr class="separator:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2dc4e9418ff63ebea20c7f709ebcb0f8">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0768c8a572dc71b0b00d57414b56b60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a0768c8a572dc71b0b00d57414b56b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a warning message using this location.  <a href="#a0768c8a572dc71b0b00d57414b56b60d">More...</a><br /></td></tr>
<tr class="separator:a0768c8a572dc71b0b00d57414b56b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e96e5ea091fb5bea539cef6ea7c5624">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a remark message using this location.  <a href="#a8a9ca6fe9d5aab498bf090db3e878c87">More...</a><br /></td></tr>
<tr class="separator:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a391c4b4ea9dc95fbcfbfdab8a49547a3">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdaf0aee1c1669e8b822bf98297b85f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:affdaf0aee1c1669e8b822bf98297b85f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#affdaf0aee1c1669e8b822bf98297b85f">emitOptionalError</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:affdaf0aee1c1669e8b822bf98297b85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of the above emission functions that take an optionally null location.  <a href="#affdaf0aee1c1669e8b822bf98297b85f">More...</a><br /></td></tr>
<tr class="separator:affdaf0aee1c1669e8b822bf98297b85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c32efa8059ae855341f4946f7497c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a665c32efa8059ae855341f4946f7497c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a665c32efa8059ae855341f4946f7497c">emitOptionalWarning</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a665c32efa8059ae855341f4946f7497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27e629384a23b9991e36201d87de462"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab27e629384a23b9991e36201d87de462"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab27e629384a23b9991e36201d87de462">emitOptionalRemark</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab27e629384a23b9991e36201d87de462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30603aed1417a20bef2b8efae1167bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a30603aed1417a20bef2b8efae1167bde">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a30603aed1417a20bef2b8efae1167bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ee8579b14d0897aab47f53b883b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a649ee8579b14d0897aab47f53b883b29">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, const APFloat &amp;value)</td></tr>
<tr class="separator:a649ee8579b14d0897aab47f53b883b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afb696ee471be35a4d1f75c64ea1bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1afb696ee471be35a4d1f75c64ea1bd4">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, float value)</td></tr>
<tr class="separator:a1afb696ee471be35a4d1f75c64ea1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26a3adac6475f34a40e802331ee10d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae26a3adac6475f34a40e802331ee10d6">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, double value)</td></tr>
<tr class="separator:ae26a3adac6475f34a40e802331ee10d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffb26ef01caacb04bda28d4501f4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2ffb26ef01caacb04bda28d4501f4fd">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:aa2ffb26ef01caacb04bda28d4501f4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9916cd8c014a3b0a666cc2fe88a6fae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_convertible&lt; T &amp;, Attribute &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp;&gt;::value &amp;&amp;!llvm::is_one_of&lt; T, double, float &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af9916cd8c014a3b0a666cc2fe88a6fae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9916cd8c014a3b0a666cc2fe88a6fae">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, const T &amp;other)</td></tr>
<tr class="separator:af9916cd8c014a3b0a666cc2fe88a6fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5b241db4d1de80e4879009596797b6"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f5b241db4d1de80e4879009596797b6">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> identifier)</td></tr>
<tr class="separator:a9f5b241db4d1de80e4879009596797b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa492640c61b36ef2ab8565e5015abd1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa492640c61b36ef2ab8565e5015abd1e">operator==</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> lhs, StringRef rhs)</td></tr>
<tr class="separator:aa492640c61b36ef2ab8565e5015abd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec87c8e176e5200de6eabb890d01e96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeec87c8e176e5200de6eabb890d01e96">operator!=</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> lhs, StringRef rhs)</td></tr>
<tr class="separator:aeec87c8e176e5200de6eabb890d01e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b0dcdd7e4c238b039144d7840350f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6b0dcdd7e4c238b039144d7840350f2">operator==</a> (StringRef lhs, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> rhs)</td></tr>
<tr class="separator:ad6b0dcdd7e4c238b039144d7840350f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956129148e25edd5ec7b39b592c6082"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa956129148e25edd5ec7b39b592c6082">operator!=</a> (StringRef lhs, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> rhs)</td></tr>
<tr class="separator:aa956129148e25edd5ec7b39b592c6082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d54dd4c592884f7bb771cbff354e7"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a060d54dd4c592884f7bb771cbff354e7">hash_value</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> arg)</td></tr>
<tr class="separator:a060d54dd4c592884f7bb771cbff354e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655bb0e17a21ea2c35194f7c822c9ca5">hash_value</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> arg)</td></tr>
<tr class="separator:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097ddf5971ea2a3956fc814005f459f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab097ddf5971ea2a3956fc814005f459f">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:ab097ddf5971ea2a3956fc814005f459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6261878bc5197cfcc003e5b3fa735ea">hash_value</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> arg)</td></tr>
<tr class="separator:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad402a86ee4c9000c6fa1fceaddab560b">m_Constant</a> ()</td></tr>
<tr class="memdesc:ad402a86ee4c9000c6fa1fceaddab560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant foldable operation.  <a href="#ad402a86ee4c9000c6fa1fceaddab560b">More...</a><br /></td></tr>
<tr class="separator:ad402a86ee4c9000c6fa1fceaddab560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">m_Constant</a> (AttrT *bind_value)</td></tr>
<tr class="memdesc:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a value from a constant foldable operation and writes the value to bind_value.  <a href="#a10b6da5781fbe1b019fcb64dcd6921dd">More...</a><br /></td></tr>
<tr class="separator:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cc1a8746679396a5dfe6e4c7ef8396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac4cc1a8746679396a5dfe6e4c7ef8396">m_One</a> ()</td></tr>
<tr class="memdesc:ac4cc1a8746679396a5dfe6e4c7ef8396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer one.  <a href="#ac4cc1a8746679396a5dfe6e4c7ef8396">More...</a><br /></td></tr>
<tr class="separator:ac4cc1a8746679396a5dfe6e4c7ef8396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplParams" colspan="2">template&lt;typename OpClass &gt; </td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">m_Op</a> ()</td></tr>
<tr class="memdesc:ac2418532386147bec2ca5aadf5414406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the given OpClass.  <a href="#ac2418532386147bec2ca5aadf5414406">More...</a><br /></td></tr>
<tr class="separator:ac2418532386147bec2ca5aadf5414406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf138ddcdd4a81f4047f2d6bbee3482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacf138ddcdd4a81f4047f2d6bbee3482">m_Zero</a> ()</td></tr>
<tr class="memdesc:aacf138ddcdd4a81f4047f2d6bbee3482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer zero.  <a href="#aacf138ddcdd4a81f4047f2d6bbee3482">More...</a><br /></td></tr>
<tr class="separator:aacf138ddcdd4a81f4047f2d6bbee3482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ff769cbd1cef62ceda90ccd14062a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__not__value__matcher.html">detail::constant_int_not_value_matcher</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a585ff769cbd1cef62ceda90ccd14062a">m_NonZero</a> ()</td></tr>
<tr class="memdesc:a585ff769cbd1cef62ceda90ccd14062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value.  <a href="#a585ff769cbd1cef62ceda90ccd14062a">More...</a><br /></td></tr>
<tr class="separator:a585ff769cbd1cef62ceda90ccd14062a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">matchPattern</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a0190228b09e7b51a4bc1e013c01d404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a0190228b09e7b51a4bc1e013c01d404c">More...</a><br /></td></tr>
<tr class="separator:a0190228b09e7b51a4bc1e013c01d404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">matchPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>.  <a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">More...</a><br /></td></tr>
<tr class="separator:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930dbe1d176d999aec049a4581838974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a930dbe1d176d999aec049a4581838974">m_ConstantInt</a> (<a class="el" href="classmlir_1_1IntegerAttr.html#a338d41710c0bd77a572190b8d552c754">IntegerAttr::ValueType</a> *bind_value)</td></tr>
<tr class="memdesc:a930dbe1d176d999aec049a4581838974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value.  <a href="#a930dbe1d176d999aec049a4581838974">More...</a><br /></td></tr>
<tr class="separator:a930dbe1d176d999aec049a4581838974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename... Matchers&gt; </td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ecde76b07cd295bae0d6ef10d1c45d8">m_Op</a> (Matchers... matchers)</td></tr>
<tr class="separator:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254079fbbd31a78a3430bff18df2d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5254079fbbd31a78a3430bff18df2d7c">registerMLIRContextCLOptions</a> ()</td></tr>
<tr class="memdesc:a5254079fbbd31a78a3430bff18df2d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>.  <a href="#a5254079fbbd31a78a3430bff18df2d7c">More...</a><br /></td></tr>
<tr class="separator:a5254079fbbd31a78a3430bff18df2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310fba6c1ad548d4884cf850b4b7df08"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a310fba6c1ad548d4884cf850b4b7df08">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpState.html">OpState</a> &amp;op)</td></tr>
<tr class="memdesc:a310fba6c1ad548d4884cf850b4b7df08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <a href="#a310fba6c1ad548d4884cf850b4b7df08">More...</a><br /></td></tr>
<tr class="separator:a310fba6c1ad548d4884cf850b4b7df08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b4a2344293dfbeab47ede8971fb29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b4a2344293dfbeab47ede8971fb29">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:a253b4a2344293dfbeab47ede8971fb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff09e0657f1f97508b409ac5f6e4e5b8"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aff09e0657f1f97508b409ac5f6e4e5b8">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> identifier)</td></tr>
<tr class="separator:aff09e0657f1f97508b409ac5f6e4e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6a127d8f1fa12d3c7405b9d51a695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14c6a127d8f1fa12d3c7405b9d51a695">operator==</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> lhs, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> rhs)</td></tr>
<tr class="separator:a14c6a127d8f1fa12d3c7405b9d51a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da97a01717dee2c2fa7ad551de8dc46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5da97a01717dee2c2fa7ad551de8dc46">operator!=</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> lhs, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> rhs)</td></tr>
<tr class="separator:a5da97a01717dee2c2fa7ad551de8dc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93109842c1b05424c5052d9bd9a4394"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad93109842c1b05424c5052d9bd9a4394">hash_value</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> arg)</td></tr>
<tr class="separator:ad93109842c1b05424c5052d9bd9a4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912da94236cff04e9076f6e052676b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af912da94236cff04e9076f6e052676b1">LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE</a> ()</td></tr>
<tr class="memdesc:af912da94236cff04e9076f6e052676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>.  <a href="#af912da94236cff04e9076f6e052676b1">More...</a><br /></td></tr>
<tr class="separator:af912da94236cff04e9076f6e052676b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acabdc4e9d44aae13942c9ea9b41b9a33">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0454cf763cf2a4bab30345a05f174fe6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0454cf763cf2a4bab30345a05f174fe6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0454cf763cf2a4bab30345a05f174fe6">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;values)</td></tr>
<tr class="separator:a0454cf763cf2a4bab30345a05f174fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b198f57489cfde31dc674cca18d6e9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9b198f57489cfde31dc674cca18d6e9d">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:a9b198f57489cfde31dc674cca18d6e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6974d43c0e2f0e03e5ffe739237dcae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6974d43c0e2f0e03e5ffe739237dcae4">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a6974d43c0e2f0e03e5ffe739237dcae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05b62a76688ea80f262ea5b69665ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af05b62a76688ea80f262ea5b69665ae4">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, bool value)</td></tr>
<tr class="separator:af05b62a76688ea80f262ea5b69665ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad554d3204bdbdc4a87d291ed94c1e575">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Block.html">Block</a> *value)</td></tr>
<tr class="separator:ad554d3204bdbdc4a87d291ed94c1e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8211b996d6a22980eb1685cc95da68b"><td class="memTemplParams" colspan="2">template&lt;typename ValueRangeT &gt; </td></tr>
<tr class="memitem:ab8211b996d6a22980eb1685cc95da68b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8211b996d6a22980eb1685cc95da68b">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;types)</td></tr>
<tr class="separator:ab8211b996d6a22980eb1685cc95da68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136935d6144b1b049ffd094c23ecda73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a136935d6144b1b049ffd094c23ecda73">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;types)</td></tr>
<tr class="separator:a136935d6144b1b049ffd094c23ecda73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f24a74c286a71cc71f45da9d4919ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6f24a74c286a71cc71f45da9d4919ab">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types)</td></tr>
<tr class="separator:ac6f24a74c286a71cc71f45da9d4919ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee66a47ca548fabe02261ad8b96eea5"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acee66a47ca548fabe02261ad8b96eea5">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a> value)</td></tr>
<tr class="separator:acee66a47ca548fabe02261ad8b96eea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb322b17530b4289c3e3ec1f4ad2ecce">hash_value</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> arg)</td></tr>
<tr class="memdesc:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types. ">TypeRange</a> hashable.  <a href="#abb322b17530b4289c3e3ec1f4ad2ecce">More...</a><br /></td></tr>
<tr class="separator:abb322b17530b4289c3e3ec1f4ad2ecce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a8fc3d1f66f267d9111234fac1effdfce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fc3d1f66f267d9111234fac1effdfce">operator==</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; lhs, const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;rhs)</td></tr>
<tr class="separator:a8fc3d1f66f267d9111234fac1effdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bfd80339235fbb32a685ff75f4e16"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd5bfd80339235fbb32a685ff75f4e16">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:acd5bfd80339235fbb32a685ff75f4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eede9183d3fdae566e18d94a5ef51b"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31eede9183d3fdae566e18d94a5ef51b">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a31eede9183d3fdae566e18d94a5ef51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="#a82686ceb29eb0f78b59e29021f1b2cdd">More...</a><br /></td></tr>
<tr class="separator:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252aee27751e05d584d0b1a8e793ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a252aee27751e05d584d0b1a8e793ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="#a252aee27751e05d584d0b1a8e793ecf0">More...</a><br /></td></tr>
<tr class="separator:a252aee27751e05d584d0b1a8e793ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae81d443c449b61825fb2c2ec6aa90d35">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">getFlattenedTypes</a> (<a class="el" href="classmlir_1_1TupleType.html">TupleType</a> t)</td></tr>
<tr class="memdesc:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types within a nested Tuple.  <a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">More...</a><br /></td></tr>
<tr class="separator:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">isOpaqueTypeWithName</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef dialect, StringRef typeData)</td></tr>
<tr class="memdesc:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified type is an opaque type with the specified dialect and typeData.  <a href="#a4bd6b581b08699ce79d3e9f820c1ade9">More...</a><br /></td></tr>
<tr class="separator:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb414ad1d507c2ab841305c273f4deb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">verifyCompatibleShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2)</td></tr>
<tr class="memdesc:acb414ad1d507c2ab841305c273f4deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two shapes are compatible.  <a href="#acb414ad1d507c2ab841305c273f4deb8">More...</a><br /></td></tr>
<tr class="separator:acb414ad1d507c2ab841305c273f4deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">verifyCompatibleShape</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2)</td></tr>
<tr class="memdesc:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two types have compatible shape.  <a href="#ac54e5e6c31f51ef648f7c03652a29ce6">More...</a><br /></td></tr>
<tr class="separator:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df16c49c963cdc57cf6f9e7c3e9f822">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710b1f6f21f3f35197575b609aae4b4"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">hash_value</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> arg)</td></tr>
<tr class="memdesc:ab710b1f6f21f3f35197575b609aae4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable.  <a href="#ab710b1f6f21f3f35197575b609aae4b4">More...</a><br /></td></tr>
<tr class="separator:ab710b1f6f21f3f35197575b609aae4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8311703578f50c8d610c687db37a8dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8311703578f50c8d610c687db37a8dc4">verify</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8311703578f50c8d610c687db37a8dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations.  <a href="#a8311703578f50c8d610c687db37a8dc4">More...</a><br /></td></tr>
<tr class="separator:a8311703578f50c8d610c687db37a8dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1bcc5ded20de449d4a852d340d919c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d1bcc5ded20de449d4a852d340d919c">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a0d1bcc5ded20de449d4a852d340d919c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block.  <a href="#a0d1bcc5ded20de449d4a852d340d919c">More...</a><br /></td></tr>
<tr class="separator:a0d1bcc5ded20de449d4a852d340d919c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1795d3dff83a21eba1ca1fc638b5154b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1795d3dff83a21eba1ca1fc638b5154b">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a1795d3dff83a21eba1ca1fc638b5154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename and appends parsed operations to the given block.  <a href="#a1795d3dff83a21eba1ca1fc638b5154b">More...</a><br /></td></tr>
<tr class="separator:a1795d3dff83a21eba1ca1fc638b5154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981d1bca708b54f222e845276d76500f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a981d1bca708b54f222e845276d76500f">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:a981d1bca708b54f222e845276d76500f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block.  <a href="#a981d1bca708b54f222e845276d76500f">More...</a><br /></td></tr>
<tr class="separator:a981d1bca708b54f222e845276d76500f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca40e833eb161d3044d41db30225fb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aca40e833eb161d3044d41db30225fb47">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *sourceFileLoc=nullptr)</td></tr>
<tr class="memdesc:aca40e833eb161d3044d41db30225fb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the IR string and appends parsed operations to the given block.  <a href="#aca40e833eb161d3044d41db30225fb47">More...</a><br /></td></tr>
<tr class="separator:aca40e833eb161d3044d41db30225fb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8dabbb172a5956aba4955252714442"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:afa8dabbb172a5956aba4955252714442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa8dabbb172a5956aba4955252714442">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:afa8dabbb172a5956aba4955252714442"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr.  <a href="#afa8dabbb172a5956aba4955252714442">More...</a><br /></td></tr>
<tr class="separator:afa8dabbb172a5956aba4955252714442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c996bdea9718ac54d8fb9fde211d3a0"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a6c996bdea9718ac54d8fb9fde211d3a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c996bdea9718ac54d8fb9fde211d3a0">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a6c996bdea9718ac54d8fb9fde211d3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename.  <a href="#a6c996bdea9718ac54d8fb9fde211d3a0">More...</a><br /></td></tr>
<tr class="separator:a6c996bdea9718ac54d8fb9fde211d3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94dbdefaa6eba8b6b33b5eab1710a9"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a4f94dbdefaa6eba8b6b33b5eab1710a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4f94dbdefaa6eba8b6b33b5eab1710a9">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a4f94dbdefaa6eba8b6b33b5eab1710a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr.  <a href="#a4f94dbdefaa6eba8b6b33b5eab1710a9">More...</a><br /></td></tr>
<tr class="separator:a4f94dbdefaa6eba8b6b33b5eab1710a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323631c3744d0b0df384c9c7ba0a1c1b"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a323631c3744d0b0df384c9c7ba0a1c1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a323631c3744d0b0df384c9c7ba0a1c1b">parseSourceString</a> (llvm::StringRef sourceStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a323631c3744d0b0df384c9c7ba0a1c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the provided string containing MLIR.  <a href="#a323631c3744d0b0df384c9c7ba0a1c1b">More...</a><br /></td></tr>
<tr class="separator:a323631c3744d0b0df384c9c7ba0a1c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa182f707b3cb6a071cf1a9937578d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1aa182f707b3cb6a071cf1a9937578d">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:af1aa182f707b3cb6a071cf1a9937578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="#af1aa182f707b3cb6a071cf1a9937578d">More...</a><br /></td></tr>
<tr class="separator:af1aa182f707b3cb6a071cf1a9937578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34310a5d6e4690062af470064089068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae34310a5d6e4690062af470064089068">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:ae34310a5d6e4690062af470064089068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2bd19a863e2bf8969c4bae3ecaa84a16">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t &amp;numRead)</td></tr>
<tr class="memdesc:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="#a2bd19a863e2bf8969c4bae3ecaa84a16">More...</a><br /></td></tr>
<tr class="separator:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d149703ad4537629141fab7417075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae61d149703ad4537629141fab7417075">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1Type.html">Type</a> type, size_t &amp;numRead)</td></tr>
<tr class="separator:ae61d149703ad4537629141fab7417075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffe10560be9caf3b9e8de592c20e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5ffe10560be9caf3b9e8de592c20e93">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac5ffe10560be9caf3b9e8de592c20e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="#ac5ffe10560be9caf3b9e8de592c20e93">More...</a><br /></td></tr>
<tr class="separator:ac5ffe10560be9caf3b9e8de592c20e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafaf30c94bd5327a769f9fd691cd42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afafaf30c94bd5327a769f9fd691cd42a">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t &amp;numRead)</td></tr>
<tr class="memdesc:afafaf30c94bd5327a769f9fd691cd42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="#afafaf30c94bd5327a769f9fd691cd42a">More...</a><br /></td></tr>
<tr class="separator:afafaf30c94bd5327a769f9fd691cd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4edce10b597637635af55bb162477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">registerPassManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:aa5c4edce10b597637635af55bb162477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a pass manager.  <a href="#aa5c4edce10b597637635af55bb162477">More...</a><br /></td></tr>
<tr class="separator:aa5c4edce10b597637635af55bb162477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b943c7bb07b96e86234204b79b3d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a706b943c7bb07b96e86234204b79b3d4">applyPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:a706b943c7bb07b96e86234204b79b3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'.  <a href="#a706b943c7bb07b96e86234204b79b3d4">More...</a><br /></td></tr>
<tr class="separator:a706b943c7bb07b96e86234204b79b3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83965c855ad737422194336251348893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a83965c855ad737422194336251348893">registerPassPipeline</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;function, std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt; optHandler)</td></tr>
<tr class="memdesc:a83965c855ad737422194336251348893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template.  <a href="#a83965c855ad737422194336251348893">More...</a><br /></td></tr>
<tr class="separator:a83965c855ad737422194336251348893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceae2b75bb5d4478ea5d9bd218e152e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adceae2b75bb5d4478ea5d9bd218e152e">registerPass</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:adceae2b75bb5d4478ea5d9bd218e152e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template.  <a href="#adceae2b75bb5d4478ea5d9bd218e152e">More...</a><br /></td></tr>
<tr class="separator:adceae2b75bb5d4478ea5d9bd218e152e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d10077c7edf58c1152a1170257d739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:ad8d10077c7edf58c1152a1170257d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses the textual representation of a pass pipeline, and adds the result to 'pm' on success.  <a href="#ad8d10077c7edf58c1152a1170257d739">More...</a><br /></td></tr>
<tr class="separator:ad8d10077c7edf58c1152a1170257d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc84cc9baea1d755e04cc705616c9b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6bc84cc9baea1d755e04cc705616c9b1"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bc84cc9baea1d755e04cc705616c9b1">debugString</a> (T &amp;op)</td></tr>
<tr class="separator:a6bc84cc9baea1d755e04cc705616c9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile</a> (llvm::StringRef inputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading.  <a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">More...</a><br /></td></tr>
<tr class="separator:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::ToolOutputFile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile</a> (llvm::StringRef outputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for writing.  <a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">More...</a><br /></td></tr>
<tr class="separator:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a> (bool isSuccess=true)</td></tr>
<tr class="memdesc:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a>.  <a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">More...</a><br /></td></tr>
<tr class="separator:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a> (bool isFailure=true)</td></tr>
<tr class="memdesc:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a>.  <a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">More...</a><br /></td></tr>
<tr class="separator:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1cb2e1046f84d6328600b92c99e52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57a1cb2e1046f84d6328600b92c99e52">succeeded</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:a57a1cb2e1046f84d6328600b92c99e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> corresponds to a success value.  <a href="#a57a1cb2e1046f84d6328600b92c99e52">More...</a><br /></td></tr>
<tr class="separator:a57a1cb2e1046f84d6328600b92c99e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:aeec13ab4fb753865cdfd2699aa01c23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> corresponds to a failure value.  <a href="#aeec13ab4fb753865cdfd2699aa01c23b">More...</a><br /></td></tr>
<tr class="separator:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3d17c70f67aa2d18203667acaf114"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46a3d17c70f67aa2d18203667acaf114">ceilDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a46a3d17c70f67aa2d18203667acaf114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's ceildiv operation on constants.  <a href="#a46a3d17c70f67aa2d18203667acaf114">More...</a><br /></td></tr>
<tr class="separator:a46a3d17c70f67aa2d18203667acaf114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3983eab6c9a05efd28747c0e79dd9d44">floorDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a3983eab6c9a05efd28747c0e79dd9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's floordiv operation on constants.  <a href="#a3983eab6c9a05efd28747c0e79dd9d44">More...</a><br /></td></tr>
<tr class="separator:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca33cad5b0cd935568ea0fc0a439abd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:afca33cad5b0cd935568ea0fc0a439abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns MLIR's mod operation on constants.  <a href="#afca33cad5b0cd935568ea0fc0a439abd">More...</a><br /></td></tr>
<tr class="separator:afca33cad5b0cd935568ea0fc0a439abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f7a5c72c1e0e867f3aac796b26ec2aa">lcm</a> (int64_t a, int64_t b)</td></tr>
<tr class="memdesc:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the least common multiple of 'a' and 'b'.  <a href="#a5f7a5c72c1e0e867f3aac796b26ec2aa">More...</a><br /></td></tr>
<tr class="separator:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25555f0964e7a67b96b5fc89f1bee1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a25555f0964e7a67b96b5fc89f1bee1fc">MlirOptMain</a> (llvm::raw_ostream &amp;outputStream, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, const <a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a> &amp;passPipeline, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, bool splitInputFile, bool verifyDiagnostics, bool verifyPasses, bool allowUnregisteredDialects, bool preloadDialectsInContext=true)</td></tr>
<tr class="memdesc:a25555f0964e7a67b96b5fc89f1bee1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the core processing behind <code>mlir-opt</code>:  <a href="#a25555f0964e7a67b96b5fc89f1bee1fc">More...</a><br /></td></tr>
<tr class="separator:a25555f0964e7a67b96b5fc89f1bee1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5529e09fff7b03bab31277d063302a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5529e09fff7b03bab31277d063302a7b">MlirOptMain</a> (int argc, char **argv, llvm::StringRef toolName, <a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry, bool preloadDialectsInContext=true)</td></tr>
<tr class="memdesc:a5529e09fff7b03bab31277d063302a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for tools like <code>mlir-opt</code>.  <a href="#a5529e09fff7b03bab31277d063302a7b">More...</a><br /></td></tr>
<tr class="separator:a5529e09fff7b03bab31277d063302a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2320d5e3423bb76edf4048a5674f8f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2320d5e3423bb76edf4048a5674f8f8e">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> processChunkBuffer, raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a2320d5e3423bb76edf4048a5674f8f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>.  <a href="#a2320d5e3423bb76edf4048a5674f8f8e">More...</a><br /></td></tr>
<tr class="separator:a2320d5e3423bb76edf4048a5674f8f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb3bcc9d23b2cfd1367b84f5b00b7c1">hash_value</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a>.  <a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">More...</a><br /></td></tr>
<tr class="separator:aafb3bcc9d23b2cfd1367b84f5b00b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320cb8d8764e198852aed80f389a0fc7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a320cb8d8764e198852aed80f389a0fc7">translateModuleToLLVMIR</a> (<a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> m, llvm::LLVMContext &amp;llvmContext, StringRef name=&quot;LLVMDialectModule&quot;)</td></tr>
<tr class="memdesc:a320cb8d8764e198852aed80f389a0fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given MLIR module into <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="#a320cb8d8764e198852aed80f389a0fc7">More...</a><br /></td></tr>
<tr class="separator:a320cb8d8764e198852aed80f389a0fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41497963c69c44476e78ff2043d4651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae41497963c69c44476e78ff2043d4651">translateLLVMIRToModule</a> (std::unique_ptr&lt; llvm::Module &gt; llvmModule, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae41497963c69c44476e78ff2043d4651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into MLIR's <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#ae41497963c69c44476e78ff2043d4651">More...</a><br /></td></tr>
<tr class="separator:ae41497963c69c44476e78ff2043d4651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90c4b2d1ff332cdf4a0b040d53a89be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab90c4b2d1ff332cdf4a0b040d53a89be">translateModuleToNVVMIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *m, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;)</td></tr>
<tr class="memdesc:ab90c4b2d1ff332cdf4a0b040d53a89be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> IR.  <a href="#ab90c4b2d1ff332cdf4a0b040d53a89be">More...</a><br /></td></tr>
<tr class="separator:ab90c4b2d1ff332cdf4a0b040d53a89be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab089f0f6a252963ae74f63d293294b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abab089f0f6a252963ae74f63d293294b">translateModuleToROCDLIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *m, llvm::LLVMContext &amp;llvmContext, llvm::StringRef name=&quot;LLVMDialectModule&quot;)</td></tr>
<tr class="memdesc:abab089f0f6a252963ae74f63d293294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> IR.  <a href="#abab089f0f6a252963ae74f63d293294b">More...</a><br /></td></tr>
<tr class="separator:abab089f0f6a252963ae74f63d293294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97db3d8a0876c380ebbfb94dea141e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97db3d8a0876c380ebbfb94dea141e31">populateBufferizeMaterializationLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a97db3d8a0876c380ebbfb94dea141e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a>.  <a href="#a97db3d8a0876c380ebbfb94dea141e31">More...</a><br /></td></tr>
<tr class="separator:a97db3d8a0876c380ebbfb94dea141e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28503c96b0a48e02a84f1d7648c0170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab28503c96b0a48e02a84f1d7648c0170">populateEliminateBufferizeMaterializationsPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab28503c96b0a48e02a84f1d7648c0170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to eliminate bufferize materializations.  <a href="#ab28503c96b0a48e02a84f1d7648c0170">More...</a><br /></td></tr>
<tr class="separator:ab28503c96b0a48e02a84f1d7648c0170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f103c236da2f1bb3afc9ceff7ac13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923f103c236da2f1bb3afc9ceff7ac13">populateFuncOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a923f103c236da2f1bb3afc9ceff7ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the signature of a FuncOp with the given type converter.  <a href="#a923f103c236da2f1bb3afc9ceff7ac13">More...</a><br /></td></tr>
<tr class="separator:a923f103c236da2f1bb3afc9ceff7ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6268f08438649faf42c968a4c8e5a704"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6268f08438649faf42c968a4c8e5a704">applyPartialConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *unconvertedOps=nullptr)</td></tr>
<tr class="memdesc:a6268f08438649faf42c968a4c8e5a704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Below we define several entry points for operation conversion.  <a href="#a6268f08438649faf42c968a4c8e5a704">More...</a><br /></td></tr>
<tr class="separator:a6268f08438649faf42c968a4c8e5a704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911001f7e461558dfcd872ef275785bb"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a911001f7e461558dfcd872ef275785bb">applyPartialConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *unconvertedOps=nullptr)</td></tr>
<tr class="separator:a911001f7e461558dfcd872ef275785bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4f9a1fcf0c20f3a9b069afad4abb82"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d4f9a1fcf0c20f3a9b069afad4abb82">applyFullConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6d4f9a1fcf0c20f3a9b069afad4abb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a complete conversion on the given operations, and all nested operations.  <a href="#a6d4f9a1fcf0c20f3a9b069afad4abb82">More...</a><br /></td></tr>
<tr class="separator:a6d4f9a1fcf0c20f3a9b069afad4abb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8371addeca1af246453f7994287ac49"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8371addeca1af246453f7994287ac49">applyFullConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="separator:ac8371addeca1af246453f7994287ac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd26cf546c0d37b3b10fbd482ea9aa11"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd26cf546c0d37b3b10fbd482ea9aa11">applyAnalysisConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;convertedOps)</td></tr>
<tr class="memdesc:acd26cf546c0d37b3b10fbd482ea9aa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an analysis conversion on the given operations, and all nested operations.  <a href="#acd26cf546c0d37b3b10fbd482ea9aa11">More...</a><br /></td></tr>
<tr class="separator:acd26cf546c0d37b3b10fbd482ea9aa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aba1760c80d47df4f15a428560a3942"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7aba1760c80d47df4f15a428560a3942">applyAnalysisConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;convertedOps)</td></tr>
<tr class="separator:a7aba1760c80d47df4f15a428560a3942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb845851e1a4ea685e2cfe48bb98a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aadb845851e1a4ea685e2cfe48bb98a4b">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:aadb845851e1a4ea685e2cfe48bb98a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the regions of the specified operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner.  <a href="#aadb845851e1a4ea685e2cfe48bb98a4b">More...</a><br /></td></tr>
<tr class="separator:aadb845851e1a4ea685e2cfe48bb98a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63da384a40018f938b03ce066a5cd68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae63da384a40018f938b03ce066a5cd68">applyPatternsAndFoldGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, <a class="el" href="classunsigned.html">unsigned</a> maxIterations)</td></tr>
<tr class="memdesc:ae63da384a40018f938b03ce066a5cd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the regions of the specified operation, with a user-provided limit on iterations to attempt before reaching convergence.  <a href="#ae63da384a40018f938b03ce066a5cd68">More...</a><br /></td></tr>
<tr class="separator:ae63da384a40018f938b03ce066a5cd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdc8625282e52ff0630d2c541452321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bdc8625282e52ff0630d2c541452321">applyPatternsAndFoldGreedily</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0bdc8625282e52ff0630d2c541452321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the given regions, which must be isolated from above.  <a href="#a0bdc8625282e52ff0630d2c541452321">More...</a><br /></td></tr>
<tr class="separator:a0bdc8625282e52ff0630d2c541452321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3f535f3e48c319294e4c467292cae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aff3f535f3e48c319294e4c467292cae5">applyPatternsAndFoldGreedily</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, <a class="el" href="classunsigned.html">unsigned</a> maxIterations)</td></tr>
<tr class="memdesc:aff3f535f3e48c319294e4c467292cae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the given regions, with a user-provided limit on iterations to attempt before reaching convergence.  <a href="#aff3f535f3e48c319294e4c467292cae5">More...</a><br /></td></tr>
<tr class="separator:aff3f535f3e48c319294e4c467292cae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae820093768939399186e9256eb789ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae820093768939399186e9256eb789ffb">applyOpPatternsAndFold</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;patterns, bool *erased=nullptr)</td></tr>
<tr class="memdesc:ae820093768939399186e9256eb789ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the specified patterns on <code>op</code> alone while also trying to fold it, by selecting the highest benefits patterns in a greedy manner.  <a href="#ae820093768939399186e9256eb789ffb">More...</a><br /></td></tr>
<tr class="separator:ae820093768939399186e9256eb789ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bc0a33de855f1c9a1a0ccfd8665e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a20bc0a33de855f1c9a1a0ccfd8665e78">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapper, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> regionResultTypes, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a20bc0a33de855f1c9a1a0ccfd8665e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a region, 'src', into another.  <a href="#a20bc0a33de855f1c9a1a0ccfd8665e78">More...</a><br /></td></tr>
<tr class="separator:a20bc0a33de855f1c9a1a0ccfd8665e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e080a2ba31bfcc4dd18b9a480051c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e080a2ba31bfcc4dd18b9a480051c74">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inlinedOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> resultsToReplace, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a6e080a2ba31bfcc4dd18b9a480051c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining.  <a href="#a6e080a2ba31bfcc4dd18b9a480051c74">More...</a><br /></td></tr>
<tr class="separator:a6e080a2ba31bfcc4dd18b9a480051c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa82b2f82348c0eacc76f1c4a862a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">inlineCall</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, CallOpInterface call, CallableOpInterface callable, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:afa82b2f82348c0eacc76f1c4a862a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation.  <a href="#afa82b2f82348c0eacc76f1c4a862a796">More...</a><br /></td></tr>
<tr class="separator:afa82b2f82348c0eacc76f1c4a862a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d3bd1afbf84ef9cca6c336a104d7280">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="#a2d3bd1afbf84ef9cca6c336a104d7280">More...</a><br /></td></tr>
<tr class="separator:a2d3bd1afbf84ef9cca6c336a104d7280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c6823f94d6ce99fa7da7547658345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af16c6823f94d6ce99fa7da7547658345">generateLocationsFromIR</a> (StringRef fileName, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:af16c6823f94d6ce99fa7da7547658345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="#af16c6823f94d6ce99fa7da7547658345">More...</a><br /></td></tr>
<tr class="separator:af16c6823f94d6ce99fa7da7547658345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9bde94caabba0feba96a044a09afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94e9bde94caabba0feba96a044a09afc">generateLocationsFromIR</a> (raw_ostream &amp;os, StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:a94e9bde94caabba0feba96a044a09afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream.  <a href="#a94e9bde94caabba0feba96a044a09afc">More...</a><br /></td></tr>
<tr class="separator:a94e9bde94caabba0feba96a044a09afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170389f5f17475f89037e332018b4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab170389f5f17475f89037e332018b4f8">generateLocationsFromIR</a> (StringRef fileName, StringRef tag, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags)</td></tr>
<tr class="memdesc:ab170389f5f17475f89037e332018b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="#ab170389f5f17475f89037e332018b4f8">More...</a><br /></td></tr>
<tr class="separator:ab170389f5f17475f89037e332018b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415fbf6253902c584461fa6a43a59ad5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a415fbf6253902c584461fa6a43a59ad5">createLocationSnapshotPass</a> (<a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags, StringRef fileName=&quot;&quot;, StringRef tag=&quot;&quot;)</td></tr>
<tr class="memdesc:a415fbf6253902c584461fa6a43a59ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file.  <a href="#a415fbf6253902c584461fa6a43a59ad5">More...</a><br /></td></tr>
<tr class="separator:a415fbf6253902c584461fa6a43a59ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb0bdadbeb0d7f5b8cef57668447640b">createLocationSnapshotPass</a> ()</td></tr>
<tr class="memdesc:abb0bdadbeb0d7f5b8cef57668447640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload utilizing pass options for initialization.  <a href="#abb0bdadbeb0d7f5b8cef57668447640b">More...</a><br /></td></tr>
<tr class="separator:abb0bdadbeb0d7f5b8cef57668447640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86843cd7c096abd53cde64b42a049140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a86843cd7c096abd53cde64b42a049140">canFuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *srcSlice, <a class="el" href="structmlir_1_1FusionStrategy.html">FusionStrategy</a> fusionStrategy={ <a class="el" href="structmlir_1_1FusionStrategy.html#af67d30ce20aaace9e674be9cae1001bfa190cb66109576270749d23427806eb6a">FusionStrategy::Generic</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>()})</td></tr>
<tr class="memdesc:a86843cd7c096abd53cde64b42a049140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'.  <a href="#a86843cd7c096abd53cde64b42a049140">More...</a><br /></td></tr>
<tr class="separator:a86843cd7c096abd53cde64b42a049140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36b4ab10b3417f15b045f8428a3f164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac36b4ab10b3417f15b045f8428a3f164">fuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;srcSlice)</td></tr>
<tr class="memdesc:ac36b4ab10b3417f15b045f8428a3f164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'.  <a href="#ac36b4ab10b3417f15b045f8428a3f164">More...</a><br /></td></tr>
<tr class="separator:ac36b4ab10b3417f15b045f8428a3f164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c56a4421761c1f8658aa16c292463"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b8c56a4421761c1f8658aa16c292463">getLoopNestStats</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> *stats)</td></tr>
<tr class="memdesc:a1b8c56a4421761c1f8658aa16c292463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect loop nest statistics (eg.  <a href="#a1b8c56a4421761c1f8658aa16c292463">More...</a><br /></td></tr>
<tr class="separator:a1b8c56a4421761c1f8658aa16c292463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eaf936f054b483e983fa6be1cb27f3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a61eaf936f054b483e983fa6be1cb27f3">getComputeCost</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;stats)</td></tr>
<tr class="memdesc:a61eaf936f054b483e983fa6be1cb27f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total cost of the loop nest rooted at 'forOp' using 'stats'.  <a href="#a61eaf936f054b483e983fa6be1cb27f3">More...</a><br /></td></tr>
<tr class="separator:a61eaf936f054b483e983fa6be1cb27f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde43535284e6667536f8ed8c7906063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afde43535284e6667536f8ed8c7906063">getFusionComputeCost</a> (AffineForOp srcForOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;srcStats, AffineForOp dstForOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;dstStats, const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, int64_t *computeCost)</td></tr>
<tr class="memdesc:afde43535284e6667536f8ed8c7906063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'.  <a href="#afde43535284e6667536f8ed8c7906063">More...</a><br /></td></tr>
<tr class="separator:afde43535284e6667536f8ed8c7906063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9a5f6331a28a90f85a2d8498fd6f801">loopUnrollFull</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation completely if the trip count is known to be constant.  <a href="#ab9a5f6331a28a90f85a2d8498fd6f801">More...</a><br /></td></tr>
<tr class="separator:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f3012781c34e4c455dcb89956d7983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69f3012781c34e4c455dcb89956d7983">loopUnrollByFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a69f3012781c34e4c455dcb89956d7983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="#a69f3012781c34e4c455dcb89956d7983">More...</a><br /></td></tr>
<tr class="separator:a69f3012781c34e4c455dcb89956d7983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c90b04191f7811b8be8e69264e9f26e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9c90b04191f7811b8be8e69264e9f26e">loopUnrollByFactor</a> (scf::ForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a9c90b04191f7811b8be8e69264e9f26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls 'forOp' by 'unrollFactor', returns success if the loop is unrolled.  <a href="#a9c90b04191f7811b8be8e69264e9f26e">More...</a><br /></td></tr>
<tr class="separator:a9c90b04191f7811b8be8e69264e9f26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a6ed1cfcc6232ad7dae507d67db6462">loopUnrollUpToFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this loop by the specified unroll factor or its trip count, whichever is lower.  <a href="#a4a6ed1cfcc6232ad7dae507d67db6462">More...</a><br /></td></tr>
<tr class="separator:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdac991f1476b0af97ff0620a3ddfdb3"><td class="memItemLeft" align="right" valign="top">bool LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abdac991f1476b0af97ff0620a3ddfdb3">isPerfectlyNested</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:abdac991f1476b0af97ff0620a3ddfdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>loops</code> is a perfectly nested loop nest, where loops appear in it from outermost to innermost.  <a href="#abdac991f1476b0af97ff0620a3ddfdb3">More...</a><br /></td></tr>
<tr class="separator:abdac991f1476b0af97ff0620a3ddfdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd53e808ea039aa9738dfab187468f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cd53e808ea039aa9738dfab187468f8">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;nestedLoops, AffineForOp root)</td></tr>
<tr class="memdesc:a7cd53e808ea039aa9738dfab187468f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="#a7cd53e808ea039aa9738dfab187468f8">More...</a><br /></td></tr>
<tr class="separator:a7cd53e808ea039aa9738dfab187468f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c6258ba17b3a08e25cde241861c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a002c6258ba17b3a08e25cde241861c3f">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;nestedLoops, scf::ForOp root)</td></tr>
<tr class="separator:a002c6258ba17b3a08e25cde241861c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a63b71c0fe3f345278eab205e10a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad67a63b71c0fe3f345278eab205e10a3">loopUnrollJamByFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:ad67a63b71c0fe3f345278eab205e10a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor.  <a href="#ad67a63b71c0fe3f345278eab205e10a3">More...</a><br /></td></tr>
<tr class="separator:ad67a63b71c0fe3f345278eab205e10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918847951e0d20706fe61380e119adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac918847951e0d20706fe61380e119adb">loopUnrollJamUpToFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:ac918847951e0d20706fe61380e119adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower.  <a href="#ac918847951e0d20706fe61380e119adb">More...</a><br /></td></tr>
<tr class="separator:ac918847951e0d20706fe61380e119adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f574bfd0dab3a0967cf1e3c77780fd4">promoteIfSingleIteration</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a AffineForOp/scf::ForOp to its containing block if the loop was known to have a single iteration.  <a href="#a9f574bfd0dab3a0967cf1e3c77780fd4">More...</a><br /></td></tr>
<tr class="separator:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e4727751a2af7968a7f722b77620ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab5e4727751a2af7968a7f722b77620ff">promoteIfSingleIteration</a> (scf::ForOp forOp)</td></tr>
<tr class="memdesc:ab5e4727751a2af7968a7f722b77620ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a forOp to its containing block if the forOp it can be determined that the loop has a single iteration.  <a href="#ab5e4727751a2af7968a7f722b77620ff">More...</a><br /></td></tr>
<tr class="separator:ab5e4727751a2af7968a7f722b77620ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3888bdf62ec2761952b4cd27770ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a30b3888bdf62ec2761952b4cd27770ef">promoteSingleIterationLoops</a> (FuncOp f)</td></tr>
<tr class="memdesc:a30b3888bdf62ec2761952b4cd27770ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="#a30b3888bdf62ec2761952b4cd27770ef">More...</a><br /></td></tr>
<tr class="separator:a30b3888bdf62ec2761952b4cd27770ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4e4aaa747cf34698887690a5b52d3f"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9a4e4aaa747cf34698887690a5b52d3f">affineForOpBodySkew</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts, bool unrollPrologueEpilogue=false)</td></tr>
<tr class="memdesc:a9a4e4aaa747cf34698887690a5b52d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew the operations in an affine.for's body with the specified operation-wise shifts.  <a href="#a9a4e4aaa747cf34698887690a5b52d3f">More...</a><br /></td></tr>
<tr class="separator:a9a4e4aaa747cf34698887690a5b52d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d63cba95be019caae3db4abae2937da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d63cba95be019caae3db4abae2937da">getTileableBands</a> (FuncOp f, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 6 &gt;&gt; *bands)</td></tr>
<tr class="memdesc:a6d63cba95be019caae3db4abae2937da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify valid and profitable bands of loops to tile.  <a href="#a6d63cba95be019caae3db4abae2937da">More...</a><br /></td></tr>
<tr class="separator:a6d63cba95be019caae3db4abae2937da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0191e64550dc17ce5ec5e35b74882"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#affb0191e64550dc17ce5ec5e35b74882">tilePerfectlyNested</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=nullptr)</td></tr>
<tr class="memdesc:affb0191e64550dc17ce5ec5e35b74882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops.  <a href="#affb0191e64550dc17ce5ec5e35b74882">More...</a><br /></td></tr>
<tr class="separator:affb0191e64550dc17ce5ec5e35b74882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7722fac9c5c7f3625d6a6fe1e2fbd52d"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7722fac9c5c7f3625d6a6fe1e2fbd52d">tilePerfectlyNestedParametric</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=nullptr)</td></tr>
<tr class="memdesc:a7722fac9c5c7f3625d6a6fe1e2fbd52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters.  <a href="#a7722fac9c5c7f3625d6a6fe1e2fbd52d">More...</a><br /></td></tr>
<tr class="separator:a7722fac9c5c7f3625d6a6fe1e2fbd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff3713bf5c6762b9f8239a980ded85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ff3713bf5c6762b9f8239a980ded85a">interchangeLoops</a> (AffineForOp forOpA, AffineForOp forOpB)</td></tr>
<tr class="memdesc:a9ff3713bf5c6762b9f8239a980ded85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs loop interchange on 'forOpA' and 'forOpB'.  <a href="#a9ff3713bf5c6762b9f8239a980ded85a">More...</a><br /></td></tr>
<tr class="separator:a9ff3713bf5c6762b9f8239a980ded85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd689ef70c61ee029b443673c78a04e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacd689ef70c61ee029b443673c78a04e">isValidLoopInterchangePermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; loopPermMap)</td></tr>
<tr class="memdesc:aacd689ef70c61ee029b443673c78a04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange).  <a href="#aacd689ef70c61ee029b443673c78a04e">More...</a><br /></td></tr>
<tr class="separator:aacd689ef70c61ee029b443673c78a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48413a8aa4dcee8ffa93b222cbedfd1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48413a8aa4dcee8ffa93b222cbedfd1b">permuteLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; inputNest, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permMap)</td></tr>
<tr class="memdesc:a48413a8aa4dcee8ffa93b222cbedfd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a loop permutation on a perfectly nested loop nest <code>inputNest</code> (where the contained loops appear from outer to inner) as specified by the permutation <code>permMap</code>: loop 'i' in <code>inputNest</code> is mapped to location 'loopPermMap[i]', where positions 0, 1, ...  <a href="#a48413a8aa4dcee8ffa93b222cbedfd1b">More...</a><br /></td></tr>
<tr class="separator:a48413a8aa4dcee8ffa93b222cbedfd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e57efabe41ec9f1d263ed7a42c7f15"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4e57efabe41ec9f1d263ed7a42c7f15">sinkSequentialLoops</a> (AffineForOp forOp)</td></tr>
<tr class="separator:ad4e57efabe41ec9f1d263ed7a42c7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623f987acfe618f9aa4823d6c7aec9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a623f987acfe618f9aa4823d6c7aec9d6">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="separator:a623f987acfe618f9aa4823d6c7aec9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab15bd4c107bb9ea52b7fcc11c283c129">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; targets)</td></tr>
<tr class="separator:ab15bd4c107bb9ea52b7fcc11c283c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8605009295454f6ebebbbaed546f7963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8605009295454f6ebebbbaed546f7963">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, AffineForOp target)</td></tr>
<tr class="memdesc:a8605009295454f6ebebbbaed546f7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="#a8605009295454f6ebebbbaed546f7963">More...</a><br /></td></tr>
<tr class="separator:a8605009295454f6ebebbbaed546f7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adb3ac25a4d763e0e5234f6b347c7f17a">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, scf::ForOp target)</td></tr>
<tr class="separator:adb3ac25a4d763e0e5234f6b347c7f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76588ffa46e04caaa584360fa5cdde4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76588ffa46e04caaa584360fa5cdde4c">tilePerfectlyNested</a> (scf::ForOp rootForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes)</td></tr>
<tr class="memdesc:a76588ffa46e04caaa584360fa5cdde4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes.  <a href="#a76588ffa46e04caaa584360fa5cdde4c">More...</a><br /></td></tr>
<tr class="separator:a76588ffa46e04caaa584360fa5cdde4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e92b2877dd22568dffce49e740b8d93"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e92b2877dd22568dffce49e740b8d93">affineDataCopyGenerate</a> (<a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; filterMemRef, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;copyNests)</td></tr>
<tr class="memdesc:a6e92b2877dd22568dffce49e740b8d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs explicit copying for the contiguous sequence of operations in the block iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>.  <a href="#a6e92b2877dd22568dffce49e740b8d93">More...</a><br /></td></tr>
<tr class="separator:a6e92b2877dd22568dffce49e740b8d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959a8e44d1e8895073035843de275b2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3959a8e44d1e8895073035843de275b2">affineDataCopyGenerate</a> (AffineForOp forOp, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; filterMemRef, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;copyNests)</td></tr>
<tr class="memdesc:a3959a8e44d1e8895073035843de275b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version of affineDataCopyGenerate for all ops in the body of an AffineForOp.  <a href="#a3959a8e44d1e8895073035843de275b2">More...</a><br /></td></tr>
<tr class="separator:a3959a8e44d1e8895073035843de275b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4e3e10aeb7dc1e0f93a00c4a3723c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac4e3e10aeb7dc1e0f93a00c4a3723c0">generateCopyForMemRegion</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;memrefRegion, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *analyzedOp, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="structmlir_1_1CopyGenerateResult.html">CopyGenerateResult</a> &amp;result)</td></tr>
<tr class="memdesc:aac4e3e10aeb7dc1e0f93a00c4a3723c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateCopyForMemRegion is similar to affineDataCopyGenerate, but works with a single memref region.  <a href="#aac4e3e10aeb7dc1e0f93a00c4a3723c0">More...</a><br /></td></tr>
<tr class="separator:aac4e3e10aeb7dc1e0f93a00c4a3723c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aecdaa20d0acb7aec0f05cb700b1e09df">extractFixedOuterLoops</a> (scf::ForOp rootFOrOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="memdesc:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>.  <a href="#aecdaa20d0acb7aec0f05cb700b1e09df">More...</a><br /></td></tr>
<tr class="separator:aecdaa20d0acb7aec0f05cb700b1e09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f13b0be0ce31ecaf0272879eace768b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1f13b0be0ce31ecaf0272879eace768b">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a1f13b0be0ce31ecaf0272879eace768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="#a1f13b0be0ce31ecaf0272879eace768b">More...</a><br /></td></tr>
<tr class="separator:a1f13b0be0ce31ecaf0272879eace768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a225e1cd29fad1b00f569d9567bc6cb2e">collapseParallelLoops</a> (scf::ParallelOp loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt; combinedDimensions)</td></tr>
<tr class="memdesc:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension.  <a href="#a225e1cd29fad1b00f569d9567bc6cb2e">More...</a><br /></td></tr>
<tr class="separator:a225e1cd29fad1b00f569d9567bc6cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc308b7190d3d087a4c12adb23b387b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abdc308b7190d3d087a4c12adb23b387b">mapLoopToProcessorIds</a> (scf::ForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; processorId, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; numProcessors)</td></tr>
<tr class="memdesc:abdc308b7190d3d087a4c12adb23b387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>.  <a href="#abdc308b7190d3d087a4c12adb23b387b">More...</a><br /></td></tr>
<tr class="separator:abdc308b7190d3d087a4c12adb23b387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419814bc8dbc6700ad0e76e437acacc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a419814bc8dbc6700ad0e76e437acacc0">gatherLoops</a> (FuncOp func, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;depthToLoops)</td></tr>
<tr class="memdesc:a419814bc8dbc6700ad0e76e437acacc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all AffineForOps in 'func' grouped by loop depth.  <a href="#a419814bc8dbc6700ad0e76e437acacc0">More...</a><br /></td></tr>
<tr class="separator:a419814bc8dbc6700ad0e76e437acacc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd7d19be1ff3cc542143dfd3f1c272a"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cd7d19be1ff3cc542143dfd3f1c272a">createCanonicalizedAffineForOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbOperands, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubOperands, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> ubMap, int64_t step=1)</td></tr>
<tr class="memdesc:a7cd7d19be1ff3cc542143dfd3f1c272a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AffineForOp while ensuring that the lower and upper bounds are canonicalized, i.e., unused and duplicate operands are removed, any constant operands propagated/folded in, and duplicate bound maps dropped.  <a href="#a7cd7d19be1ff3cc542143dfd3f1c272a">More...</a><br /></td></tr>
<tr class="separator:a7cd7d19be1ff3cc542143dfd3f1c272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58dea8a192531cbf60dd5238c0ba8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3e58dea8a192531cbf60dd5238c0ba8a">separateFullTiles</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; nest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *fullTileNest=nullptr)</td></tr>
<tr class="memdesc:a3e58dea8a192531cbf60dd5238c0ba8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates full tiles from partial tiles for a perfect nest <code>nest</code> by generating a conditional guard that selects between the full tile version and the partial tile version using an AffineIfOp.  <a href="#a3e58dea8a192531cbf60dd5238c0ba8a">More...</a><br /></td></tr>
<tr class="separator:a3e58dea8a192531cbf60dd5238c0ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bde3ce64d571a88aefe7dc3bbca323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4bde3ce64d571a88aefe7dc3bbca323">moveLoopInvariantCode</a> (LoopLikeOpInterface looplike)</td></tr>
<tr class="memdesc:ae4bde3ce64d571a88aefe7dc3bbca323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move loop invariant code out of <code>looplike</code>.  <a href="#ae4bde3ce64d571a88aefe7dc3bbca323">More...</a><br /></td></tr>
<tr class="separator:ae4bde3ce64d571a88aefe7dc3bbca323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77905fe4592bbcf12db456795a71c4e4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a77905fe4592bbcf12db456795a71c4e4">createBufferDeallocationPass</a> ()</td></tr>
<tr class="memdesc:a77905fe4592bbcf12db456795a71c4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the BufferDeallocation pass to free all allocated buffers.  <a href="#a77905fe4592bbcf12db456795a71c4e4">More...</a><br /></td></tr>
<tr class="separator:a77905fe4592bbcf12db456795a71c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73638eb9bd43c7c9d80ad84ca18feed9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a73638eb9bd43c7c9d80ad84ca18feed9">createBufferHoistingPass</a> ()</td></tr>
<tr class="memdesc:a73638eb9bd43c7c9d80ad84ca18feed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass.  <a href="#a73638eb9bd43c7c9d80ad84ca18feed9">More...</a><br /></td></tr>
<tr class="separator:a73638eb9bd43c7c9d80ad84ca18feed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c7580bd3f0770bf2dce00a6f1f9b33"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a44c7580bd3f0770bf2dce00a6f1f9b33">createBufferLoopHoistingPass</a> ()</td></tr>
<tr class="memdesc:a44c7580bd3f0770bf2dce00a6f1f9b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards out of loops.  <a href="#a44c7580bd3f0770bf2dce00a6f1f9b33">More...</a><br /></td></tr>
<tr class="separator:a44c7580bd3f0770bf2dce00a6f1f9b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3ceb6839e2fb42db15365105290b24"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f3ceb6839e2fb42db15365105290b24">createPromoteBuffersToStackPass</a> (<a class="el" href="classunsigned.html">unsigned</a> maxAllocSizeInBytes=1024, <a class="el" href="classunsigned.html">unsigned</a> bitwidthOfIndexType=64, <a class="el" href="classunsigned.html">unsigned</a> maxRankOfAllocatedMemRef=1)</td></tr>
<tr class="memdesc:a5f3ceb6839e2fb42db15365105290b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="#a5f3ceb6839e2fb42db15365105290b24">More...</a><br /></td></tr>
<tr class="separator:a5f3ceb6839e2fb42db15365105290b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fd271d3415a3e2578af827b936c957"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a24fd271d3415a3e2578af827b936c957">createFinalizingBufferizePass</a> ()</td></tr>
<tr class="memdesc:a24fd271d3415a3e2578af827b936c957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finalizes a partial bufferization by removing remaining tensor_load and tensor_to_memref operations.  <a href="#a24fd271d3415a3e2578af827b936c957">More...</a><br /></td></tr>
<tr class="separator:a24fd271d3415a3e2578af827b936c957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad511db48e4d4767cd251eb7e7400e896"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad511db48e4d4767cd251eb7e7400e896">createBufferResultsToOutParamsPass</a> ()</td></tr>
<tr class="memdesc:ad511db48e4d4767cd251eb7e7400e896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts memref function results to out-params.  <a href="#ad511db48e4d4767cd251eb7e7400e896">More...</a><br /></td></tr>
<tr class="separator:ad511db48e4d4767cd251eb7e7400e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0069355214b578476e81bc909f7f13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">createCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:aab0069355214b578476e81bc909f7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass.  <a href="#aab0069355214b578476e81bc909f7f13">More...</a><br /></td></tr>
<tr class="separator:aab0069355214b578476e81bc909f7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1c13054dd9f29cef7fd20d09f684c8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7e1c13054dd9f29cef7fd20d09f684c8">createCopyRemovalPass</a> ()</td></tr>
<tr class="memdesc:a7e1c13054dd9f29cef7fd20d09f684c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that removes unnecessary Copy operations.  <a href="#a7e1c13054dd9f29cef7fd20d09f684c8">More...</a><br /></td></tr>
<tr class="separator:a7e1c13054dd9f29cef7fd20d09f684c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14895da9723acd9c7f910c2694ff9f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">createCSEPass</a> ()</td></tr>
<tr class="memdesc:a14895da9723acd9c7f910c2694ff9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform common sub expression elimination.  <a href="#a14895da9723acd9c7f910c2694ff9f65">More...</a><br /></td></tr>
<tr class="separator:a14895da9723acd9c7f910c2694ff9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d8be1adb94ed50220c9c44d0caa362"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6d8be1adb94ed50220c9c44d0caa362">createLoopFusionPass</a> (<a class="el" href="classunsigned.html">unsigned</a> fastMemorySpace=0, uint64_t localBufSizeThreshold=0, bool maximalFusion=false)</td></tr>
<tr class="memdesc:aa6d8be1adb94ed50220c9c44d0caa362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses loops.  <a href="#aa6d8be1adb94ed50220c9c44d0caa362">More...</a><br /></td></tr>
<tr class="separator:aa6d8be1adb94ed50220c9c44d0caa362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fde65e573dbc3a947d58196cb2b3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">createLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a319fde65e573dbc3a947d58196cb2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop.  <a href="#a319fde65e573dbc3a947d58196cb2b3a">More...</a><br /></td></tr>
<tr class="separator:a319fde65e573dbc3a947d58196cb2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb9cf05fcdd6618fe542c7126cd30ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7fb9cf05fcdd6618fe542c7126cd30ec">createPipelineDataTransferPass</a> ()</td></tr>
<tr class="memdesc:a7fb9cf05fcdd6618fe542c7126cd30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy.  <a href="#a7fb9cf05fcdd6618fe542c7126cd30ec">More...</a><br /></td></tr>
<tr class="separator:a7fb9cf05fcdd6618fe542c7126cd30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebeb1f710273219157ff4b10d6577b8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aebeb1f710273219157ff4b10d6577b8d">createLoopCoalescingPass</a> ()</td></tr>
<tr class="memdesc:aebeb1f710273219157ff4b10d6577b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms perfectly nested loops with independent bounds into a single loop.  <a href="#aebeb1f710273219157ff4b10d6577b8d">More...</a><br /></td></tr>
<tr class="separator:aebeb1f710273219157ff4b10d6577b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525d8e77b6503a81d7aa03b636c98e2e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a525d8e77b6503a81d7aa03b636c98e2e">createParallelLoopCollapsingPass</a> ()</td></tr>
<tr class="memdesc:a525d8e77b6503a81d7aa03b636c98e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables.  <a href="#a525d8e77b6503a81d7aa03b636c98e2e">More...</a><br /></td></tr>
<tr class="separator:a525d8e77b6503a81d7aa03b636c98e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cac3d49263cfecc05b77c0fd4c2074"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a37cac3d49263cfecc05b77c0fd4c2074">createMemRefDataFlowOptPass</a> ()</td></tr>
<tr class="memdesc:a37cac3d49263cfecc05b77c0fd4c2074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform optimizations relying on memref dataflow such as store to load forwarding, elimination of dead stores, and dead allocs.  <a href="#a37cac3d49263cfecc05b77c0fd4c2074">More...</a><br /></td></tr>
<tr class="separator:a37cac3d49263cfecc05b77c0fd4c2074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b152134b4d44a148dac8bfc24070dcd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3b152134b4d44a148dac8bfc24070dcd">createStripDebugInfoPass</a> ()</td></tr>
<tr class="memdesc:a3b152134b4d44a148dac8bfc24070dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <a href="#a3b152134b4d44a148dac8bfc24070dcd">More...</a><br /></td></tr>
<tr class="separator:a3b152134b4d44a148dac8bfc24070dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d86bdab25e38eed8e3ab9a35012b1e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d86bdab25e38eed8e3ab9a35012b1e8">createPrintOpStatsPass</a> ()</td></tr>
<tr class="memdesc:a2d86bdab25e38eed8e3ab9a35012b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which prints the list of ops and the number of occurrences in the module.  <a href="#a2d86bdab25e38eed8e3ab9a35012b1e8">More...</a><br /></td></tr>
<tr class="separator:a2d86bdab25e38eed8e3ab9a35012b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">createInlinerPass</a> ()</td></tr>
<tr class="memdesc:a6c6ad0644a283c257d1fbc15be6adc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="#a6c6ad0644a283c257d1fbc15be6adc18">More...</a><br /></td></tr>
<tr class="separator:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1372ce1294d9b98b652930aa6baf1386"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1372ce1294d9b98b652930aa6baf1386">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines)</td></tr>
<tr class="memdesc:a1372ce1294d9b98b652930aa6baf1386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="#a1372ce1294d9b98b652930aa6baf1386">More...</a><br /></td></tr>
<tr class="separator:a1372ce1294d9b98b652930aa6baf1386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c5dd15c86ea433c8b83b1133a9a322"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a17c5dd15c86ea433c8b83b1133a9a322">createInlinerPass</a> (llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt; opPipelines, std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt; defaultPipelineBuilder)</td></tr>
<tr class="memdesc:a17c5dd15c86ea433c8b83b1133a9a322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type.  <a href="#a17c5dd15c86ea433c8b83b1133a9a322">More...</a><br /></td></tr>
<tr class="separator:a17c5dd15c86ea433c8b83b1133a9a322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119493f8c83de427f34658e5e39cbfe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6119493f8c83de427f34658e5e39cbfe">createSCCPPass</a> ()</td></tr>
<tr class="memdesc:a6119493f8c83de427f34658e5e39cbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which performs sparse conditional constant propagation over nested operations.  <a href="#a6119493f8c83de427f34658e5e39cbfe">More...</a><br /></td></tr>
<tr class="separator:a6119493f8c83de427f34658e5e39cbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69605e45210627de9b7fde4644fa50c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69605e45210627de9b7fde4644fa50c1">createSymbolDCEPass</a> ()</td></tr>
<tr class="memdesc:a69605e45210627de9b7fde4644fa50c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which delete symbol operations that are unreachable.  <a href="#a69605e45210627de9b7fde4644fa50c1">More...</a><br /></td></tr>
<tr class="separator:a69605e45210627de9b7fde4644fa50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f703ae55d1f56e11c4e263c7bdb6a36"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f703ae55d1f56e11c4e263c7bdb6a36">createNormalizeMemRefsPass</a> ()</td></tr>
<tr class="memdesc:a8f703ae55d1f56e11c4e263c7bdb6a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an interprocedural pass to normalize memrefs to have a trivial (identity) layout map.  <a href="#a8f703ae55d1f56e11c4e263c7bdb6a36">More...</a><br /></td></tr>
<tr class="separator:a8f703ae55d1f56e11c4e263c7bdb6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">areValuesDefinedAbove</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit)</td></tr>
<tr class="memdesc:ac680df79552c596c048cd9cb27638c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all values in the provided range are defined above the <code>limit</code> region.  <a href="#ac680df79552c596c048cd9cb27638c5f">More...</a><br /></td></tr>
<tr class="separator:ac680df79552c596c048cd9cb27638c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a5d204dd78ac563241168e6b2e40eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">replaceAllUsesInRegionWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> orig, <a class="el" href="classmlir_1_1Value.html">Value</a> replacement, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a15a5d204dd78ac563241168e6b2e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of <code>orig</code> within the given region with <code>replacement</code>.  <a href="#a15a5d204dd78ac563241168e6b2e40eb">More...</a><br /></td></tr>
<tr class="separator:a15a5d204dd78ac563241168e6b2e40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae644ec0854505ef60f12c23b96de595b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">visitUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:ae644ec0854505ef60f12c23b96de595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>.  <a href="#ae644ec0854505ef60f12c23b96de595b">More...</a><br /></td></tr>
<tr class="separator:ae644ec0854505ef60f12c23b96de595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">visitUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors.  <a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">More...</a><br /></td></tr>
<tr class="separator:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f633b099c2b8b42235818ba7bb70bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f633b099c2b8b42235818ba7bb70bc0">getUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a9f633b099c2b8b42235818ba7bb70bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants.  <a href="#a9f633b099c2b8b42235818ba7bb70bc0">More...</a><br /></td></tr>
<tr class="separator:a9f633b099c2b8b42235818ba7bb70bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabf77e050b8d684e39d2e5c760a2f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdabf77e050b8d684e39d2e5c760a2f0">getUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:afdabf77e050b8d684e39d2e5c760a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors.  <a href="#afdabf77e050b8d684e39d2e5c760a2f0">More...</a><br /></td></tr>
<tr class="separator:afdabf77e050b8d684e39d2e5c760a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303077ea0260053bc46cb584abb7767f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a303077ea0260053bc46cb584abb7767f">simplifyRegions</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a303077ea0260053bc46cb584abb7767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a set of structural simplifications over the given regions.  <a href="#a303077ea0260053bc46cb584abb7767f">More...</a><br /></td></tr>
<tr class="separator:a303077ea0260053bc46cb584abb7767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8fbbebc62328a945ae239955b846e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8b8fbbebc62328a945ae239955b846e">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *domInstFilter=nullptr, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *postDomInstFilter=nullptr, bool allowNonDereferencingOps=false, bool replaceInDeallocOp=false)</td></tr>
<tr class="memdesc:ac8b8fbbebc62328a945ae239955b846e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>.  <a href="#ac8b8fbbebc62328a945ae239955b846e">More...</a><br /></td></tr>
<tr class="separator:ac8b8fbbebc62328a945ae239955b846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a7944174565a109d7a5efe97cd62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e5a7944174565a109d7a5efe97cd62e">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, bool allowNonDereferencingOps=false)</td></tr>
<tr class="memdesc:a9e5a7944174565a109d7a5efe97cd62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well.  <a href="#a9e5a7944174565a109d7a5efe97cd62e">More...</a><br /></td></tr>
<tr class="separator:a9e5a7944174565a109d7a5efe97cd62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f3ffb3d4089a4a62f1b01ef2cc80df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4f3ffb3d4089a4a62f1b01ef2cc80df">normalizeMemRef</a> (AllocOp op)</td></tr>
<tr class="memdesc:ae4f3ffb3d4089a4a62f1b01ef2cc80df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the memref defined by this alloc op to have an identity layout map and updates all its indexing uses.  <a href="#ae4f3ffb3d4089a4a62f1b01ef2cc80df">More...</a><br /></td></tr>
<tr class="separator:ae4f3ffb3d4089a4a62f1b01ef2cc80df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139b18a8e4fed885a7c7040ac8c9a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad139b18a8e4fed885a7c7040ac8c9a42">normalizeMemRefType</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> memrefType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> builder, <a class="el" href="classunsigned.html">unsigned</a> numSymbolicOperands)</td></tr>
<tr class="memdesc:ad139b18a8e4fed885a7c7040ac8c9a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the old memref type map layout and computes the new memref type to have a new shape and a layout map, where the old layout map has been normalized to an identity layout map.  <a href="#ad139b18a8e4fed885a7c7040ac8c9a42">More...</a><br /></td></tr>
<tr class="separator:ad139b18a8e4fed885a7c7040ac8c9a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e839c359226fcf9fc26cb51ba6c3282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e839c359226fcf9fc26cb51ba6c3282">createComposedAffineApplyOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; affineApplyOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *results)</td></tr>
<tr class="memdesc:a4e839c359226fcf9fc26cb51ba6c3282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and inserts into 'builder' a new AffineApplyOp, with the number of its results equal to the number of operands, as a composition of all other AffineApplyOps reachable from input parameter 'operands'.  <a href="#a4e839c359226fcf9fc26cb51ba6c3282">More...</a><br /></td></tr>
<tr class="separator:a4e839c359226fcf9fc26cb51ba6c3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf452ef02d7d46f5c0f409ebb373b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aebf452ef02d7d46f5c0f409ebb373b92">createAffineComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *opInst, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *sliceOps)</td></tr>
<tr class="memdesc:aebf452ef02d7d46f5c0f409ebb373b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation.  <a href="#aebf452ef02d7d46f5c0f409ebb373b92">More...</a><br /></td></tr>
<tr class="separator:aebf452ef02d7d46f5c0f409ebb373b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6bf62f92ba677b78bd16aa0f34fd07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6b6bf62f92ba677b78bd16aa0f34fd07">viewGraph</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, const Twine &amp;name, bool shortNames=false, const Twine &amp;title=&quot;&quot;, llvm::GraphProgram::Name program=llvm::GraphProgram::DOT)</td></tr>
<tr class="memdesc:a6b6bf62f92ba677b78bd16aa0f34fd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the graph in a window.  <a href="#a6b6bf62f92ba677b78bd16aa0f34fd07">More...</a><br /></td></tr>
<tr class="separator:a6b6bf62f92ba677b78bd16aa0f34fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dab397b212cccb9be9497581485293"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9dab397b212cccb9be9497581485293">writeGraph</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="separator:aa9dab397b212cccb9be9497581485293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42ac202207527a00d55b96e72d27216"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae42ac202207527a00d55b96e72d27216">createPrintOpGraphPass</a> (raw_ostream &amp;os=llvm::errs(), bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="memdesc:ae42ac202207527a00d55b96e72d27216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print op graphs.  <a href="#ae42ac202207527a00d55b96e72d27216">More...</a><br /></td></tr>
<tr class="separator:ae42ac202207527a00d55b96e72d27216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb01423a036ce7642b34f08a4d39e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeeb01423a036ce7642b34f08a4d39e8b">viewGraph</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, const Twine &amp;name, bool shortNames=false, const Twine &amp;title=&quot;&quot;, llvm::GraphProgram::Name program=llvm::GraphProgram::DOT)</td></tr>
<tr class="memdesc:aeeb01423a036ce7642b34f08a4d39e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the CFG in a window.  <a href="#aeeb01423a036ce7642b34f08a4d39e8b">More...</a><br /></td></tr>
<tr class="separator:aeeb01423a036ce7642b34f08a4d39e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637269c766005364583ba36db13bacd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3637269c766005364583ba36db13bacd">writeGraph</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="separator:a3637269c766005364583ba36db13bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dc570ec82de616d9530aee07d2cfed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab6dc570ec82de616d9530aee07d2cfed">createPrintCFGGraphPass</a> (raw_ostream &amp;os=llvm::errs(), bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="memdesc:ab6dc570ec82de616d9530aee07d2cfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print CFG graphs.  <a href="#ab6dc570ec82de616d9530aee07d2cfed">More...</a><br /></td></tr>
<tr class="separator:ab6dc570ec82de616d9530aee07d2cfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8a2eef6c85897dbfc1b6437251776b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aea8a2eef6c85897dbfc1b6437251776b">mlirTranslateMain</a> (int argc, char **argv, llvm::StringRef toolName)</td></tr>
<tr class="memdesc:aea8a2eef6c85897dbfc1b6437251776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate to/from an MLIR module from/to an external representation (e.g.  <a href="#aea8a2eef6c85897dbfc1b6437251776b">More...</a><br /></td></tr>
<tr class="separator:aea8a2eef6c85897dbfc1b6437251776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfff33b4e364b14e039f109ea3d9669"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteDialect &gt; </td></tr>
<tr class="memitem:accfff33b4e364b14e039f109ea3d9669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#accfff33b4e364b14e039f109ea3d9669">registerDialect</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:accfff33b4e364b14e039f109ea3d9669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac235bc6229112b8d5ac18171be7d9d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac235bc6229112b8d5ac18171be7d9d8b">vectorizeAffineLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fastestVaryingPattern)</td></tr>
<tr class="memdesc:ac235bc6229112b8d5ac18171be7d9d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">External utility to vectorize affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <a href="#ac235bc6229112b8d5ac18171be7d9d8b">More...</a><br /></td></tr>
<tr class="separator:ac235bc6229112b8d5ac18171be7d9d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b336390b16983a364b2d95bd2a64a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2b336390b16983a364b2d95bd2a64a2f">registerTestRoundtripSPIRV</a> ()</td></tr>
<tr class="separator:a2b336390b16983a364b2d95bd2a64a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed913befc935e3b4b3e622838655b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ed913befc935e3b4b3e622838655b30">registerTestRoundtripDebugSPIRV</a> ()</td></tr>
<tr class="separator:a9ed913befc935e3b4b3e622838655b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2887883f00b094c5ca61c631d7b093a0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a> = 0</td></tr>
<tr class="memdesc:a2887883f00b094c5ca61c631d7b093a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout.  <a href="#a2887883f00b094c5ca61c631d7b093a0">More...</a><br /></td></tr>
<tr class="separator:a2887883f00b094c5ca61c631d7b093a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159f88d87b78c353731e1661c65a0b98"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a159f88d87b78c353731e1661c65a0b98">makeOptimizingTransformer</a> (<a class="el" href="classunsigned.html">unsigned</a> optLevel, <a class="el" href="classunsigned.html">unsigned</a> sizeLevel, llvm::TargetMachine *targetMachine)</td></tr>
<tr class="memdesc:a159f88d87b78c353731e1661c65a0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g.  <a href="#a159f88d87b78c353731e1661c65a0b98">More...</a><br /></td></tr>
<tr class="separator:a159f88d87b78c353731e1661c65a0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb0828d77d6958e5bc1fabe03734b5"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2aeb0828d77d6958e5bc1fabe03734b5">makeLLVMPassesTransformer</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; const llvm::PassInfo *&gt; llvmPasses, <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; mbOptLevel, llvm::TargetMachine *targetMachine, <a class="el" href="classunsigned.html">unsigned</a> optPassesInsertPos=0)</td></tr>
<tr class="memdesc:a2aeb0828d77d6958e5bc1fabe03734b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes explicitly specified, plus an optional optimization level, Any optimization passes, if present, will be inserted before the pass at position optPassesInsertPos.  <a href="#a2aeb0828d77d6958e5bc1fabe03734b5">More...</a><br /></td></tr>
<tr class="separator:a2aeb0828d77d6958e5bc1fabe03734b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c28c68e095c2f94534de768800107"><td class="memItemLeft" align="right" valign="top">const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a470c28c68e095c2f94534de768800107">kUnknownNumRegionInvocations</a> = -1</td></tr>
<tr class="separator:a470c28c68e095c2f94534de768800107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15e265851e534782cef307a4c775b46"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae15e265851e534782cef307a4c775b46">nullIndex</a> = std::numeric_limits&lt;int&gt;::max()</td></tr>
<tr class="separator:ae15e265851e534782cef307a4c775b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Include the generated interface declarations. </p>
<p>ValueType. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aad8f5011648c4f698028afb8a96b31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8f5011648c4f698028afb8a96b31ce">&#9670;&nbsp;</a></span>AttributeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">mlir::AttributeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00131">131</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="af5aaca5fea0016501841c1e98a14e7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aaca5fea0016501841c1e98a14e7ab">&#9670;&nbsp;</a></span>BlobGenerator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">mlir::BlobGenerator</a> = typedef std::function&lt;<a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">OwnedBlob</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00037">37</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="aafb0c2458571cd80ebb876d979e24346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0c2458571cd80ebb876d979e24346">&#9670;&nbsp;</a></span>ChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">mlir::ChunkBufferHandler</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00028">28</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="a759bdae349015b16ce375bdd46c1e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759bdae349015b16ce375bdd46c1e16c">&#9670;&nbsp;</a></span>DefaultAttributeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">mlir::DefaultAttributeStorage</a> = typedef <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for attributes that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00123">123</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a8b36f0e85767ed4e793d86f40bd8fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b36f0e85767ed4e793d86f40bd8fe55">&#9670;&nbsp;</a></span>DefaultTypeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">mlir::DefaultTypeStorage</a> = typedef <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for types that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00108">108</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="ad7f731697783a754f6f0e3821d1264b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f731697783a754f6f0e3821d1264b2">&#9670;&nbsp;</a></span>DenseMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">mlir::DenseMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00103">103</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a59d6aae8a616cd9d13c8b1edb1095948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d6aae8a616cd9d13c8b1edb1095948">&#9670;&nbsp;</a></span>DenseSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">mlir::DenseSet</a> = typedef <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00105">105</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a2e943fa4f63d44d69d846e504c16d5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e943fa4f63d44d69d846e504c16d5f6">&#9670;&nbsp;</a></span>DialectAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2e943fa4f63d44d69d846e504c16d5f6">mlir::DialectAllocatorFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8h_source.html#l00028">28</a> of file <a class="el" href="IR_2Dialect_8h_source.html">Dialect.h</a>.</p>

</div>
</div>
<a id="ac76a6e97fdeb03ac678bde155e380b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76a6e97fdeb03ac678bde155e380b7f">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">mlir::Direction</a> = typedef <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Simplex::Direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00014">14</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

</div>
</div>
<a id="aedbc3d0362a57c5175f05dd95fb59641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc3d0362a57c5175f05dd95fb59641">&#9670;&nbsp;</a></span>DominanceInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">mlir::DominanceInfoNode</a> = typedef llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dominance_8h_source.html#l00019">19</a> of file <a class="el" href="Dominance_8h_source.html">Dominance.h</a>.</p>

</div>
</div>
<a id="a899fdaa9e41cd3d5abb2b4cc44dba232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899fdaa9e41cd3d5abb2b4cc44dba232">&#9670;&nbsp;</a></span>FilterFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a899fdaa9e41cd3d5abb2b4cc44dba232">mlir::FilterFunctionType</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that: </p>
<ol type="1">
<li>recursively matches a substructure in the tree;</li>
<li>uses a filter function to refine matches with extra semantic constraints (passed via a lambda of type FilterFunctionType);</li>
<li>TODO: optionally applies actions (lambda).</li>
</ol>
<p>Nested patterns are meant to capture imperfectly nested loops while matching properties over the whole loop nest. For instance, in vectorization we are interested in capturing all the imperfectly nested loops of a certain type and such that all the load and stores have certain access patterns along the loops' induction variables). Such NestedMatches are first captured using the <code>match</code> function and are later processed to analyze properties and apply transformations in a non-greedy way.</p>
<p>The NestedMatches captured in the IR can grow large, especially after aggressive unrolling. As experience has shown, it is generally better to use a plain walk over operations to match flat patterns but the current implementation is competitive nonetheless. </p>

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00090">90</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a0bff6226b7c81b6134b8c1130403a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff6226b7c81b6134b8c1130403a172">&#9670;&nbsp;</a></span>function_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00126">126</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a4ddb6704fdaa06a1d6d81b12d73eac94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">&#9670;&nbsp;</a></span>GenFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">mlir::GenFunction</a> = typedef std::function&lt;bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator function to invoke. </p>

<p class="definition">Definition at line <a class="el" href="GenInfo_8h_source.html#l00024">24</a> of file <a class="el" href="GenInfo_8h_source.html">GenInfo.h</a>.</p>

</div>
</div>
<a id="ad5c8735b67af7a64e4deff16477a06eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c8735b67af7a64e4deff16477a06eb">&#9670;&nbsp;</a></span>Loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">mlir::Loops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8h_source.html#l00145">145</a> of file <a class="el" href="LoopUtils_8h_source.html">LoopUtils.h</a>.</p>

</div>
</div>
<a id="a594a45ae9aa1ccffd960f369da94d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a45ae9aa1ccffd960f369da94d156">&#9670;&nbsp;</a></span>LoweringCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">mlir::LoweringCallback</a> = typedef std::function&lt;std::unique_ptr&lt;llvm::Module&gt;( <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, llvm::LLVMContext &amp;, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00039">39</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a2bd440a077557b4421b2cfd06d48956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd440a077557b4421b2cfd06d48956a">&#9670;&nbsp;</a></span>NamedAttribute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">mlir::NamedAttribute</a> = typedef std::pair&lt;<a class="el" href="classmlir_1_1Identifier.html">Identifier</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NamedAttribute is combination of a name, represented by an <a class="el" href="classmlir_1_1Identifier.html" title="This class represents a uniqued string owned by an MLIRContext. ">Identifier</a>, and a value, represented by an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a>. </p>
<p>The attribute pointer should always be non-null. </p>

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00130">130</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="ab0887111bf825d1f766ef9e0911394d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0887111bf825d1f766ef9e0911394d5">&#9670;&nbsp;</a></span>OpAsmSetValueNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">mlir::OpAsmSetValueNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the start of a result group of an operation. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00869">869</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a3789e28c54bcaf5d2c3baf5f99eb615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789e28c54bcaf5d2c3baf5f99eb615f">&#9670;&nbsp;</a></span>OperandElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">mlir::OperandElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00077">77</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="afd0d8f38577d05b87e540d717a7ba9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0d8f38577d05b87e540d717a7ba9c5">&#9670;&nbsp;</a></span>OwnedBlob</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#afd0d8f38577d05b87e540d717a7ba9c5">mlir::OwnedBlob</a> = typedef std::unique_ptr&lt;std::vector&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUCommonPass_8h_source.html#l00035">35</a> of file <a class="el" href="GPUCommonPass_8h_source.html">GPUCommonPass.h</a>.</p>

</div>
</div>
<a id="a48db7fd5d49bfa7ca8c81e5a6a058683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db7fd5d49bfa7ca8c81e5a6a058683">&#9670;&nbsp;</a></span>PassAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">mlir::PassAllocatorFunction</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00037">37</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="af4ccb1e7accf2ec0c57b1aea967ccd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ccb1e7accf2ec0c57b1aea967ccd02">&#9670;&nbsp;</a></span>PassRegistryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">mlir::PassRegistryFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(const Twine &amp;)&gt; errorHandler)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A registry function that adds passes to the given pass manager. </p>
<p>This should also parse options and return <a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed" title="Utility function to generate a LogicalResult. ">success()</a> if parsing succeeded. <code>errorHandler</code> is a functor used to emit errors during parsing. parameter corresponds to the raw location within the pipeline string. This should always return failure. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00036">36</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="a5b512697c8dadec5de092fbd243ab4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b512697c8dadec5de092fbd243ab4f6">&#9670;&nbsp;</a></span>PDLConstraintFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a5b512697c8dadec5de092fbd243ab4f6">mlir::PDLConstraintFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic PDL pattern constraint function. </p>
<p>This function applies a constraint to a given set of opaque <a class="el" href="classmlir_1_1PDLValue.html" title="Storage type of byte-code interpreter values. ">PDLValue</a> entities. The second parameter is a set of constant value parameters specified in <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> form. Returns success if the constraint successfully held, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00312">312</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="acf4515fd1b2926432504b2fc92363e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4515fd1b2926432504b2fc92363e50">&#9670;&nbsp;</a></span>PDLCreateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#acf4515fd1b2926432504b2fc92363e50">mlir::PDLCreateFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native PDL creation function. </p>
<p>This function creates a new <a class="el" href="classmlir_1_1PDLValue.html" title="Storage type of byte-code interpreter values. ">PDLValue</a> given a set of existing PDL values, a set of constant parameters specified in <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> form, and a <a class="el" href="classmlir_1_1PatternRewriter.html" title="This class coordinates the application of a pattern to the current function, providing a way to creat...">PatternRewriter</a>. Returns the newly created <a class="el" href="classmlir_1_1PDLValue.html" title="Storage type of byte-code interpreter values. ">PDLValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00317">317</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="ab2b0c268d492a9759203e8be9992d2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b0c268d492a9759203e8be9992d2bc">&#9670;&nbsp;</a></span>PDLRewriteFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab2b0c268d492a9759203e8be9992d2bc">mlir::PDLRewriteFunction</a> = typedef std::function&lt;<a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&gt;, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native PDL rewrite function. </p>
<p>This function rewrites the given root operation using the provided <a class="el" href="classmlir_1_1PatternRewriter.html" title="This class coordinates the application of a pattern to the current function, providing a way to creat...">PatternRewriter</a>. This method is only invoked when the corresponding match was successful. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00322">322</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="aa6eb3af9c93fd73a80717bf5dc93276d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eb3af9c93fd73a80717bf5dc93276d">&#9670;&nbsp;</a></span>PDLSingleEntityConstraintFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa6eb3af9c93fd73a80717bf5dc93276d">mlir::PDLSingleEntityConstraintFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic PDL pattern constraint function. </p>
<p>This function applies a constraint to a given opaque <a class="el" href="classmlir_1_1PDLValue.html" title="Storage type of byte-code interpreter values. ">PDLValue</a> entity. The second parameter is a set of constant value parameters specified in <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> form. Returns success if the constraint successfully held, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00328">328</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a253b95ef2aaf79bdc612ae40fddc0732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b95ef2aaf79bdc612ae40fddc0732">&#9670;&nbsp;</a></span>ResultElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">mlir::ResultElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00094">94</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="ac2b3592ab67f8512cb18e62375d7ff4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b3592ab67f8512cb18e62375d7ff4b">&#9670;&nbsp;</a></span>StringSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorTy  = llvm::MallocAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac2b3592ab67f8512cb18e62375d7ff4b">mlir::StringSet</a> = typedef <a class="el" href="classllvm_1_1StringSet.html">llvm::StringSet</a>&lt;AllocatorTy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00107">107</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="ac474b9f30a56412e090d9919e4dd8b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac474b9f30a56412e090d9919e4dd8b34">&#9670;&nbsp;</a></span>StringSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac474b9f30a56412e090d9919e4dd8b34">mlir::StringSwitch</a> = typedef <a class="el" href="classllvm_1_1StringSwitch.html">llvm::StringSwitch</a>&lt;T, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00117">117</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a3f0d45d0562d47acc2c42934ccbfea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d45d0562d47acc2c42934ccbfea19">&#9670;&nbsp;</a></span>TileLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">mlir::TileLoops</a> = typedef std::pair&lt;<a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8h_source.html#l00146">146</a> of file <a class="el" href="LoopUtils_8h_source.html">LoopUtils.h</a>.</p>

</div>
</div>
<a id="a389845a5dc285d746b24f6012a0ca2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389845a5dc285d746b24f6012a0ca2e3">&#9670;&nbsp;</a></span>TransitiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">mlir::TransitiveFilter</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of the condition to limit the propagation of transitive use-defs. </p>
<p>This can be used in particular to limit the propagation to a given Scope or to avoid passing through certain types of operation in a configurable manner. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00027">27</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a13b54e61e2491e2bc91c54f8ef429cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b54e61e2491e2bc91c54f8ef429cfa">&#9670;&nbsp;</a></span>TranslateFromMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">mlir::TranslateFromMLIRFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classModuleOp.html">ModuleOp</a>, llvm::raw_ostream &amp;output)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates MLIR to a different format and outputs the result to a stream. </p>
<p>It is allowed to modify the module. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00047">47</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="addbb54b5d484b1a53b08f04871fb0da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbb54b5d484b1a53b08f04871fb0da8">&#9670;&nbsp;</a></span>TranslateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">mlir::TranslateFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( llvm::SourceMgr &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that performs file-to-file translation involving MLIR. </p>
<p>The input file is held in the given MemoryBuffer; the output file should be written to the given raw_ostream. The implementation should create all MLIR constructs needed during the process inside the given context. This can be used for round-tripping external formats through the MLIR system. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00055">55</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a16773901a5b8781f9be66507fad3c5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16773901a5b8781f9be66507fad3c5b4">&#9670;&nbsp;</a></span>TranslateSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a16773901a5b8781f9be66507fad3c5b4">mlir::TranslateSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR. </p>
<p>The source manager has at least one buffer. The implementation should create a new MLIR ModuleOp in the given context and return a pointer to it, or a nullptr in case of any error. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00035">35</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a995eefe8643c3770dfe42925733c17f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995eefe8643c3770dfe42925733c17f8">&#9670;&nbsp;</a></span>TranslateStringRefToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a995eefe8643c3770dfe42925733c17f8">mlir::TranslateStringRefToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the given string to MLIR. </p>
<p>The implementation should create a new MLIR ModuleOp in the given context. If source-related error reporting is required from within the function, use TranslateSourceMgrToMLIRFunction instead. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00042">42</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a01e9069ef9040ccc727d541c02d49ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e9069ef9040ccc727d541c02d49ecd">&#9670;&nbsp;</a></span>TypeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">mlir::TypeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a utility allocator used to allocate memory for instances of derived Types. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00116">116</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="abcf44d03780c99376ac0c1dd1caed0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf44d03780c99376ac0c1dd1caed0f4">&#9670;&nbsp;</a></span>TypeSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ResultT  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abcf44d03780c99376ac0c1dd1caed0f4">mlir::TypeSwitch</a> = typedef <a class="el" href="classllvm_1_1TypeSwitch.html">llvm::TypeSwitch</a>&lt;T, ResultT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00120">120</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="aa10a637dbeb6e0d2178032f95fb5ea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10a637dbeb6e0d2178032f95fb5ea1b">&#9670;&nbsp;</a></span>VectorizableLoopFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa10a637dbeb6e0d2178032f95fb5ea1b">mlir::VectorizableLoopFun</a> = typedef std::function&lt;bool(AffineForOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8h_source.html#l00063">63</a> of file <a class="el" href="LoopAnalysis_8h_source.html">LoopAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6d3b7fd763c24274db6c115579084133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b7fd763c24274db6c115579084133">&#9670;&nbsp;</a></span>AffineExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">mlir::AffineExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>RHS of mul is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"><p>RHS of mod is always a constant or a symbolic expression with a positive value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a"></a>FloorDiv&#160;</td><td class="fielddoc"><p>RHS of floordiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a"></a>CeilDiv&#160;</td><td class="fielddoc"><p>RHS of ceildiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24"></a>LAST_AFFINE_BINARY_OP&#160;</td><td class="fielddoc"><p>This is a marker for the last affine binary op. </p>
<p>The range of binary op's is expected to be this element and earlier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>Constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"><p>Dimensional identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"><p>Symbolic identifier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00038">38</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a247bc9a6d1f1577f2d876cb55e2ea752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247bc9a6d1f1577f2d876cb55e2ea752">&#9670;&nbsp;</a></span>DiagnosticSeverity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">mlir::DiagnosticSeverity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different supported severity of a diagnostic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec"></a>Note&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6"></a>Remark&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00039">39</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

</div>
</div>
<a id="a77f701680752dfb55505285ab8ce8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f701680752dfb55505285ab8ce8b55">&#9670;&nbsp;</a></span>IteratorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">mlir::IteratorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Typed representation for loop type strings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a77f701680752dfb55505285ab8ce8b55a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a77f701680752dfb55505285ab8ce8b55a9e834f13e35e4edf64863ab414a6217a"></a>Reduction&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00124">124</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a583774594e92d8af2d0884e3262d7e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583774594e92d8af2d0884e3262d7e24">&#9670;&nbsp;</a></span>OperationProperty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24">mlir::OperationProperty</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24ac9f87f9079df3ae77c58b9258f497dfb"></a>Commutative&#160;</td><td class="fielddoc"><p>This bit is set for an operation if it is a commutative operation: that is an operator where order of operands does not change the result of the operation. </p>
<p>For example, in a binary commutative operation, "a op b" and "b op a" produce the same results. </p>
</td></tr>
<tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24ab420c1d31e69a823fbc30a434907c9c0"></a>Terminator&#160;</td><td class="fielddoc"><p>This bit is set for an operation if it is a terminator: that means an operation at the end of a block. </p>
</td></tr>
<tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24aee504cc3a721fbb8c7898dcc0798d273"></a>IsolatedFromAbove&#160;</td><td class="fielddoc"><p>This bit is set for operations that are completely isolated from above. </p>
<p>This is used for operations whose regions are explicit capture only, i.e. they are never allowed to implicitly reference values defined above the parent operation. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00059">59</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

</div>
</div>
<a id="ab64460ede39d8480e398fd2e6810d95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64460ede39d8480e398fd2e6810d95b">&#9670;&nbsp;</a></span>PassDisplayMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">mlir::PassDisplayMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing the different display modes for the information within the pass manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135"></a>List&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72"></a>Pipeline&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00146">146</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="abeb30aa1b062bf437bf3ea2b843a2ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb30aa1b062bf437bf3ea2b843a2ae1">&#9670;&nbsp;</a></span>RegionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#abeb30aa1b062bf437bf3ea2b843a2ae1">mlir::RegionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of regions contained in an operation. </p>
<p>SSACFG regions require the SSA-Dominance property to hold. Graph regions do not require SSA-Dominance. If a registered operation does not implement RegionKindInterface, then any regions it contains are assumed to be SSACFG regions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1abfd486e5c2cad6a0ba13ec4e1951815b"></a>SSACFG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abeb30aa1b062bf437bf3ea2b843a2ae1a4cdbd2bafa8193091ba09509cedf94fd"></a>Graph&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="RegionKindInterface_8h_source.html#l00026">26</a> of file <a class="el" href="RegionKindInterface_8h_source.html">RegionKindInterface.h</a>.</p>

</div>
</div>
<a id="ae0a5f1311f5db69741663dd9e28a3c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a5f1311f5db69741663dd9e28a3c9b">&#9670;&nbsp;</a></span>SDBMExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9b">mlir::SDBMExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9baec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bace7566d1d08cc094b74cf283cf9c56a5"></a>Stripe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9ba49630f5d7723e9b41474bd1cb1887b9d"></a>Diff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9baea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bafb278fa5defd7e699fcbc930c3e76ccd"></a>Neg&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SDBMExpr_8h_source.html#l00026">26</a> of file <a class="el" href="SDBMExpr_8h_source.html">SDBMExpr.h</a>.</p>

</div>
</div>
<a id="a9e4d5a3d224089fd8a2ebc3e933d08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d5a3d224089fd8a2ebc3e933d08b5">&#9670;&nbsp;</a></span>TraversalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a9e4d5a3d224089fd8a2ebc3e933d08b5">mlir::TraversalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>traversal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ab8166871d66f03feaa6948b3f5727c96"></a>SinglePath&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5ad4f6ed581fb2f9d06c062711e30c13e1"></a>Backtrack&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9e4d5a3d224089fd8a2ebc3e933d08b5a9addc7d66f740728689b7f9abde66593"></a>MultiPath&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ReductionTreePass_8h_source.html#l00034">34</a> of file <a class="el" href="ReductionTreePass_8h_source.html">ReductionTreePass.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6e92b2877dd22568dffce49e740b8d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e92b2877dd22568dffce49e740b8d93">&#9670;&nbsp;</a></span>affineDataCopyGenerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>filterMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs explicit copying for the contiguous sequence of operations in the block iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>. </p>
<p>Returns the total size of fast memory space buffers used. <code>copyOptions</code> provides various parameters, and the output argument <code>copyNests</code> is the set of all copy nests inserted, each represented by its root affine.for. Since we generate alloc's and dealloc's for all fast buffers (before and after the range of operations resp. or at a hoisted position), all of the fast memory capacity is assumed to be available for processing this block range. When 'filterMemRef' is specified, copies are only generated for the provided MemRef. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02651">2651</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00286">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LoopUtils_8h_source.html#l00180">mlir::AffineCopyOptions::fastMemCapacityBytes</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02139">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02599">getFullMemRefAsRegion()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00944">getNestingDepth()</a>, <a class="el" href="LoopUtils_8h_source.html#l00174">mlir::AffineCopyOptions::slowMemorySpace</a>, and <a class="el" href="LogicalResult_8h_source.html#l00040">succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02842">affineDataCopyGenerate()</a>, and <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00087">createAffineDataCopyGenerationPass()</a>.</p>

</div>
</div>
<a id="a3959a8e44d1e8895073035843de275b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3959a8e44d1e8895073035843de275b2">&#9670;&nbsp;</a></span>affineDataCopyGenerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>filterMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version of affineDataCopyGenerate for all ops in the body of an AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02842">2842</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02651">affineDataCopyGenerate()</a>.</p>

</div>
</div>
<a id="a9a4e4aaa747cf34698887690a5b52d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4e4aaa747cf34698887690a5b52d3f">&#9670;&nbsp;</a></span>affineForOpBodySkew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::affineForOpBodySkew </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollPrologueEpilogue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skew the operations in an affine.for's body with the specified operation-wise shifts. </p>
<p>The shifts are with respect to the original execution order, and are multiplied by the loop 'step' before being applied. If <code>unrollPrologueEpilogue</code> is set, fully unroll the prologue and epilogue loops when possible. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00305">305</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00359">applyOpPatternsAndFold()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00250">generateShiftedLoop()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00340">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00361">isOpwiseShiftValid()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01031">loopUnrollFull()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00164">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="ab1784af818174409b28cc34095d17bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1784af818174409b28cc34095d17bc0">&#9670;&nbsp;</a></span>affineParallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affineParallelize </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces parallel affine.for op with 1-d affine.parallel op. </p>
<p>Replace affine.for with a 1-d affine.parallel and clone the former's body into the latter while remapping values.</p>
<p><a class="el" href="namespacemlir.html#a0d9c4fc904589c35cd742b2f96393ee2" title="Returns true if `forOp&#39; is a parallel loop. ">mlir::isLoopParallel</a> detect the parallel affine.for ops. There is no cost model currently used to drive this parallelization.</p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00134">134</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Attributes_8cpp_source.html#l00038">mlir::Attribute::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00168">mlir::AffineMap::getMultiDimIdentityMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>.</p>

</div>
</div>
<a id="acd26cf546c0d37b3b10fbd482ea9aa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd26cf546c0d37b3b10fbd482ea9aa11">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an analysis conversion on the given operations, and all nested operations. </p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'convertedOps' set; note that no actual rewrites are applied to the operations on success and only pre-existing operations are added to the set. This method only returns failure if there are unreachable blocks in any of the regions nested within 'ops'.</p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'convertedOps' set; note that no actual rewrites are applied to the operations on success and only pre-existing operations are added to the set. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02716">2716</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l02725">applyAnalysisConversion()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00726">mlir::ConversionTarget::isDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="a7aba1760c80d47df4f15a428560a3942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aba1760c80d47df4f15a428560a3942">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02725">2725</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02716">applyAnalysisConversion()</a>.</p>

</div>
</div>
<a id="abba549e24352340ea200e631850a404e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba549e24352340ea200e631850a404e">&#9670;&nbsp;</a></span>applyCmpPredicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::applyCmpPredicate </td>
          <td>(</td>
          <td class="paramtype">CmpIPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <code>lhs</code> <code>pred</code> <code>rhs</code>, where <code>pred</code> is one of the known integer comparison predicates. </p>

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l00780">780</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00237">mlir::edsc::op::eq()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00243">mlir::edsc::op::ne()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00267">mlir::edsc::op::sge()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00261">mlir::edsc::op::sgt()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00255">mlir::edsc::op::sle()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00249">mlir::edsc::op::slt()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00291">mlir::edsc::op::uge()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00285">mlir::edsc::op::ugt()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00279">mlir::edsc::op::ule()</a>, and <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00273">mlir::edsc::op::ult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>, <a class="el" href="Ops_8cpp_source.html#l00808">applyCmpPredicateToEqualOperands()</a>, and <a class="el" href="Ops_8h_source.html#l00297">mlir::DmaWaitOp::getNumElements()</a>.</p>

</div>
</div>
<a id="a6af079cfe2148bdcfafea66ac62d3407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af079cfe2148bdcfafea66ac62d3407">&#9670;&nbsp;</a></span>applyCmpPredicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::applyCmpPredicate </td>
          <td>(</td>
          <td class="paramtype">CmpFPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <code>lhs</code> <code>pred</code> <code>rhs</code>, where <code>pred</code> is one of the known floating point comparison predicates. </p>

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l00858">858</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="Ops_8cpp_source.html#l00780">applyCmpPredicate()</a>, <a class="el" href="Ops_8cpp_source.html#l00569">collapseBranch()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00775">mlir::IntegerType::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00301">mlir::IntegerAttr::get()</a>, <a class="el" href="Block_8cpp_source.html#l00237">mlir::Block::getSinglePredecessor()</a>, <a class="el" href="Block_8cpp_source.html#l00216">mlir::Block::getTerminator()</a>, <a class="el" href="Block_8cpp_source.html#l00248">mlir::Block::getUniquePredecessor()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00226">mlir::FloatAttr::getValue()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="Matchers_8h_source.html#l00238">m_NonZero()</a>, <a class="el" href="Matchers_8h_source.html#l00232">m_Zero()</a>, <a class="el" href="Matchers_8h_source.html#l00244">matchPattern()</a>, <a class="el" href="PatternMatch_8h_source.html#l00458">mlir::PatternRewriter::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a6d4f9a1fcf0c20f3a9b069afad4abb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4f9a1fcf0c20f3a9b069afad4abb82">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a complete conversion on the given operations, and all nested operations. </p>
<p>This method returns failure if the conversion of any operation fails, or if there are unreachable blocks in any of the regions nested within 'ops'.</p>
<p>This method will return failure if the conversion of any operation fails. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02698">2698</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l02704">applyFullConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00726">mlir::ConversionTarget::isDynamicallyLegal()</a>, <a class="el" href="Transforms_2Bufferize_8cpp_source.html#l00085">populateEliminateBufferizeMaterializationsPatterns()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00187">mlir::linalg::populateLinalgToStandardConversionPatterns()</a>, <a class="el" href="DecorateSPIRVCompositeTypeLayoutPass_8cpp_source.html#l00077">populateSPIRVLayoutInfoPatterns()</a>, and <a class="el" href="VectorToSPIRV_8cpp_source.html#l00120">populateVectorToSPIRVPatterns()</a>.</p>

</div>
</div>
<a id="ac8371addeca1af246453f7994287ac49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8371addeca1af246453f7994287ac49">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02704">2704</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02698">applyFullConversion()</a>.</p>

</div>
</div>
<a id="ae820093768939399186e9256eb789ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae820093768939399186e9256eb789ffb">&#9670;&nbsp;</a></span>applyOpPatternsAndFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyOpPatternsAndFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>erased</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the specified patterns on <code>op</code> alone while also trying to fold it, by selecting the highest benefits patterns in a greedy manner. </p>
<p>Rewrites only <code>op</code> using the supplied canonicalization patterns and folding.</p>
<p>Returns success if no more patterns can be matched. <code>erased</code> is set to true if <code>op</code> was folded away or erased as a result of becoming dead. Note: This does not apply any patterns recursively to the regions of <code>op</code>.</p>
<p><code>erased</code> is set to true if the op is erased as a result of being folded, replaced, or dead. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00359">359</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, and <a class="el" href="Operation_8cpp_source.html#l00214">mlir::Operation::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00305">affineForOpBodySkew()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00087">createAffineDataCopyGenerationPass()</a>, <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00075">createSimplifyAffineStructuresPass()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">hoistAffineIfOp()</a>.</p>

</div>
</div>
<a id="a6268f08438649faf42c968a4c8e5a704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6268f08438649faf42c968a4c8e5a704">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>unconvertedOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Below we define several entry points for operation conversion. </p>
<p>Apply a partial conversion on the given operations and all nested operations.</p>
<p>It is important to note that the patterns provided to the conversion framework may have additional constraints. See the <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="This class coordinates the application of a pattern to the current function, providing a way to creat...">PatternRewriter</a> Hooks</code> section of the <a class="el" href="classmlir_1_1ConversionPatternRewriter.html" title="This class implements a pattern rewriter for use with ConversionPatterns. ">ConversionPatternRewriter</a>, to see what additional constraints are imposed on the use of the <a class="el" href="classmlir_1_1PatternRewriter.html" title="This class coordinates the application of a pattern to the current function, providing a way to creat...">PatternRewriter</a>. Apply a partial conversion on the given operations and all nested operations. This method converts as many operations to the target as possible, ignoring operations that failed to legalize. This method only returns failure if there ops explicitly marked as illegal. If an <code>unconvertedOps</code> set is provided, all operations that are found not to be legalizable to the given <code>target</code> are placed within that set. (Note that if there is an op explicitly marked as illegal, the conversion terminates and the <code>unconvertedOps</code> set will not necessarily be complete.)</p>
<p>This method converts as many operations to the target as possible, ignoring operations that failed to legalize. This method only returns failure if there ops explicitly marked as illegal. If an <code>unconvertedOps</code> set is provided, all operations that are found not to be legalizable to the given <code>target</code> are placed within that set. (Note that if there is an op explicitly marked as illegal, the conversion terminates and the <code>unconvertedOps</code> set will not necessarily be complete.) </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02678">2678</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l02687">applyPartialConversion()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00153">finalizeBufferAllocation()</a>, <a class="el" href="DialectConversion_8h_source.html#l00726">mlir::ConversionTarget::isDynamicallyLegal()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00664">populateAffineToVectorConversionPatterns()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00069">populateElementwiseToLinalgConversionPatterns()</a>, <a class="el" href="SCFToStandard_8cpp_source.html#l00571">populateLoopToStdConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00044">populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="Dialect_2StandardOps_2Transforms_2Bufferize_8cpp_source.html#l00157">populateStdBufferizePatterns()</a>, <a class="el" href="Dialect_2Tensor_2Transforms_2Bufferize_8cpp_source.html#l00037">populateTensorBufferizePatterns()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00150">populateVectorToROCDLConversionPatterns()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04077">mlir::LLVMTypeConverter::promoteOperands()</a>.</p>

</div>
</div>
<a id="a911001f7e461558dfcd872ef275785bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911001f7e461558dfcd872ef275785bb">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>unconvertedOps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02687">2687</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>.</p>

</div>
</div>
<a id="a706b943c7bb07b96e86234204b79b3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706b943c7bb07b96e86234204b79b3d4">&#9670;&nbsp;</a></span>applyPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::applyPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00150">150</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Pass_2Pass_8cpp_source.html#l00831">mlir::PassManager::enableCrashReproducerGeneration()</a>, and <a class="el" href="PassStatistics_8cpp_source.html#l00244">mlir::PassManager::enableStatistics()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManager_8h_source.html#l00305">mlir::PassManager::PassTimingConfig::getDisplayMode()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00045">performActions()</a>.</p>

</div>
</div>
<a id="aadb845851e1a4ea685e2cfe48bb98a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb845851e1a4ea685e2cfe48bb98a4b">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the regions of the specified operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner. </p>
<p>This variant may stop after a predefined number of iterations, see the alternative below to provide a specific number of iterations before stopping in absence of convergence. Return success if the iterative process converged and no more patterns can be matched in the result operation regions. Note: This does not apply patterns to the top-level operation itself. These methods also perform folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>Return success if no more patterns can be matched in the result operation regions. Note: This does not apply patterns to the top-level operation itself. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">221</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00226">applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00316">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="Tiling_8cpp_source.html#l00590">applyTilingToLoopPatterns()</a>, <a class="el" href="Generalization_8cpp_source.html#l00033">createGenericOpFromNamedOp()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00935">mlir::linalg::fuseTensorOps()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">hoistAffineIfOp()</a>, <a class="el" href="Loops_8cpp_source.html#l00572">lowerLinalgToLoopsImpl()</a>, <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00108">populateConvertShapeConstraintsConversionPatterns()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00495">populateLinalgFoldUnitExtentDimsPatterns()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00182">populateStdLegalizationPatternsForSPIRVLowering()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00689">populateVectorToSCFConversionPatterns()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00110">reshapeLowerToHigher()</a>, and <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="ae63da384a40018f938b03ce066a5cd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63da384a40018f938b03ce066a5cd68">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxIterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the regions of the specified operation, with a user-provided limit on iterations to attempt before reaching convergence. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00226">226</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="Operation_8h_source.html#l00413">mlir::Operation::getRegions()</a>.</p>

</div>
</div>
<a id="a0bdc8625282e52ff0630d2c541452321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdc8625282e52ff0630d2c541452321">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the given regions, which must be isolated from above. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00234">234</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>.</p>

</div>
</div>
<a id="aff3f535f3e48c319294e4c467292cae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3f535f3e48c319294e4c467292cae5">&#9670;&nbsp;</a></span>applyPatternsAndFoldGreedily() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPatternsAndFoldGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternList.html">FrozenRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxIterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the given regions, with a user-provided limit on iterations to attempt before reaching convergence. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00240">240</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00487">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00032">isOpTriviallyDead()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="ac680df79552c596c048cd9cb27638c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680df79552c596c048cd9cb27638c5f">&#9670;&nbsp;</a></span>areValuesDefinedAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::areValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all values in the provided range are defined above the <code>limit</code> region. </p>
<p>That is, if they are defined in a region that is a proper ancestor of <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8h_source.html#l00023">23</a> of file <a class="el" href="RegionUtils_8h_source.html">RegionUtils.h</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00058">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00023">replaceAllUsesInRegionWith()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00696">simplifyRegions()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00031">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00088">checkAffineLoopNestMappableImpl()</a>.</p>

</div>
</div>
<a id="a173d145c5b783b4fe092fc78fd6879ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d145c5b783b4fe092fc78fd6879ec">&#9670;&nbsp;</a></span>barePtrFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::barePtrFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>It converts MemRef function arguments to bare pointers to the MemRef element type. </p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l00088">88</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardToLLVM_8cpp_source.html#l00423">mlir::LLVMTypeConverter::convertCallingConventionType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StandardToLLVM_8cpp_source.html#l00226">mlir::LLVMTypeConverter::convertFunctionSignature()</a>.</p>

</div>
</div>
<a id="a97905517c34a363dacccfe12bb2fcc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97905517c34a363dacccfe12bb2fcc14">&#9670;&nbsp;</a></span>bindDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to DimExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00291">291</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02212">createScopedSubViewIntersection()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00038">isColumnMajorMatmul()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00027">isRowMajorMatmul()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00209">mlir::edsc::ops::linalg_generic_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00246">mlir::edsc::ops::linalg_generic_dilated_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00175">mlir::edsc::ops::linalg_generic_matmul()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01685">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01798">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>, and <a class="el" href="Dialect_2Vector_2EDSC_2Builders_8cpp_source.html#l00032">mlir::edsc::ops::vector_contraction_matmul()</a>.</p>

</div>
</div>
<a id="afdb92b40e131a0a6bd17fc39f1f3e371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb92b40e131a0a6bd17fc39f1f3e371">&#9670;&nbsp;</a></span>boundCheckLoadOrStoreOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOpPointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::boundCheckLoadOrStoreOp </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOpPointer&#160;</td>
          <td class="paramname"><em>loadOrStoreOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise. </p>
<p>Emits a diagnostic error (with location information) if emitError is true. </p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00433">getMemRefSizeInBytes()</a>.</p>

</div>
</div>
<a id="a63560e053a2ecec5eae27d99fe6d72c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63560e053a2ecec5eae27d99fe6d72c7">&#9670;&nbsp;</a></span>buildAffineLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a perfect nest of affine "for" loops, i.e. </p>
<p>each loop except the innermost only contains another loop and a terminator. The loops iterate from "lbs" to "ubs" with "steps". The body of the innermost loop is populated by calling "bodyBuilderFn" and providing it with an <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a>, a <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> and a list of loop induction variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01987">1987</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01964">buildAffineLoopFromConstants()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01923">buildAffineLoopNestImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00017">mlir::edsc::affineLoopNestBuilder()</a>.</p>

</div>
</div>
<a id="ac0366913a08a55f407cca2775a169d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0366913a08a55f407cca2775a169d7e">&#9670;&nbsp;</a></span>buildAffineLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01995">1995</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01973">buildAffineLoopFromValues()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01923">buildAffineLoopNestImpl()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00181">mlir::PatternRewriter::eraseBlock()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00495">mlir::PatternRewriter::finalizeRootUpdate()</a>, <a class="el" href="PatternMatch_8h_source.html#l00490">mlir::PatternRewriter::startRootUpdate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a90d90e917cd6d91240a86ce6e3c9a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d90e917cd6d91240a86ce6e3c9a9c6">&#9670;&nbsp;</a></span>buildTripCountMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::buildTripCountMapAndOperands </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>tripCountMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>tripCountOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise. </p>
<p>Returns the trip count of the loop as an affine expression if the latter is expressible as an affine expression, and nullptr otherwise.</p>
<p>This method always succeeds as long as the lower bound is not a multi-result map. The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions</p>
<p>The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00033">33</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00113">getLargestDivisorOfTripCount()</a>.</p>

</div>
</div>
<a id="a701b6225d36b98c4157a1f80810d0c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701b6225d36b98c4157a1f80810d0c44">&#9670;&nbsp;</a></span>canFoldIntoConsumerOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::canFoldIntoConsumerOp </td>
          <td>(</td>
          <td class="paramtype">MemRefCastOp&#160;</td>
          <td class="paramname"><em>castOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether MemRefCastOp casts to a more dynamic version of the source memref. </p>
<p>This is useful to to fold a memref_cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of memref_cast operations. Such foldable memref_cast operations are typically inserted as <code>view</code> and <code>subview</code> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked memrefs with strided semantics and same element type and rank.</li>
<li>each of the source's size, offset or stride has more static information than the corresponding result's size, offset or stride.</li>
</ol>
<p>Example 1: </p><div class="fragment"><div class="line">%1 = memref_cast %0 : memref&lt;8x16xf32&gt; to memref&lt;?x?xf32&gt;</div><div class="line">%2 = consumer %1 ... : memref&lt;?x?xf32&gt; ...</div></div><!-- fragment --><p>may fold into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : memref&lt;8x16xf32&gt; ...</div></div><!-- fragment --><p>Example 2: </p><div class="fragment"><div class="line">%1 = memref_cast %0 : memref&lt;?x16xf32, affine_map&lt;(i, <a class="code" href="unionj.html">j</a>)-&gt;(16 * i + <a class="code" href="unionj.html">j</a>)&gt;&gt;</div><div class="line">       to memref&lt;?x?xf32&gt;</div><div class="line">consumer %1 : memref&lt;?x?xf32&gt; ...</div></div><!-- fragment --><p>may fold into:</p>
<div class="fragment"><div class="line">consumer %0 ... : memref&lt;?x16xf32, affine_map&lt;(i, <a class="code" href="unionj.html">j</a>)-&gt;(16 * i + <a class="code" href="unionj.html">j</a>)&gt;&gt;</div></div><!-- fragment --><p>This is useful to to fold a memref_cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of memref_cast operations. Such foldable memref_cast operations are typically inserted as <code>view</code> and <code>subview</code> ops are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked memrefs with strided semantics and same element type and rank.</li>
<li>each of the source's size, offset or stride has more static information than the corresponding result's size, offset or stride.</li>
</ol>
<p>Example 1: </p><div class="fragment"><div class="line">%1 = memref_cast %0 : memref&lt;8x16xf32&gt; to memref&lt;?x?xf32&gt;</div><div class="line">%2 = consumer %1 ... : memref&lt;?x?xf32&gt; ...</div></div><!-- fragment --><p>may fold into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : memref&lt;8x16xf32&gt; ...</div></div><!-- fragment --><p>Example 2: </p><div class="fragment"><div class="line">%1 = memref_cast %0 : memref&lt;?x16xf32, affine_map&lt;(i, <a class="code" href="unionj.html">j</a>)-&gt;(16 * i + <a class="code" href="unionj.html">j</a>)&gt;&gt;</div><div class="line">       to memref&lt;?x?xf32&gt;</div><div class="line">consumer %1 : memref&lt;?x?xf32&gt; ...</div></div><!-- fragment --><p>may fold into:</p>
<div class="fragment"><div class="line">consumer %0 ... : memref&lt;?x16xf32, affine_map&lt;(i, <a class="code" href="unionj.html">j</a>)-&gt;(16 * i + <a class="code" href="unionj.html">j</a>)&gt;&gt;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l03472">3472</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00512">mlir::MemRefType::getShape()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00671">getStridesAndOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l03544">canFoldIntoConsumerOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00133">foldMemRefCast()</a>, <a class="el" href="Ops_8h_source.html#l00297">mlir::DmaWaitOp::getNumElements()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l01639">verifyNamedStructuredOp()</a>.</p>

</div>
</div>
<a id="ac0879aa569e9a89496a46fe007ac6885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0879aa569e9a89496a46fe007ac6885">&#9670;&nbsp;</a></span>canFoldIntoConsumerOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::canFoldIntoConsumerOp </td>
          <td>(</td>
          <td class="paramtype">TensorCastOp&#160;</td>
          <td class="paramname"><em>castOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counterpart of <code><a class="el" href="namespacemlir.html#a701b6225d36b98c4157a1f80810d0c44" title="Determines whether MemRefCastOp casts to a more dynamic version of the source memref. ">canFoldIntoConsumerOp(MemRefCastOp castOp)</a></code> for tensors. </p>
<p>Determines whether TensorCastOp casts to a more dynamic version of the source tensor. This is useful to fold a tensor_cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor_cast operations. Such foldable tensor_cast operations are typically inserted as <code>subtensor</code> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor_cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div><div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div></div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l03544">3544</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="Ops_8cpp_source.html#l03472">canFoldIntoConsumerOp()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Ops_8cpp_source.html#l00254">extractFromI64ArrayAttr()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00397">mlir::RankedTensorType::getShape()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00311">mlir::ShapedType::isDynamic()</a>, <a class="el" href="Ops_8cpp_source.html#l00176">m_ConstantIndex()</a>, <a class="el" href="Matchers_8h_source.html#l00244">matchPattern()</a>, <a class="el" href="PatternMatch_8h_source.html#l00458">mlir::PatternRewriter::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a86843cd7c096abd53cde64b42a049140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86843cd7c096abd53cde64b42a049140">&#9670;&nbsp;</a></span>canFuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> mlir::canFuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>srcSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1FusionStrategy.html">FusionStrategy</a>&#160;</td>
          <td class="paramname"><em>fusionStrategy</em> = <code>{&#160;<a class="el" href="structmlir_1_1FusionStrategy.html#af67d30ce20aaace9e674be9cae1001bfa190cb66109576270749d23427806eb6a">FusionStrategy::Generic</a>,&#160;<a class="el" href="classmlir_1_1Value.html">Value</a>()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'. </p>
<p>Returns <a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> 'Success' if fusion of the src/dst loop nests is feasible (i.e. they are in the same block and dependences would not be violated). Otherwise returns a <a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> explaining why fusion is not feasible. NOTE: This function is not feature complete and should only be used in testing. TODO: Update comments when this function is fully implemented. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00263">263</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00035">mlir::FusionResult::FailBlockDependence</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00036">mlir::FusionResult::FailFusionDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00034">mlir::FusionResult::FailPrecondition</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00178">gatherLoadsAndStores()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00060">mlir::FusionStrategy::Generic</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00137">getFusedLoopNestInsertionPoint()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00194">getMaxLoopDepth()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00974">getNumCommonSurroundingLoops()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00075">mlir::FusionStrategy::memref</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00065">mlir::FusionStrategy::ProducerConsumer</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00071">mlir::FusionStrategy::Sibling</a>, <a class="el" href="structmlir_1_1FusionStrategy.html#a9725ef356451e500e33d325a4d520c1c">mlir::FusionStrategy::strategy</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00033">mlir::FusionResult::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8h_source.html#l00077">mlir::FusionStrategy::FusionStrategy()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="ad8bde50e2368b8864c8bc070a11fdd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bde50e2368b8864c8bc070a11fdd71">&#9670;&nbsp;</a></span>canonicalizeMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::canonicalizeMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies both <code>map</code> and <code>operands</code> in-place so as to: </p>
<ol type="1">
<li>drop duplicate operands</li>
<li>drop unused dims and symbols from map</li>
<li>promote valid symbols to symbolic operands in case they appeared as dimensional operands</li>
<li>propagate constant operands and drop them </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00980">980</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00044">applyMapToValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01629">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01721">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00828">composeAffineMapAndOperands()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02907">createCanonicalizedAffineForOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00035">createFoldedComposedAffineApply()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02219">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00757">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00466">mlir::linalg::AffineMinSCFCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00406">substitute()</a>.</p>

</div>
</div>
<a id="a02d761b15655cb81ff4b40dbf49445db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d761b15655cb81ff4b40dbf49445db">&#9670;&nbsp;</a></span>canonicalizeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::canonicalizeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00985">985</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00828">composeAffineMapAndOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="PatternMatch_8h_source.html#l00458">mlir::PatternRewriter::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02929">createSeparationCondition()</a>, <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02100">print()</a>.</p>

</div>
</div>
<a id="a80dcfbd64b4c5038926d874e46edeea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcfbd64b4c5038926d874e46edeea2">&#9670;&nbsp;</a></span>canonicalizeStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::canonicalizeStridedLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout. </p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout.</p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout. If <code>t</code> has multiple layout maps or a multi-result layout, just return <code>t</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00764">764</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00514">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00512">mlir::MemRefType::getShape()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00493">mlir::MemRefType::Builder::setAffineMaps()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01072">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00727">computeReshapeCollapsedType()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02732">verify()</a>.</p>

</div>
</div>
<a id="abb70330a9161c3ff1b6aa1f905e8f51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb70330a9161c3ff1b6aa1f905e8f51b">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00057">57</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::den</a>, and <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::num</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l01102">mlir::Simplex::computeIntegerBounds()</a>, and <a class="el" href="Ops_8cpp_source.html#l02741">signedCeilNonnegInputs()</a>.</p>

</div>
</div>
<a id="a46a3d17c70f67aa2d18203667acaf114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a3d17c70f67aa2d18203667acaf114">&#9670;&nbsp;</a></span>ceilDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::ceilDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's ceildiv operation on constants. </p>
<p>The RHS is expected to be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00023">23</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00033">buildTripCountMapAndOperands()</a>, <a class="el" href="Fraction_8h_source.html#l00057">ceil()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00821">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00058">computeStrides()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02118">mlir::FlatAffineConstraints::getConstantBoundOnDimSize()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01163">loopUnrollByFactor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00088">normalizeAffineFor()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>, <a class="el" href="SCF_8cpp_source.html#l00178">parseForOp()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00377">processParallelLoop()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00195">promoteIfSingleIteration()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00693">setInterTileBoundsParametric()</a>.</p>

</div>
</div>
<a id="af210ccb9e9409d8494b8998f50b6d274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af210ccb9e9409d8494b8998f50b6d274">&#9670;&nbsp;</a></span>checkMemrefAccessDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a> mlir::checkMemrefAccessDependence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>srcAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>dstAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *&#160;</td>
          <td class="paramname"><em>dependenceComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowRAR</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00859">859</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00372">addDomainConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00678">addOrderingConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00216">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00704">computeDirectionVector()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02634">mlir::Operation::dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02366">mlir::FlatAffineConstraints::dump()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00107">mlir::DependenceResult::Failure</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00757">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00581">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8h_source.html#l00434">mlir::FlatAffineConstraints::getNumDimIds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00119">getOpIndexSet()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00105">mlir::DependenceResult::HasDependence</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00302">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00965">mlir::FlatAffineConstraints::isEmpty()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00049">mlir::MemRefAccess::memref</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00106">mlir::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00050">mlir::MemRefAccess::opInst</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00654">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00437">checkTilingLegalityImpl()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00081">createMemRefDataFlowOptPass()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00109">mlir::DependenceResult::DependenceResult()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00952">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00194">getMaxLoopDepth()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l01053">isLoopParallel()</a>.</p>

</div>
</div>
<a id="a8502dc067cc5f52028a818a810146a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8502dc067cc5f52028a818a810146a59">&#9670;&nbsp;</a></span>cloneWithNewYields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scf::ForOp mlir::cloneWithNewYields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newIterOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newYieldedValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceLoopResults</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a clone of <code>loop</code> with <code>newIterOperands</code> added as new initialization values and <code>newYieldedValues</code> added as new yielded values. </p>
<p>The returned ForOp has <code>newYieldedValues.size()</code> new result values. The <code>loop</code> induction variable and <code>newIterOperands</code> are remapped to the new induction variable and the new entry block arguments respectively.</p>
<p>Additionally, if <code>replaceLoopResults</code> is true, all uses of <code>loop.getResults()</code> are replaced with the first <code>loop.getNumResults()</code> return values respectively. This additional replacement is provided as a convenience to update the consumers of <code>loop</code>, in the case e.g. when <code>loop</code> is soon to be deleted.</p>
<p>Return the cloned loop.</p>
<p>This convenience function is useful to factorize common mechanisms related to hoisting roundtrips to memory into yields. It does not perform any legality checks.</p>
<p>Prerequisite: <code>newYieldedValues.size() == newYieldedValues.size()</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00025">25</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8cpp_source.html#l00463">mlir::OpBuilder::clone()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="Operation_8h_source.html#l00155">mlir::Operation::replaceAllUsesWith()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00347">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00084">mlir::linalg::hoistRedundantVectorTransfers()</a>.</p>

</div>
</div>
<a id="a1f13b0be0ce31ecaf0272879eace768b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f13b0be0ce31ecaf0272879eace768b">&#9670;&nbsp;</a></span>coalesceLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops with bounds and steps independent of any loop induction variable involved in the nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01975">1975</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01907">normalizeLoop()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00023">replaceAllUsesInRegionWith()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00347">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a225e1cd29fad1b00f569d9567bc6cb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225e1cd29fad1b00f569d9567bc6cb2e">&#9670;&nbsp;</a></span>collapseParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::collapseParallelLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ParallelOp&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>combinedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the ParallelLoop and for each set of dimension indices, combine them into a single dimension. </p>
<p>combinedDimensions must contain each index into loops exactly once. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02030">2030</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00211">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01907">normalizeLoop()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00023">replaceAllUsesInRegionWith()</a>.</p>

</div>
</div>
<a id="a69efac5a24f7fb5371ad005350219f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69efac5a24f7fb5371ad005350219f7a">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison between two fractions. </p>
<p>Returns +1, 0, and -1 if the first fraction is greater than, equal to, or less than the second fraction, respectively. </p>

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00046">46</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::den</a>, and <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::num</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fraction_8h_source.html#l00061">operator&lt;()</a>, <a class="el" href="Fraction_8h_source.html#l00063">operator&lt;=()</a>, <a class="el" href="Fraction_8h_source.html#l00065">operator==()</a>, <a class="el" href="Fraction_8h_source.html#l00067">operator&gt;()</a>, and <a class="el" href="Fraction_8h_source.html#l00069">operator&gt;=()</a>.</p>

</div>
</div>
<a id="a138bbf83686d046fd85553cdd10eaf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138bbf83686d046fd85553cdd10eaf18">&#9670;&nbsp;</a></span>computeElementOffsetsFromVectorSliceOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::computeElementOffsetsFromVectorSliceOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the target sizes of a vector, together with vector-space offsets, returns the element-space offsets for each dimension. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00093">93</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00192">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00935">isValidExtractOrInsertSlicesType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>.</p>

</div>
</div>
<a id="a9c157bd2c9cf4949b45235593f6ef994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c157bd2c9cf4949b45235593f6ef994">&#9670;&nbsp;</a></span>computeMaxLinearIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::computeMaxLinearIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of elements of basis, <code>0</code> if empty. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00033">33</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8cpp_source.html#l00044">applyMapToValues()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00192">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00233">initUnrolledVectorState()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>.</p>

</div>
</div>
<a id="ae672104d54f3fa1333ad2295d16f8985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae672104d54f3fa1333ad2295d16f8985">&#9670;&nbsp;</a></span>computeRankReductionMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; bool, 4 &gt; &gt; mlir::computeRankReductionMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>originalShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>reducedShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an <code>originalShape</code> and a <code>reducedShape</code> assumed to be a subset of <code>originalShape</code> with some <code>1</code> entries erased, return the vector of booleans that specifies which of the entries of <code>originalShape</code> are keep to obtain <code>reducedShape</code>. </p>
<p>The returned mask can be applied as a projection to <code>originalShape</code> to obtain the <code>reducedShape</code>. This mask is useful to track which dimensions must be kept when e.g. compute MemRef strides under rank-reducing operations. Return None if reducedShape cannot be obtained by dropping only <code>1</code> entries in <code>originalShape</code>. </p>

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l03148">3148</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8h_source.html#l00297">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="Ops_8cpp_source.html#l03184">isRankReducedType()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>.</p>

</div>
</div>
<a id="a3db2dac35fa151fba5d1114497897f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db2dac35fa151fba5d1114497897f50">&#9670;&nbsp;</a></span>computeSliceSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::computeSliceSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>elementOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the shape, sizes, and element-space offsets of a vector, returns the slize sizes for each dimension. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00102">102</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00192">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00935">isValidExtractOrInsertSlicesType()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>.</p>

</div>
</div>
<a id="aa68a5a18c2ea856568b0fbfb272e2b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68a5a18c2ea856568b0fbfb272e2b0d">&#9670;&nbsp;</a></span>computeSliceUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::computeSliceUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>opsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>opsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numCommonLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceUnion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB'. </p>
<p>The parameter 'numCommonLoops' is the number of loops common to the operations in 'opsA' and 'opsB'. If 'isBackwardSlice' is true, computes slice bounds for loop nest surrounding ops in 'opsA', as a function of IVs and symbols of loop nest surrounding ops in 'opsB' at 'loopDepth'. If 'isBackwardSlice' is false, computes slice bounds for loop nest surrounding ops in 'opsB', as a function of IVs and symbols of loop nest surrounding ops in 'opsA' at 'loopDepth'. Returns 'success' if union was computed, 'failure' otherwise.</p>
<p>Returns 'Success' if union was computed, 'failure' otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">598</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00552">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00353">mlir::FlatAffineConstraints::areIdsAlignedWithOther()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00859">checkMemrefAccessDependence()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00101">mlir::ComputationSliceState::clearBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00621">mlir::FlatAffineConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00107">mlir::DependenceResult::Failure</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00757">getComputationSliceState()</a>, <a class="el" href="AffineStructures_8h_source.html#l00454">mlir::FlatAffineConstraints::getIdValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00461">mlir::FlatAffineConstraints::getIdValues()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00568">getInnermostCommonLoopDepth()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00944">getNestingDepth()</a>, <a class="el" href="AffineStructures_8h_source.html#l00436">mlir::FlatAffineConstraints::getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00434">mlir::FlatAffineConstraints::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00437">mlir::FlatAffineConstraints::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00074">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00070">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00049">mlir::MemRefAccess::memref</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00456">mlir::FlatAffineConstraints::mergeAndAlignIdsWithOther()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00106">mlir::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00050">mlir::MemRefAccess::opInst</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00072">mlir::ComputationSliceState::ubOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::ubs</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02789">mlir::FlatAffineConstraints::unionBoundingBox()</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00263">canFuseLoops()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00087">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a4ceb28e02820023acb8c3efd2a689e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceb28e02820023acb8c3efd2a689e0b">&#9670;&nbsp;</a></span>computeStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a shape with sizes greater than 0 along all dimensions, return the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension. </p>
<p>e.g. shape[3, 4, 5] -&gt; linearization_basis[20, 5, 1] </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00044">44</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8cpp_source.html#l00044">applyMapToValues()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00192">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00233">initUnrolledVectorState()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00935">isValidExtractOrInsertSlicesType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>.</p>

</div>
</div>
<a id="af1a5f445f0e1451c0dde7b93a2e1d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a5f445f0e1451c0dde7b93a2e1d7ab">&#9670;&nbsp;</a></span>computeStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::computeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the shape and sizes of a vector, returns the corresponding strides for each dimension. </p>
<p>TODO: needs better doc of how it is used. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00058">58</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>.</p>

</div>
</div>
<a id="a6d24d64d6db077b8d5c88316b0d6c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24d64d6db077b8d5c88316b0d6c717">&#9670;&nbsp;</a></span>concatAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::concatAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, stepping over potentially empty maps. </p>
<p>Assumes each of the underlying map has 0 symbols. The resulting map has a number of dims equal to the max of <code>maps</code>' dims and the concatenated results as its results. Returns an empty map if all input <code>maps</code> are empty.</p>
<p>Example: When applied to the following list of 3 affine maps,</p>
<div class="fragment"><div class="line">{</div><div class="line">  (i, j, k) -&gt; (i, k),</div><div class="line">  (i, j, k) -&gt; (k, j),</div><div class="line">  (i, j, k) -&gt; (i, j)</div><div class="line">}</div></div><!-- fragment --><p>Returns the map:</p>
<div class="fragment"><div class="line">(i, j, k) -&gt; (i, k, k, j, i, j)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00441">441</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00437">fuseWithReshapeByExpansion()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00237">mlir::MutableAffineMap::getContext()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00157">replaceBlockArgForUnitDimLoops&lt; IndexedGenericOp &gt;()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00247">replaceUnitExtents()</a>.</p>

</div>
</div>
<a id="a7fa896c9229c786edc4a7970b960b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa896c9229c786edc4a7970b960b208">&#9670;&nbsp;</a></span>configureGpuToNVVMConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToNVVMConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00144">144</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00702">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00621">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00579">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="a65c490624b02da7c5cb78aa071e0aa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c490624b02da7c5cb78aa071e0aa2a">&#9670;&nbsp;</a></span>configureGpuToROCDLConversionLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureGpuToROCDLConversionLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure target to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00080">80</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00702">mlir::ConversionTarget::addIllegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00621">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00579">mlir::ConversionTarget::addLegalOp()</a>.</p>

</div>
</div>
<a id="af01d59b73ef695a82338e96055101c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d59b73ef695a82338e96055101c16">&#9670;&nbsp;</a></span>configureParallelLoopToGPULegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::configureParallelLoopToGPULegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the rewrite target such that only <code>scf.parallel</code> operations that are not rewritten by the provided patterns are legal. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00649">649</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00589">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00031">mlir::gpu::getMappingAttrName()</a>.</p>

</div>
</div>
<a id="a5d3b3bbe9e749975af2eb5358df6f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">&#9670;&nbsp;</a></span>constFoldBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00030">30</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00777">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00807">mlir::DenseElementsAttr::getSplatValue()</a>, and <a class="el" href="classmlir_1_1ElementsAttr.html#adf4ac010890b03caf951f8e0c59364b6">mlir::ElementsAttr::getValues()</a>.</p>

</div>
</div>
<a id="addbe63747d3d90805543a5697ca8aca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbe63747d3d90805543a5697ca8aca9">&#9670;&nbsp;</a></span>convertAffineLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertAffineLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation. </p>
<p>Map <code>numBlockDims</code> outer loops to GPU blocks and <code>numThreadDims</code> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00279">279</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToGPU_8cpp_source.html#l00263">convertAffineLoopNestToGPULaunch()</a>.</p>

</div>
</div>
<a id="aebf452ef02d7d46f5c0f409ebb373b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf452ef02d7d46f5c0f409ebb373b92">&#9670;&nbsp;</a></span>createAffineComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::createAffineComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>opInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *&#160;</td>
          <td class="paramname"><em>sliceOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation. </p>
<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation operation.</p>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... v = "compute"(idx, ...)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) v = "compute"(idx_, ...) This allows the application of different transformations on send and compute (for eg. different shifts/delays)</p>
<p>Fills <code>sliceOps</code> with the list of affine.apply operations. In the following cases, <code>sliceOps</code> remains empty:</p><ol type="1">
<li>If none of opInst's operands were the result of an affine.apply (i.e., there was no affine computation slice to create).</li>
<li>If all the affine.apply op's supplying operands to this opInst did not have any uses other than those in this opInst.</li>
</ol>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) "compute"(idx)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) "compute"(idx_)</p>
<p>This allows applying different transformations on send and compute (for eg. different shifts/delays).</p>
<p>Returns nullptr either if none of opInst's operands were the result of an affine.apply and thus there was no affine computation slice to create, or if all the affine.apply op's supplying operands to this opInst did not have any uses besides this opInst; otherwise returns the list of affine.apply operations created in output argument <code>sliceOps</code>. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00328">328</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00839">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00320">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="Operation_8h_source.html#l00228">mlir::Operation::getNumOperands()</a>, <a class="el" href="Operation_8h_source.html#l00254">mlir::Operation::getOperands()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00038">getReachableAffineApplyOps()</a>, and <a class="el" href="Operation_8h_source.html#l00233">mlir::Operation::setOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00164">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="a71bd90d9233f88fee90fddb8a63e6a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bd90d9233f88fee90fddb8a63e6a14">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>slowMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>tagMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDmaTransferSize</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fastMemCapacityBytes</em> = <code>std::numeric_limits&lt;uint64_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations. </p>
<p>Generates copies for memref's living in 'slowMemorySpace' into newly created buffers in 'fastMemorySpace', and replaces memory operations to the former by the latter.</p>
<p>Only load op's handled for now. TODO: extend this to store op's. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00079">79</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

</div>
</div>
<a id="a7ce0e77d2011d2b90e06e51817718d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce0e77d2011d2b90e06e51817718d59">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00087">87</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02651">affineDataCopyGenerate()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00359">applyOpPatternsAndFold()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::begin()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Block_8h_source.html#l00133">mlir::Block::empty()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::end()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01033">getMemoryFootprintBytes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a5b9e1cdfc040345b0970e86449810d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9e1cdfc040345b0970e86449810d94">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that converts loop nests into GPU kernels. </p>
<p>It considers top-level affine.for operations as roots of loop nests and converts them to the gpu.launch operations if possible.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00066">66</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="a4007a1734d8ad9d47b3dce58973adb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4007a1734d8ad9d47b3dce58973adb40">&#9670;&nbsp;</a></span>createAffineForToGPUPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineForToGPUPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00069">69</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="ad6822d49e5cfc93f8de6b655124dd6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6822d49e5cfc93f8de6b655124dd6da">&#9670;&nbsp;</a></span>createAffineLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00233">233</a> of file <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html">AffineLoopInvariantCodeMotion.cpp</a>.</p>

</div>
</div>
<a id="af3bf3d0a1c7cbdb9df414f8f86e58531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bf3d0a1c7cbdb9df414f8f86e58531">&#9670;&nbsp;</a></span>createAffineLoopNormalizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineLoopNormalizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply normalization transformations to affine loop-like ops. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00202">202</a> of file <a class="el" href="AffineLoopNormalize_8cpp_source.html">AffineLoopNormalize.cpp</a>.</p>

</div>
</div>
<a id="a2b4e2c9a83970c5a5b838fe89beeb046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4e2c9a83970c5a5b838fe89beeb046">&#9670;&nbsp;</a></span>createAffineParallelizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAffineParallelizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops. </p>

<p class="definition">Definition at line <a class="el" href="AffineParallelize_8cpp_source.html#l00063">63</a> of file <a class="el" href="AffineParallelize_8cpp_source.html">AffineParallelize.cpp</a>.</p>

</div>
</div>
<a id="a99a424dd79d80784b6e20585650e2189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a424dd79d80784b6e20585650e2189">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00280">280</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a66616cf55b8e82b53029bf262b40924e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66616cf55b8e82b53029bf262b40924e">&#9670;&nbsp;</a></span>createAsyncParallelForPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAsyncParallelForPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numWorkerThreads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncParallelFor_8cpp_source.html#l00285">285</a> of file <a class="el" href="AsyncParallelFor_8cpp_source.html">AsyncParallelFor.cpp</a>.</p>

</div>
</div>
<a id="a577355fd96e48e20bee59e467d111a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577355fd96e48e20bee59e467d111a29">&#9670;&nbsp;</a></span>createAsyncRefCountingOptimizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAsyncRefCountingOptimizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRefCountingOptimization_8cpp_source.html#l00216">216</a> of file <a class="el" href="AsyncRefCountingOptimization_8cpp_source.html">AsyncRefCountingOptimization.cpp</a>.</p>

</div>
</div>
<a id="a72abf12aa165b47dcbe308e65b981bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72abf12aa165b47dcbe308e65b981bcf">&#9670;&nbsp;</a></span>createAsyncRefCountingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createAsyncRefCountingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncRefCounting_8cpp_source.html#l00322">322</a> of file <a class="el" href="AsyncRefCounting_8cpp_source.html">AsyncRefCounting.cpp</a>.</p>

</div>
</div>
<a id="a77905fe4592bbcf12db456795a71c4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77905fe4592bbcf12db456795a71c4e4">&#9670;&nbsp;</a></span>createBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the BufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00528">528</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="a73638eb9bd43c7c9d80ad84ca18feed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73638eb9bd43c7c9d80ad84ca18feed9">&#9670;&nbsp;</a></span>createBufferHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00383">383</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a44c7580bd3f0770bf2dce00a6f1f9b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c7580bd3f0770bf2dce00a6f1f9b33">&#9670;&nbsp;</a></span>createBufferLoopHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferLoopHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards out of loops. </p>
<p>This avoids reallocations inside of loops. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00387">387</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="ad511db48e4d4767cd251eb7e7400e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad511db48e4d4767cd251eb7e7400e896">&#9670;&nbsp;</a></span>createBufferResultsToOutParamsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createBufferResultsToOutParamsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts memref function results to out-params. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00141">141</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

</div>
</div>
<a id="a7cd7d19be1ff3cc542143dfd3f1c272a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd7d19be1ff3cc542143dfd3f1c272a">&#9670;&nbsp;</a></span>createCanonicalizedAffineForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::createCanonicalizedAffineForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>ubMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an AffineForOp while ensuring that the lower and upper bounds are canonicalized, i.e., unused and duplicate operands are removed, any constant operands propagated/folded in, and duplicate bound maps dropped. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02907">2907</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00980">canonicalizeMapAndOperands()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00839">fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00408">removeDuplicateExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03011">createFullTiles()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02219">generatePointWiseCopy()</a>.</p>

</div>
</div>
<a id="aab0069355214b578476e81bc909f7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0069355214b578476e81bc909f7f13">&#9670;&nbsp;</a></span>createCanonicalizerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass. </p>
<p>Create a Canonicalizer pass. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00041">41</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00031">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a4e839c359226fcf9fc26cb51ba6c3282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e839c359226fcf9fc26cb51ba6c3282">&#9670;&nbsp;</a></span>createComposedAffineApplyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::createComposedAffineApplyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and inserts into 'builder' a new AffineApplyOp, with the number of its results equal to the number of operands, as a composition of all other AffineApplyOps reachable from input parameter 'operands'. </p>
<p>If different operands were drawing results from multiple affine apply ops, these will also be collected into a single (multi-result) affine apply op. The final results of the composed AffineApplyOp are returned in output parameter 'results'. Returns the affine apply op created. </p>

</div>
</div>
<a id="a4fa49d15d05958ebff1ab8aac3e55cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa49d15d05958ebff1ab8aac3e55cfc">&#9670;&nbsp;</a></span>createConvertAsyncToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertAsyncToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Async operations to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AsyncToLLVM_8cpp_source.html#l00883">883</a> of file <a class="el" href="AsyncToLLVM_8cpp_source.html">AsyncToLLVM.cpp</a>.</p>

</div>
</div>
<a id="af54c51849e4c06810c12ec1e96b6f259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54c51849e4c06810c12ec1e96b6f259">&#9670;&nbsp;</a></span>createConvertElementwiseToLinalgPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createConvertElementwiseToLinalgPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00096">96</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

</div>
</div>
<a id="a68415bea06e1d49a93ff20fd3c015fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68415bea06e1d49a93ff20fd3c015fdf">&#9670;&nbsp;</a></span>createConvertGPUKernelToBlobPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createConvertGPUKernelToBlobPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a594a45ae9aa1ccffd960f369da94d156">LoweringCallback</a>&#160;</td>
          <td class="paramname"><em>loweringCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#af5aaca5fea0016501841c1e98a14e7ab">BlobGenerator</a>&#160;</td>
          <td class="paramname"><em>blobGenerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>triple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>targetChip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>gpuBinaryAnnotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert kernel functions into GPU target object blobs. </p>
<p>This transformation takes the body of each function that is annotated with the 'gpu.kernel' attribute, copies it to a new <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module, compiles the module with help of the GPU backend to target object and then invokes the provided blobGenerator to produce a binary blob. Such blob is then attached as a string attribute to the kernel function.</p>
<p>Following callbacks are to be provided by user:</p><ul>
<li>loweringCallback : lower the module to an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module.</li>
<li>blobGenerator : build a blob executable on target GPU.</li>
</ul>
<p>Information wrt <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> backend are to be supplied by user:</p><ul>
<li>triple : target triple to be used.</li>
<li>targetChip : mcpu to be used.</li>
<li>features : target-specific features to be used.</li>
</ul>
<p>Information about result attribute is to be specified by user:</p><ul>
<li>gpuBinaryAnnotation : the name of the attribute which contains the blob.</li>
</ul>
<p>After the transformation, the body of the kernel function is removed (i.e., it is turned into a declaration). </p>

<p class="definition">Definition at line <a class="el" href="ConvertKernelFuncToBlob_8cpp_source.html#l00155">155</a> of file <a class="el" href="ConvertKernelFuncToBlob_8cpp_source.html">ConvertKernelFuncToBlob.cpp</a>.</p>

</div>
</div>
<a id="ad39c9d3321b2f5f4aee088b02b535f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c9d3321b2f5f4aee088b02b535f9b">&#9670;&nbsp;</a></span>createConvertGpuLaunchFuncToVulkanLaunchFuncPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createConvertGpuLaunchFuncToVulkanLaunchFuncPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html#l00191">191</a> of file <a class="el" href="ConvertGPULaunchFuncToVulkanLaunchFunc_8cpp_source.html">ConvertGPULaunchFuncToVulkanLaunchFunc.cpp</a>.</p>

</div>
</div>
<a id="a98081470e80af33268acc9e7463f4af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98081470e80af33268acc9e7463f4af1">&#9670;&nbsp;</a></span>createConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="ConvertGPUToSPIRVPass_8cpp_source.html#l00071">71</a> of file <a class="el" href="ConvertGPUToSPIRVPass_8cpp_source.html">ConvertGPUToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a99c92dd67a98755cd2ef9b4590197aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c92dd67a98755cd2ef9b4590197aba">&#9670;&nbsp;</a></span>createConvertLinalgToAffineLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createConvertLinalgToAffineLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses. </p>
<p>Placeholder for now, this is NYI. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00651">651</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="a5d81cd941f78768bc9dd0cbaca49d45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d81cd941f78768bc9dd0cbaca49d45a">&#9670;&nbsp;</a></span>createConvertLinalgToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertLinalgToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00331">331</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

</div>
</div>
<a id="adc31af884ed2445efac7962abbbebdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc31af884ed2445efac7962abbbebdd7">&#9670;&nbsp;</a></span>createConvertLinalgToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createConvertLinalgToLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to scf.for loops and std.load/std.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00641">641</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="af0f0386f22f7191ef34da794fbb52331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f0386f22f7191ef34da794fbb52331">&#9670;&nbsp;</a></span>createConvertLinalgToParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createConvertLinalgToParallelLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to scf.parallel loops and std.load/std.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00646">646</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aefb33f39a4ad0d4d52396f132bee84cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb33f39a4ad0d4d52396f132bee84cf">&#9670;&nbsp;</a></span>createConvertLinalgToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertLinalgToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the Standard dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00220">220</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

</div>
</div>
<a id="ae53acb3c78e9695b7e30e1e9efec285a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53acb3c78e9695b7e30e1e9efec285a">&#9670;&nbsp;</a></span>createConvertOpenMPToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertOpenMPToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert OpenMP operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00075">75</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

</div>
</div>
<a id="addfd4071e05737fd95c2e25e89bc4a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4071e05737fd95c2e25e89bc4a96">&#9670;&nbsp;</a></span>createConvertSCFToOpenMPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createConvertSCFToOpenMPPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCFToOpenMP_8cpp_source.html#l00111">111</a> of file <a class="el" href="SCFToOpenMP_8cpp_source.html">SCFToOpenMP.cpp</a>.</p>

</div>
</div>
<a id="a476fec80d5042ee5602a8b7b97d8a023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476fec80d5042ee5602a8b7b97d8a023">&#9670;&nbsp;</a></span>createConvertShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createConvertShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00135">135</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="abc9ecc9afba558cb026032d0453a7c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ecc9afba558cb026032d0453a7c95">&#9670;&nbsp;</a></span>createConvertShapeToStandardPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertShapeToStandardPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00625">625</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

</div>
</div>
<a id="a41cd8a621caca1db19e02a6933d28fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cd8a621caca1db19e02a6933d28fb3">&#9670;&nbsp;</a></span>createConvertSPIRVToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertSPIRVToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert SPIR-V operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertSPIRVToLLVMPass_8cpp_source.html#l00059">59</a> of file <a class="el" href="ConvertSPIRVToLLVMPass_8cpp_source.html">ConvertSPIRVToLLVMPass.cpp</a>.</p>

</div>
</div>
<a id="a374133dc1b7dbc57586ad4cd57308ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374133dc1b7dbc57586ad4cd57308ebb">&#9670;&nbsp;</a></span>createConvertStandardToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertStandardToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert StandardOps to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToSPIRVPass_8cpp_source.html#l00048">48</a> of file <a class="el" href="ConvertStandardToSPIRVPass_8cpp_source.html">ConvertStandardToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="afa5d0c2f42ef94e822f398d917b39184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5d0c2f42ef94e822f398d917b39184">&#9670;&nbsp;</a></span>createConvertVectorToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertVectorToLLVMPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1LowerVectorToLLVMOptions.html">LowerVectorToLLVMOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert vector operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html#l00099">99</a> of file <a class="el" href="ConvertVectorToLLVMPass_8cpp_source.html">ConvertVectorToLLVMPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>.</p>

</div>
</div>
<a id="a4c2e8d8175dd430cb8048a29596d6ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2e8d8175dd430cb8048a29596d6ce3">&#9670;&nbsp;</a></span>createConvertVectorToROCDLPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertVectorToROCDLPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert vector operations to the <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorToROCDL_8cpp_source.html#l00179">179</a> of file <a class="el" href="VectorToROCDL_8cpp_source.html">VectorToROCDL.cpp</a>.</p>

</div>
</div>
<a id="ac5c71e471d7d8cdda288a27d1ae75642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c71e471d7d8cdda288a27d1ae75642">&#9670;&nbsp;</a></span>createConvertVectorToSCFPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createConvertVectorToSCFPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert a subset of vector ops to SCF. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l00720">720</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToSCF_8h_source.html#l00160">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::options</a>.</p>

</div>
</div>
<a id="a30e215016b82bc3a02bddb450f68fdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e215016b82bc3a02bddb450f68fdaf">&#9670;&nbsp;</a></span>createConvertVectorToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertVectorToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00155">155</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

</div>
</div>
<a id="aa85822fd77ee16dc5df2c93c9f56b4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85822fd77ee16dc5df2c93c9f56b4bf">&#9670;&nbsp;</a></span>createConvertVulkanLaunchFuncToVulkanCallsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createConvertVulkanLaunchFuncToVulkanCallsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToVulkanCalls_8cpp_source.html#l00434">434</a> of file <a class="el" href="ConvertLaunchFuncToVulkanCalls_8cpp_source.html">ConvertLaunchFuncToVulkanCalls.cpp</a>.</p>

</div>
</div>
<a id="a7e1c13054dd9f29cef7fd20d09f684c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1c13054dd9f29cef7fd20d09f684c8">&#9670;&nbsp;</a></span>createCopyRemovalPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCopyRemovalPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that removes unnecessary Copy operations. </p>

<p class="definition">Definition at line <a class="el" href="CopyRemoval_8cpp_source.html#l00215">215</a> of file <a class="el" href="CopyRemoval_8cpp_source.html">CopyRemoval.cpp</a>.</p>

</div>
</div>
<a id="a14895da9723acd9c7f910c2694ff9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14895da9723acd9c7f910c2694ff9f65">&#9670;&nbsp;</a></span>createCSEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCSEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform common sub expression elimination. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00236">236</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

</div>
</div>
<a id="a24fd271d3415a3e2578af827b936c957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fd271d3415a3e2578af827b936c957">&#9670;&nbsp;</a></span>createFinalizingBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a> &gt; mlir::createFinalizingBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finalizes a partial bufferization by removing remaining tensor_load and tensor_to_memref operations. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Bufferize_8cpp_source.html#l00126">126</a> of file <a class="el" href="Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="af04e9e0b0d3deab87baf02639705782e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04e9e0b0d3deab87baf02639705782e">&#9670;&nbsp;</a></span>createFoldReshapeOpsByLinearizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createFoldReshapeOpsByLinearizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l01034">1034</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

</div>
</div>
<a id="a1d49e4ae28aeaaa552466850cc5e04ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d49e4ae28aeaaa552466850cc5e04ec">&#9670;&nbsp;</a></span>createForLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createForLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes for loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00113">113</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a2a7e5f540e0e85d59b26385c04930822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7e5f540e0e85d59b26385c04930822">&#9670;&nbsp;</a></span>createFuncBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createFuncBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of func bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="FuncBufferize_8cpp_source.html#l00084">84</a> of file <a class="el" href="FuncBufferize_8cpp_source.html">FuncBufferize.cpp</a>.</p>

</div>
</div>
<a id="ad1d51e9993163b996f97d9c444de9bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d51e9993163b996f97d9c444de9bff">&#9670;&nbsp;</a></span>createGpuAsyncRegionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createGpuAsyncRegionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites a function region so that GPU ops execute asynchronously. </p>

<p class="definition">Definition at line <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00273">273</a> of file <a class="el" href="AsyncRegionRewriter_8cpp_source.html">AsyncRegionRewriter.cpp</a>.</p>

</div>
</div>
<a id="a84b9dda21074b16b5b4c9b72449883a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b9dda21074b16b5b4c9b72449883a3">&#9670;&nbsp;</a></span>createGpuKernelOutliningPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces <code>gpu.launch</code> with <code>gpu.launch_func</code> by moving the region into a separate kernel function. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00317">317</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

</div>
</div>
<a id="af8557dc4a578cb4d61bd87ab914e6c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8557dc4a578cb4d61bd87ab914e6c3f">&#9670;&nbsp;</a></span>createGpuToLLVMConversionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createGpuToLLVMConversionPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>gpuBinaryAnnotation</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert a gpu.launch_func operation into a sequence of GPU runtime calls. </p>
<p>This pass does not generate code to call GPU runtime APIs directly but instead uses a small wrapper library that exports a stable and conveniently typed ABI on top of GPU runtimes such as CUDA or ROCm (HIP). </p>

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00647">647</a> of file <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html">ConvertLaunchFuncToRuntimeCalls.cpp</a>.</p>

</div>
</div>
<a id="a6c6ad0644a283c257d1fbc15be6adc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ad0644a283c257d1fbc15be6adc18">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00782">782</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

</div>
</div>
<a id="a1372ce1294d9b98b652930aa6baf1386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1372ce1294d9b98b652930aa6baf1386">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the default inliner pipeline during optimization. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00786">786</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Inliner_8cpp_source.html#l00031">defaultInlinerOptPipeline()</a>.</p>

</div>
</div>
<a id="a17c5dd15c86ea433c8b83b1133a9a322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c5dd15c86ea433c8b83b1133a9a322">&#9670;&nbsp;</a></span>createInlinerPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringMap&lt; <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &gt;&#160;</td>
          <td class="paramname"><em>opPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>defaultPipelineBuilder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the inliner pass, and use the provided pass managers when optimizing callable operations with names matching the key type. </p>
<p>Callable operations with a name not within the provided map will use the provided default pipeline builder. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00791">791</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

</div>
</div>
<a id="a8665adb3fa2ac64504cfff30192ecb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8665adb3fa2ac64504cfff30192ecb5e">&#9670;&nbsp;</a></span>createLegalizeStdOpsForSPIRVLoweringPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLegalizeStdOpsForSPIRVLoweringPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to legalize ops that are not directly lowered to SPIR-V. </p>

<p class="definition">Definition at line <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00209">209</a> of file <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html">LegalizeStandardForSPIRV.cpp</a>.</p>

</div>
</div>
<a id="a207e1131b41e4217e146a70bd150d803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207e1131b41e4217e146a70bd150d803">&#9670;&nbsp;</a></span>createLinalgBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations which work on tensors to use buffers instead. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00348">348</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="ae5e44d45d1d785d7118a3eff2c95baab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e44d45d1d785d7118a3eff2c95baab">&#9670;&nbsp;</a></span>createLinalgFoldUnitExtentDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgFoldUnitExtentDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00524">524</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

</div>
</div>
<a id="a064ade44b33729c9389df10558e6e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064ade44b33729c9389df10558e6e3e9">&#9670;&nbsp;</a></span>createLinalgFusionOfTensorOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLinalgFusionOfTensorOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l01030">1030</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

</div>
</div>
<a id="a913354f530de23d05fb673dc3f173925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913354f530de23d05fb673dc3f173925">&#9670;&nbsp;</a></span>createLinalgGeneralizationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgGeneralizationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to conver named Linalg operations to Linalg generic operations. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00178">178</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

</div>
</div>
<a id="ae90f2f907477a4e94ccd0f3dd4cdad97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90f2f907477a4e94ccd0f3dd4cdad97">&#9670;&nbsp;</a></span>createLinalgPromotionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgPromotionPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamicBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00422">422</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="a94d8740521bec1c043bfa8f2e36c3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d8740521bec1c043bfa8f2e36c3f6d">&#9670;&nbsp;</a></span>createLinalgPromotionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgPromotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00425">425</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="a0a5ca0de1aea770790d0177e20d4046b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5ca0de1aea770790d0177e20d4046b">&#9670;&nbsp;</a></span>createLinalgTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00634">634</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="a7b643d974d1e381b31c4468ed3cc44ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b643d974d1e381b31c4468ed3cc44ab">&#9670;&nbsp;</a></span>createLinalgTilingToParallelLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLinalgTilingToParallelLoopsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00639">639</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

</div>
</div>
<a id="a7621ad17eef3b7af217a900ae413cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7621ad17eef3b7af217a900ae413cfa5">&#9670;&nbsp;</a></span>createLinalgToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createLinalgToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert Linalg ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToSPIRVPass_8cpp_source.html#l00048">48</a> of file <a class="el" href="LinalgToSPIRVPass_8cpp_source.html">LinalgToSPIRVPass.cpp</a>.</p>

</div>
</div>
<a id="a415fbf6253902c584461fa6a43a59ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415fbf6253902c584461fa6a43a59ad5">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to generate new locations by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. If a 'tag' is non-empty, the generated locations are represented as a <a class="el" href="classmlir_1_1NameLoc.html" title="Represents an identity name attached to a child location. ">NameLoc</a> with the given tag as the name, and then fused with the existing locations. Otherwise, the existing locations are replaced. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00146">146</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="abb0bdadbeb0d7f5b8cef57668447640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0bdadbeb0d7f5b8cef57668447640b">&#9670;&nbsp;</a></span>createLocationSnapshotPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLocationSnapshotPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload utilizing pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00151">151</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

</div>
</div>
<a id="aebeb1f710273219157ff4b10d6577b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebeb1f710273219157ff4b10d6577b8d">&#9670;&nbsp;</a></span>createLoopCoalescingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLoopCoalescingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms perfectly nested loops with independent bounds into a single loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopCoalescing_8cpp_source.html#l00088">88</a> of file <a class="el" href="LoopCoalescing_8cpp_source.html">LoopCoalescing.cpp</a>.</p>

</div>
</div>
<a id="aa6d8be1adb94ed50220c9c44d0caa362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d8be1adb94ed50220c9c44d0caa362">&#9670;&nbsp;</a></span>createLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLoopFusionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>localBufSizeThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maximalFusion</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses loops. </p>
<p>Buffers of size less than or equal to <code>localBufSizeThreshold</code> are promoted to memory space `fastMemorySpace'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00065">65</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a319fde65e573dbc3a947d58196cb2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319fde65e573dbc3a947d58196cb2b3a">&#9670;&nbsp;</a></span>createLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00123">123</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a6ea1632e318442ba6dcd15c498791cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea1632e318442ba6dcd15c498791cd3">&#9670;&nbsp;</a></span>createLoopTilingPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cacheSizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform tiling on loop nests. </p>
<p>Creates a pass to perform loop tiling on all suitable loop nests of a Function.</p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00057">57</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="aaa3ffa270502198f1d63f696a16abe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3ffa270502198f1d63f696a16abe59">&#9670;&nbsp;</a></span>createLoopTilingPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00060">60</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a54bed21f88cd230f8184ec74c8bd19e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bed21f88cd230f8184ec74c8bd19e4">&#9670;&nbsp;</a></span>createLoopUnrollAndJamPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLoopUnrollAndJamPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unroll jam pass to unroll jam by the specified factor. </p>
<p>A factor of -1 lets the pass use the default factor or the one on the command line if provided. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00066">66</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="aa9e1b2ed676bd820564178e64886bbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e1b2ed676bd820564178e64886bbfd">&#9670;&nbsp;</a></span>createLoopUnrollPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createLoopUnrollPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollFactor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollUpToFactor</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollFull</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classunsigned.html">unsigned</a>(AffineForOp)&gt; &amp;&#160;</td>
          <td class="paramname"><em>getUnrollFactor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unrolling pass with the provided parameters. </p>
<p>'getUnrollFactor' is a function callback for clients to supply a function that computes an unroll factor - the callback takes precedence over unroll factors supplied through other means. If -1 is passed as the unrollFactor and no callback is provided, anything passed from the command-line (if at all) or the default unroll factor is used (LoopUnroll:kDefaultUnrollFactor). </p>

<p class="definition">Definition at line <a class="el" href="LoopUnroll_8cpp_source.html#l00135">135</a> of file <a class="el" href="LoopUnroll_8cpp_source.html">LoopUnroll.cpp</a>.</p>

</div>
</div>
<a id="ae09ce34232ab009ce688d7cdc63695a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09ce34232ab009ce688d7cdc63695a8">&#9670;&nbsp;</a></span>createLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers affine control flow operations (ForStmt, IfStmt and AffineApplyOp) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives). </p>
<p>Lowers If and For operations within a function into their lower level CFG equivalent blocks.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00691">691</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

</div>
</div>
<a id="ad62610c48d7b8e08dfd726bdb51d433e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62610c48d7b8e08dfd726bdb51d433e">&#9670;&nbsp;</a></span>createLowerGpuOpsToNVVMOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToNVVMOpsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00207">207</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

</div>
</div>
<a id="a31c22a8ed14d48069b4c811e1f61727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c22a8ed14d48069b4c811e1f61727e">&#9670;&nbsp;</a></span>createLowerGpuOpsToROCDLOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToROCDLOpsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>indexBitwidth</em> = <code><a class="el" href="namespacemlir.html#a2887883f00b094c5ca61c631d7b093a0">kDeriveIndexBitwidthFromDataLayout</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts. </p>
<p>The index bitwidth used for the lowering of the device side index computations is configurable. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00139">139</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

</div>
</div>
<a id="a712e219558e911fe489fefff81dd8365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712e219558e911fe489fefff81dd8365">&#9670;&nbsp;</a></span>createLowerHostCodeToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; mlir::createLowerHostCodeToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to emulate <code>gpu.launch_func</code> call in <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect and lower the host module code to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>This transformation creates a sequence of global variables that are later linked to the varables in the kernel module, and a series of copies to/from them to emulate the memory transfer from the host or to the device sides. It also converts the remaining Standard dialect into <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, emitting C wrappers. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00305">305</a> of file <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html">ConvertLaunchFuncToLLVMCalls.cpp</a>.</p>

</div>
</div>
<a id="aa7bcd86978ddc5c8c9eb55e995fa7d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bcd86978ddc5c8c9eb55e995fa7d69">&#9670;&nbsp;</a></span>createLowerToCFGPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerToCFGPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert scf.for, scf.if and loop.terminator ops to CFG. </p>

<p class="definition">Definition at line <a class="el" href="SCFToStandard_8cpp_source.html#l00591">591</a> of file <a class="el" href="SCFToStandard_8cpp_source.html">SCFToStandard.cpp</a>.</p>

</div>
</div>
<a id="a649d6d11fb7af43b251d8664ed0202a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649d6d11fb7af43b251d8664ed0202a8">&#9670;&nbsp;</a></span>createLowerToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createLowerToLLVMPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1LowerToLLVMOptions.html#ac14fc13dfbd07ab39707b8400195db85">LowerToLLVMOptions::getDefaultOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert the Standard dialect into the LLVMIR dialect. </p>
<p>stdlib malloc/free is used by default for allocating memrefs allocated with std.alloc, while <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>'s alloca is used for those allocated with std.alloca. </p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l04173">4173</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00039">mlir::LowerToLLVMOptions::dataLayout</a>, <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00031">mlir::LowerToLLVMOptions::emitCWrappers</a>, <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00032">mlir::LowerToLLVMOptions::indexBitwidth</a>, <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00034">mlir::LowerToLLVMOptions::useAlignedAlloc</a>, and <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00030">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00042">mlir::LowerToLLVMOptions::getDefaultOptions()</a>.</p>

</div>
</div>
<a id="a37cac3d49263cfecc05b77c0fd4c2074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cac3d49263cfecc05b77c0fd4c2074">&#9670;&nbsp;</a></span>createMemRefDataFlowOptPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createMemRefDataFlowOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform optimizations relying on memref dataflow such as store to load forwarding, elimination of dead stores, and dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00081">81</a> of file <a class="el" href="MemRefDataFlowOpt_8cpp_source.html">MemRefDataFlowOpt.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00859">checkMemrefAccessDependence()</a>, <a class="el" href="Operation_8cpp_source.html#l00487">mlir::Operation::erase()</a>, <a class="el" href="OpDefinition_8h_source.html#l00208">mlir::OpState::erase()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#a8244a4feee85f6bd09a2c68ea316572d">mlir::AffineReadOpInterface::getMemRef()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00944">getNestingDepth()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00974">getNumCommonSurroundingLoops()</a>, <a class="el" href="Value_8h_source.html#l00199">mlir::Value::getUsers()</a>, <a class="el" href="classmlir_1_1AffineReadOpInterface.html#ab0b307ac79e93d7e8f37814e59c8ef23">mlir::AffineReadOpInterface::getValue()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00120">hasDependence()</a>, and <a class="el" href="Value_8cpp_source.html#l00124">mlir::Value::replaceAllUsesWith()</a>.</p>

</div>
</div>
<a id="a8f703ae55d1f56e11c4e263c7bdb6a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f703ae55d1f56e11c4e263c7bdb6a36">&#9670;&nbsp;</a></span>createNormalizeMemRefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createNormalizeMemRefsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an interprocedural pass to normalize memrefs to have a trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00044">44</a> of file <a class="el" href="NormalizeMemRefs_8cpp_source.html">NormalizeMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a525d8e77b6503a81d7aa03b636c98e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525d8e77b6503a81d7aa03b636c98e2e">&#9670;&nbsp;</a></span>createParallelLoopCollapsingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopCollapsingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms a single ParallelLoop over N induction variables into another ParallelLoop over less than N induction variables. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopCollapsing_8cpp_source.html#l00043">43</a> of file <a class="el" href="ParallelLoopCollapsing_8cpp_source.html">ParallelLoopCollapsing.cpp</a>.</p>

</div>
</div>
<a id="ad00701d01638289dd08ec9e255076f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00701d01638289dd08ec9e255076f50">&#9670;&nbsp;</a></span>createParallelLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00173">173</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a16b9f8678ec66eed9c66536834540184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9f8678ec66eed9c66536834540184">&#9670;&nbsp;</a></span>createParallelLoopSpecializationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopSpecializationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that specializes parallel loop for unrolling and vectorization. </p>

<p class="definition">Definition at line <a class="el" href="LoopSpecialization_8cpp_source.html#l00109">109</a> of file <a class="el" href="LoopSpecialization_8cpp_source.html">LoopSpecialization.cpp</a>.</p>

</div>
</div>
<a id="a376762082da3778ea351a8c9e1db5f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376762082da3778ea351a8c9e1db5f23">&#9670;&nbsp;</a></span>createParallelLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSize</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which tiles innermost parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00173">173</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

</div>
</div>
<a id="aa2f36107d7ffc6c1f873c746385d9de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f36107d7ffc6c1f873c746385d9de0">&#9670;&nbsp;</a></span>createParallelLoopToGpuPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createParallelLoopToGpuPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts scf.parallel operations into a gpu.launch operation. </p>
<p>The mapping of loop dimensions to launch dimensions is derived from mapping attributes. See ParallelToGpuLaunchLowering::matchAndRewrite for a description of the used attributes. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPUPass_8cpp_source.html#l00073">73</a> of file <a class="el" href="SCFToGPUPass_8cpp_source.html">SCFToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="af882e712b4e426905d73c1c74bd0f353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af882e712b4e426905d73c1c74bd0f353">&#9670;&nbsp;</a></span>createPDLToPDLInterpPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createPDLToPDLInterpPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a pass to convert PDL ops to PDL interpreter ops. </p>

<p class="definition">Definition at line <a class="el" href="PDLToPDLInterp_8cpp_source.html#l00692">692</a> of file <a class="el" href="PDLToPDLInterp_8cpp_source.html">PDLToPDLInterp.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrozenRewritePatternList_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>.</p>

</div>
</div>
<a id="a7fb9cf05fcdd6618fe542c7126cd30ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb9cf05fcdd6618fe542c7126cd30ec">&#9670;&nbsp;</a></span>createPipelineDataTransferPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createPipelineDataTransferPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00043">43</a> of file <a class="el" href="PipelineDataTransfer_8cpp_source.html">PipelineDataTransfer.cpp</a>.</p>

</div>
</div>
<a id="ab6dc570ec82de616d9530aee07d2cfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dc570ec82de616d9530aee07d2cfed">&#9670;&nbsp;</a></span>createPrintCFGGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::FuncOp &gt; &gt; mlir::createPrintCFGGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print CFG graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewRegionGraph_8cpp_source.html#l00079">79</a> of file <a class="el" href="ViewRegionGraph_8cpp_source.html">ViewRegionGraph.cpp</a>.</p>

</div>
</div>
<a id="ae42ac202207527a00d55b96e72d27216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42ac202207527a00d55b96e72d27216">&#9670;&nbsp;</a></span>createPrintOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createPrintOpGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print op graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00164">164</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

</div>
</div>
<a id="a2d86bdab25e38eed8e3ab9a35012b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d86bdab25e38eed8e3ab9a35012b1e8">&#9670;&nbsp;</a></span>createPrintOpStatsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPrintOpStatsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which prints the list of ops and the number of occurrences in the module. </p>

<p class="definition">Definition at line <a class="el" href="OpStats_8cpp_source.html#l00083">83</a> of file <a class="el" href="OpStats_8cpp_source.html">OpStats.cpp</a>.</p>

</div>
</div>
<a id="a5f3ceb6839e2fb42db15365105290b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3ceb6839e2fb42db15365105290b24">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxAllocSizeInBytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>bitwidthOfIndexType</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxRankOfAllocatedMemRef</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller than the provided size are promoted. Dynamic shaped buffers are promoted up to the given rank. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00392">392</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="adfe31940e952ad0bd9566f70265c59a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe31940e952ad0bd9566f70265c59a9">&#9670;&nbsp;</a></span>createRemoveShapeConstraintsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a> &gt; mlir::createRemoveShapeConstraintsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00063">63</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

</div>
</div>
<a id="a6119493f8c83de427f34658e5e39cbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119493f8c83de427f34658e5e39cbfe">&#9670;&nbsp;</a></span>createSCCPPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCCPPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which performs sparse conditional constant propagation over nested operations. </p>

<p class="definition">Definition at line <a class="el" href="SCCP_8cpp_source.html#l00929">929</a> of file <a class="el" href="SCCP_8cpp_source.html">SCCP.cpp</a>.</p>

</div>
</div>
<a id="a8c2a7464fefab1d85cec445e487f0d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2a7464fefab1d85cec445e487f0d0c">&#9670;&nbsp;</a></span>createSCFBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSCFBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that bufferizes the SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Bufferize_8cpp_source.html#l00039">39</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="abef79e69a6b8ca521bbf9bc4a48937e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef79e69a6b8ca521bbf9bc4a48937e9">&#9670;&nbsp;</a></span>createShapeBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FunctionPass.html">FunctionPass</a> &gt; mlir::createShapeBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Shape_2Transforms_2Bufferize_8cpp_source.html#l00036">36</a> of file <a class="el" href="Dialect_2Shape_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a050e7653e9cef5f155370ca0425994e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050e7653e9cef5f155370ca0425994e9">&#9670;&nbsp;</a></span>createShapeToShapeLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createShapeToShapeLowering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the ShapeToShapeLowering pass that legalizes Shape dialect to be convertible to Standard. </p>
<p>For example, <code>shape.num_elements</code> get transformed to <code>shape.reduce</code>, which can be lowered to SCF and Standard. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00080">80</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

</div>
</div>
<a id="a7a370cf9eebe697f8b1a61109360b5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a370cf9eebe697f8b1a61109360b5e0">&#9670;&nbsp;</a></span>createSimplifyAffineStructuresPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createSimplifyAffineStructuresPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simplification pass for affine structures (maps and sets). </p>
<p>In addition, this pass also normalizes memrefs to have the trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00075">75</a> of file <a class="el" href="SimplifyAffineStructures_8cpp_source.html">SimplifyAffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00359">applyOpPatternsAndFold()</a>, and <a class="el" href="Operation_8h_source.html#l00307">mlir::Operation::getAttrs()</a>.</p>

</div>
</div>
<a id="a92beb0911d97bc65a57ee92a77c231ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92beb0911d97bc65a57ee92a77c231ba">&#9670;&nbsp;</a></span>createStdBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStdBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of std bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2StandardOps_2Transforms_2Bufferize_8cpp_source.html#l00201">201</a> of file <a class="el" href="Dialect_2StandardOps_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a6352a64edaea4b4e39b617a7ca6cdf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6352a64edaea4b4e39b617a7ca6cdf5e">&#9670;&nbsp;</a></span>createStdExpandOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStdExpandOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the StdExpand pass that legalizes Std dialect ops to be convertible to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>For example, <code>std.ceildivi_signed</code> gets transformed to a number of std operations, which can be lowered to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>; <code>memref_reshape</code> gets converted to <code>memref_reinterpret_cast</code>. </p>

<p class="definition">Definition at line <a class="el" href="ExpandOps_8cpp_source.html#l00246">246</a> of file <a class="el" href="ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

</div>
</div>
<a id="a3b152134b4d44a148dac8bfc24070dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b152134b4d44a148dac8bfc24070dcd">&#9670;&nbsp;</a></span>createStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfo_8cpp_source.html#l00030">30</a> of file <a class="el" href="StripDebugInfo_8cpp_source.html">StripDebugInfo.cpp</a>.</p>

</div>
</div>
<a id="a6f35ed77a2654a16846d52d1c49f6866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f35ed77a2654a16846d52d1c49f6866">&#9670;&nbsp;</a></span>createSuperVectorizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createSuperVectorizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>virtualVectorSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to vectorize loops, operations and data types using a target-independent, n-D super-vector abstraction. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01428">1428</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="a7544cfaf2c45f493fa03ceec3e976eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7544cfaf2c45f493fa03ceec3e976eb2">&#9670;&nbsp;</a></span>createSuperVectorizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::createSuperVectorizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01431">1431</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="a69605e45210627de9b7fde4644fa50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69605e45210627de9b7fde4644fa50c1">&#9670;&nbsp;</a></span>createSymbolDCEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createSymbolDCEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which delete symbol operations that are unreachable. </p>
<p>This pass may <em>only</em> be scheduled on an operation that defines a <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolDCE_8cpp_source.html#l00144">144</a> of file <a class="el" href="SymbolDCE_8cpp_source.html">SymbolDCE.cpp</a>.</p>

</div>
</div>
<a id="ae811b6513cd07f50d4b60bcd270d4171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae811b6513cd07f50d4b60bcd270d4171">&#9670;&nbsp;</a></span>createTensorBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTensorBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of <code>tensor</code> dialect bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Transforms_2Bufferize_8cpp_source.html#l00062">62</a> of file <a class="el" href="Dialect_2Tensor_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a5634dcc1162f90dc6df439f3edb444df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5634dcc1162f90dc6df439f3edb444df">&#9670;&nbsp;</a></span>createTensorConstantBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createTensorConstantBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of tensor constant bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="TensorConstantBufferize_8cpp_source.html#l00122">122</a> of file <a class="el" href="TensorConstantBufferize_8cpp_source.html">TensorConstantBufferize.cpp</a>.</p>

</div>
</div>
<a id="a6bc84cc9baea1d755e04cc705616c9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc84cc9baea1d755e04cc705616c9b1">&#9670;&nbsp;</a></span>debugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::debugString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebugStringHelper_8h_source.html#l00027">27</a> of file <a class="el" href="DebugStringHelper_8h_source.html">DebugStringHelper.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>.</p>

</div>
</div>
<a id="a7dc425822a826dd76ea2e8185aeb9fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc425822a826dd76ea2e8185aeb9fab">&#9670;&nbsp;</a></span>defaultFilterFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::defaultFilterFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00091">91</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a0f6910a7b4e1cce403814b5dfd894d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6910a7b4e1cce403814b5dfd894d90">&#9670;&nbsp;</a></span>delinearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; mlir::delinearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>linearIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the strides together with a linear index in the dimension space, returns the vector-space offsets in each dimension for a de-linearized index. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00081">81</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8cpp_source.html#l00044">applyMapToValues()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00846">foldExtractFromShapeCast()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00192">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00935">isValidExtractOrInsertSlicesType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>.</p>

</div>
</div>
<a id="a4e96b0c437652eb5a4890734bb6bcee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96b0c437652eb5a4890734bb6bcee7">&#9670;&nbsp;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit an error message using this location. </p>
<p>Emit an error message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00301">301</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleTranslation_8cpp_source.html#l00053">buildSequentialConstant()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00837">checkedAddLLVMFnAttribute()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00356">checkTensorElementType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00032">computeConversionSet()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00577">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00039">deserializeModule()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00040">diag()</a>, <a class="el" href="Operation_8cpp_source.html#l00286">mlir::Operation::emitError()</a>, <a class="el" href="OpDefinition_8h_source.html#l00208">mlir::OpState::erase()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00877">forwardPassthroughAttributes()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00451">mlir::MemRefType::getChecked()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00903">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00629">getElementType()</a>, <a class="el" href="Lexer_8cpp_source.html#l00041">mlir::Lexer::getEncodedSourceLocation()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00088">getInnermostElementType()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00489">getLLVMAtomicOrdering()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00433">getMemRefSizeInBytes()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00545">getOrInsertBuiltinVariable()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00090">logFailure()</a>, <a class="el" href="CAPI_2IR_2Diagnostics_8cpp_source.html#l00077">mlirEmitError()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00961">parseAccessChainOp()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="OpImplementation_8h_source.html#l00820">mlir::OpAsmParser::parseAssignmentList()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00285">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00454">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00794">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="Parser_8cpp_source.html#l00059">mlir::detail::Parser::parseCommaSeparatedListUntil()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00505">mlir::detail::Parser::parseExtendedAttr()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00138">mlir::DialectAsmParser::parseInteger()</a>, <a class="el" href="OpImplementation_8h_source.html#l00417">mlir::OpAsmParser::parseInteger()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00210">mlir::DialectAsmParser::parseKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00362">mlir::OpAsmParser::parseKeyword()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00150">mlir::DialectAsmParser::parseOptionalInteger()</a>, <a class="el" href="OpImplementation_8h_source.html#l00429">mlir::OpAsmParser::parseOptionalInteger()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00325">mlir::detail::Parser::parsePrettyDialectSymbolName()</a>, <a class="el" href="OpImplementation_8h_source.html#l00547">mlir::OpAsmParser::parseSymbolName()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00314">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00755">mlir::OpAsmParser::parseType()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00045">performActions()</a>, <a class="el" href="OpImplementation_8h_source.html#l00635">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00859">translateLLVMIRToModule()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00027">translateModuleToLLVMIR()</a>, <a class="el" href="ArmSVEToLLVM_8cpp_source.html#l00039">unwrap()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00031">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00155">mlir::spirv::InterfaceVarABIAttr::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00043">mlir::ComplexType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00250">mlir::spirv::VerCapExtAttr::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00061">mlir::IntegerType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00331">mlir::spirv::TargetEnvAttr::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00252">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00220">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00211">mlir::OpaqueType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00341">mlir::IntegerAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00256">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00282">mlir::LLVM::LLVMArrayType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00399">mlir::OpaqueAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00310">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00332">mlir::LLVM::LLVMFunctionType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00321">mlir::VectorType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00357">mlir::LLVM::LLVMIntegerType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00387">mlir::LLVM::LLVMPointerType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00370">mlir::quant::CalibratedQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00388">mlir::RankedTensorType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01116">mlir::spirv::MatrixType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00459">mlir::LLVM::LLVMStructType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00495">mlir::LLVM::LLVMVectorType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00534">mlir::UnrankedMemRefType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00241">verifyFloatTypeInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00330">verifyIntegerTypeInvariants()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l01207">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="a2dc4e9418ff63ebea20c7f709ebcb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">&#9670;&nbsp;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00302">302</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00279">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8h_source.html#l00471">emitOptionalError()</a>.</p>

</div>
</div>
<a id="affdaf0aee1c1669e8b822bf98297b85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdaf0aee1c1669e8b822bf98297b85f">&#9670;&nbsp;</a></span>emitOptionalError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads of the above emission functions that take an optionally null location. </p>
<p>If the location is null, no diagnostic is emitted and a failure is returned. Given that the provided location may be null, these methods take the diagnostic arguments directly instead of relying on the returned <a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported. ">InFlightDiagnostic</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00471">471</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00332">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00302">emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00451">mlir::MemRefType::getChecked()</a>.</p>

</div>
</div>
<a id="ab27e629384a23b9991e36201d87de462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27e629384a23b9991e36201d87de462">&#9670;&nbsp;</a></span>emitOptionalRemark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00483">483</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00332">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00318">emitRemark()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>.</p>

</div>
</div>
<a id="a665c32efa8059ae855341f4946f7497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c32efa8059ae855341f4946f7497c">&#9670;&nbsp;</a></span>emitOptionalWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00477">477</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8h_source.html#l00332">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00310">emitWarning()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>.</p>

</div>
</div>
<a id="a8a9ca6fe9d5aab498bf090db3e878c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ca6fe9d5aab498bf090db3e878c87">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a remark message using this location. </p>
<p>Emit a remark message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00315">315</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operation_8cpp_source.html#l00315">mlir::Operation::emitRemark()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00208">mlir::OpState::erase()</a>.</p>

</div>
</div>
<a id="a391c4b4ea9dc95fbcfbfdab8a49547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00318">318</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00279">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8h_source.html#l00483">emitOptionalRemark()</a>.</p>

</div>
</div>
<a id="a0768c8a572dc71b0b00d57414b56b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c8a572dc71b0b00d57414b56b60d">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a warning message using this location. </p>
<p>Emit a warning message using this location. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00307">307</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operation_8cpp_source.html#l00306">mlir::Operation::emitWarning()</a>, <a class="el" href="OpDefinition_8h_source.html#l00208">mlir::OpState::erase()</a>, and <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00489">getLLVMAtomicOrdering()</a>.</p>

</div>
</div>
<a id="a5e96e5ea091fb5bea539cef6ea7c5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e96e5ea091fb5bea539cef6ea7c5624">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00310">310</a> of file <a class="el" href="IR_2Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00279">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8h_source.html#l00477">emitOptionalWarning()</a>.</p>

</div>
</div>
<a id="ab8075944125730fed529e3b93dcfed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8075944125730fed529e3b93dcfed5b">&#9670;&nbsp;</a></span>encodeBindAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::encodeBindAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a>&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes global variable's descriptor set and binding into its name if they both exist. </p>

<p class="definition">Definition at line <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01529">1529</a> of file <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html">ConvertSPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00312">mlir::IntegerAttr::getInt()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00310">mlir::IntegerAttr::getValue()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01527">kBinding</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01528">kDescriptorSet</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00930">mlir::SymbolTable::replaceAllSymbolUses()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00204">mlir::SymbolTable::setSymbolName()</a>.</p>

</div>
</div>
<a id="a47f2978611fa2c3143d6ea5ea01cd041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f2978611fa2c3143d6ea5ea01cd041">&#9670;&nbsp;</a></span>eraseStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::eraseStridedLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with a layout that has all dynamic offset and strides. </p>
<p>This is used to erase the static layout. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00822">822</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00252">mlir::ShapedType::kDynamicStrideOrOffset</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00723">makeStridedLinearLayoutMap()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00493">mlir::MemRefType::Builder::setAffineMaps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00085">createTypeCanonicalizedMemRefOperands()</a>, and <a class="el" href="LinalgToStandard_8cpp_source.html#l00025">extractOperandTypes()</a>.</p>

</div>
</div>
<a id="ab9dbba661e76a7e45c145e652fbcc853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dbba661e76a7e45c145e652fbcc853">&#9670;&nbsp;</a></span>expandAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">mlir::Value</a> mlir::expandAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dimValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>symbolValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values. </p>
<p>Create a sequence of operations that implement the <code>expr</code> applied to the given dimension and symbol values.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00213">213</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00221">expandAffineMap()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="ae58c2a14651ef626d0d9fcee46698032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58c2a14651ef626d0d9fcee46698032">&#9670;&nbsp;</a></span>expandAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt; mlir::expandAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>affineMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp). </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00221">221</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineToStandard_8cpp_source.html#l00213">expandAffineExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, and <a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754">mlir::vector::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00292">lowerAffineLowerBound()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00265">lowerAffineMapMax()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00274">lowerAffineMapMin()</a>.</p>

</div>
</div>
<a id="aecdaa20d0acb7aec0f05cb700b1e09df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdaa20d0acb7aec0f05cb700b1e09df">&#9670;&nbsp;</a></span>extractFixedOuterLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> mlir::extractFixedOuterLoops </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootFOrOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01862">1862</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00125">ceilDivPositive()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00987">getPerfectlyNestedLoopsImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01753">tile()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01845">tryIsolateBands()</a>.</p>

</div>
</div>
<a id="a13093ebea6c814674ee1668daf5f81f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13093ebea6c814674ee1668daf5f81f8">&#9670;&nbsp;</a></span>extractForInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::extractForInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forInsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>. </p>
<p>Extracts the induction variables from a list of AffineForOps and returns them.</p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01913">1913</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02599">getFullMemRefAsRegion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00088">getIndexSet()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00902">tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00944">tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="aeec13ab4fb753865cdfd2699aa01c23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec13ab4fb753865cdfd2699aa01c23b">&#9670;&nbsp;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::failed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> corresponds to a failure value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00046">46</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Failure</a>, and <a class="el" href="structmlir_1_1LogicalResult.html#a367e2bef1a5e5122bc9d0484479a353a">mlir::LogicalResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00656">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00634">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Simplex_8cpp_source.html#l00360">mlir::Simplex::addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00552">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01834">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00695">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02651">affineDataCopyGenerate()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00615">analyzeProfitability()</a>, <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00359">applyOpPatternsAndFold()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00316">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="Ops_8cpp_source.html#l03472">canFoldIntoConsumerOp()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00263">canFuseLoops()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00942">canFuseSrcWhichWritesToLiveOut()</a>, <a class="el" href="UpdateVCEPass_8cpp_source.html#l00070">checkAndUpdateCapabilityRequirements()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00859">checkMemrefAccessDependence()</a>, <a class="el" href="Ops_8cpp_source.html#l00569">collapseBranch()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00123">mlir::spirv::combine()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00464">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00536">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00032">computeConversionSet()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02098">mlir::FlatAffineConstraints::constantFoldIdRange()</a>, <a class="el" href="include_2mlir_2Parser_8h_source.html#l00036">mlir::detail::constructContainerOpForParserIfNecessary()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00263">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02502">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00226">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00461">mlir::LLVM::ModuleTranslation::convertOmpOpRegions()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00394">mlir::LLVM::ModuleTranslation::convertOmpParallel()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00577">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="FrozenRewritePatternList_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00085">convertRangeType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01142">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02466">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02481">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00285">convertStructType()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00214">convertToLaunchFuncOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02423">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02436">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="FoldUtils_8h_source.html#l00060">mlir::OperationFolder::create()</a>, <a class="el" href="PassOptions_8h_source.html#l00255">mlir::PassPipelineOptions&lt; EmptyPipelineOptions &gt;::createFromString()</a>, <a class="el" href="Generalization_8cpp_source.html#l00033">createGenericOpFromNamedOp()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00229">mlir::LLVM::LLVMType::createStructTy()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01339">mlir::OpaqueElementsAttr::decode()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00019">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="Deserialization_8cpp_source.html#l02785">mlir::spirv::deserialize()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00040">diag()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01529">encodeBindAttribute()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00048">extractCompositeElement()</a>, <a class="el" href="LogicalResult_8h_source.html#l00057">mlir::FailureOr&lt; T &gt;::FailureOr()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00153">finalizeBufferAllocation()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00164">findMatchingStartFinishInsts()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00176">mlir::FlatAffineConstraints::FlatAffineConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01675">foldLoopBounds()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00877">forwardPassthroughAttributes()</a>, <a class="el" href="FrozenRewritePatternList_8cpp_source.html#l00056">mlir::FrozenRewritePatternList::FrozenRewritePatternList()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02851">generateCopyForMemRegion()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00119">generateLocationsFromIR()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00668">mlir::spirv::SPIRVConversionTarget::get()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02999">mlir::FlatAffineConstraints::getAsIntegerSet()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00163">getBase()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00180">getBasePtr()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02179">getCastCompatibleMemRefType()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00100">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00218">getDefaultABIAttrs()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00604">mlir::spirv::getElementPtr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00903">getElementPtrType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00992">mlir::spirv::StructType::getEmpty()</a>, <a class="el" href="OpDefinition_8h_source.html#l01559">mlir::Op&lt; DmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;::getFromOpaquePointer()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00206">getIndexedPtrs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00088">getIndexSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02946">mlir::FlatAffineConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00489">getLLVMAtomicOrdering()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00989">getMemoryFootprintBytes()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00433">getMemRefSizeInBytes()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00219">mlir::detail::PassOptions::getOptionWidth()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00157">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00515">hasSizeMismatch()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00084">mlir::linalg::hoistRedundantVectorTransfers()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00024">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="ByteCode_8cpp_source.html#l00699">mlir::detail::PDLByteCode::initializeMutableState()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00297">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00432">inlineCallsInSCC()</a>, <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00311">isAsyncWithOneDependency()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00246">JitRunnerMain()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00303">mlir::SymbolTable::lookupSymbolIn()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00959">mlir::SymbolTableCollection::lookupSymbolIn()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00166">lowerAsEntryFunction()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00025">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00124">mlir::vector::UnrollVectorPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02455">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00328">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01685">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01798">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00405">mlir::OpConversionPattern&lt; SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00421">mlir::linalg::LinalgTilingPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01930">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00163">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00249">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00275">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00302">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00119">mlir::linalg::LinalgBaseTilingPattern::matchAndRewriteBase()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l03752">matchSimpleAtomicOp()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>, <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00078">moveLoopInvariantCode()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00396">normalizeMemRef()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00437">normalizeMemRefType()</a>, <a class="el" href="OpDefinition_8h_source.html#l00048">mlir::ParseResult::operator bool()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02904">parseAffineParallelOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00465">parseAndVerify&lt; unsigned &gt;()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00274">parseArrayType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00569">parseAttributions()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01434">parseBound()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00297">parseCalibratedType()</a>, <a class="el" href="Shape_8cpp_source.html#l00363">parseConstShapeOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, <a class="el" href="Async_8cpp_source.html#l00212">parseExecuteOp()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00094">parseExpressedTypeAndRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01708">parseFenceOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01717">parseFuncOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00016">mlir::impl::parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00163">mlir::impl::parseFunctionLikeOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00095">parseFunctionResultList()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00318">parseGenericOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01150">parseGlobalOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00602">parseGPUFuncOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00871">parseInterfaceVarABIAttr()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00845">parseKeywordList()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00107">parseListOfOperandsOrIntegers()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01368">parseLLVMFuncOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00464">parseLoopOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02341">parseMemRefReinterpretCastOp()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00046">parseOperandList()</a>, <a class="el" href="PDL_8cpp_source.html#l00120">parseOperationOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00244">parseOptionalArrayStride()</a>, <a class="el" href="Parser_8cpp_source.html#l00098">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00150">mlir::DialectAsmParser::parseOptionalInteger()</a>, <a class="el" href="OpImplementation_8h_source.html#l00429">mlir::OpAsmParser::parseOptionalInteger()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00183">parseParallelOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00470">parsePassPipeline()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00162">parseQuantParams()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00376">parseRuntimeArrayType()</a>, <a class="el" href="include_2mlir_2Parser_8h_source.html#l00129">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_8h_source.html#l00187">parseSourceString()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00025">parseStorageType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">mlir::detail::Parser::parseStridedLayout()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00540">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00604">parseStructType()</a>, <a class="el" href="Ops_8cpp_source.html#l03782">parseSubTensorInsertOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03668">parseSubTensorOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03059">parseSubViewOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00547">mlir::OpAsmParser::parseSymbolName()</a>, <a class="el" href="PassRegistry_8h_source.html#l00167">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00045">performActions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00512">performPreTilingChecks()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00664">populateAffineToVectorConversionPatterns()</a>, <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00108">populateConvertShapeConstraintsConversionPatterns()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00069">populateElementwiseToLinalgConversionPatterns()</a>, <a class="el" href="Transforms_2Bufferize_8cpp_source.html#l00085">populateEliminateBufferizeMaterializationsPatterns()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00187">mlir::linalg::populateLinalgToStandardConversionPatterns()</a>, <a class="el" href="SCFToStandard_8cpp_source.html#l00571">populateLoopToStdConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00044">populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="DecorateSPIRVCompositeTypeLayoutPass_8cpp_source.html#l00077">populateSPIRVLayoutInfoPatterns()</a>, <a class="el" href="Dialect_2StandardOps_2Transforms_2Bufferize_8cpp_source.html#l00157">populateStdBufferizePatterns()</a>, <a class="el" href="Dialect_2Tensor_2Transforms_2Bufferize_8cpp_source.html#l00037">populateTensorBufferizePatterns()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00150">populateVectorToROCDLConversionPatterns()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l00120">populateVectorToSPIRVPatterns()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01282">printFloatValue()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00377">processParallelLoop()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l04077">mlir::LLVMTypeConverter::promoteOperands()</a>, <a class="el" href="Promotion_8cpp_source.html#l00387">mlir::linalg::promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00265">promoteSubViews()</a>, <a class="el" href="Translation_8cpp_source.html#l00060">registerTranslateToMLIRFunction()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01039">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00220">replaceAllMemRefUsesWith()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00220">replaceTransferOpWithLoadOrStore()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00232">replaceTransferOpWithMasked()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00111">resolveSourceIndices()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00483">mlir::detail::OpToOpPassAdaptor::runOnOperation()</a>, <a class="el" href="Inliner_8cpp_source.html#l00286">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03066">separateFullTiles()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00082">serializeModule()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00325">mlir::OpPassManager::setNesting()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00410">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00021">splitAndProcessBuffer()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00902">tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00944">tilePerfectlyNestedParametric()</a>, <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00838">translateLLVMIRToModule()</a>, <a class="el" href="ModuleTranslation_8h_source.html#l00054">mlir::LLVM::ModuleTranslation::translateModule()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00400">mlir::OpBuilder::tryFold()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00087">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00082">updateCalls()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00046">updateSymbolAndAllUses()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00798">vectorizeAffineForOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01170">vectorizeLoopNest()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01267">vectorizeLoops()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00853">vectorizeLoopsAndLoads()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00510">verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00721">verifyAttributions()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00252">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00220">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00341">mlir::IntegerAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00256">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00310">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03220">verifyCopyMemory()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00499">verifyGenericOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00770">verifyGroupNonUniformArithmeticOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00049">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="Operation_8cpp_source.html#l00904">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00871">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00928">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00890">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00859">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01260">verifySingleInputPoolingOp()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00074">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00109">mlir::OpTrait::linalg::NamedStructuredOpTrait&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00467">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00151">mlir::detail::verifyTypesAlongControlFlowEdges()</a>, <a class="el" href="Serialization_8cpp_source.html#l00065">visitInPrettyBlockOrder()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01271">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a07367c8c4a3d4a47a32bc2b9b7d8a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">&#9670;&nbsp;</a></span>failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFailure</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a>. </p>
<p>If isFailure is true a <code>failure</code> result is generated, otherwise a 'success' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00033">33</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Failure</a>, and <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00540">ableToUpdatePredOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00656">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00552">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01834">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00695">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00044">allocateBuffersForResults()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00615">analyzeProfitability()</a>, <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00240">applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00316">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00088">barePtrFuncArgTypeConverter()</a>, <a class="el" href="Ops_8cpp_source.html#l01283">mlir::ConstantIndexOp::build()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01995">buildAffineLoopNest()</a>, <a class="el" href="Ops_8cpp_source.html#l03544">canFoldIntoConsumerOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02829">mlir::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01721">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00985">canonicalizeSetAndOperands()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00065">checkCapabilityRequirements()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00038">checkExtensionRequirements()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00582">checkIfHyperRectangular()</a>, <a class="el" href="Ops_8cpp_source.html#l00569">collapseBranch()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00573">collapseReassociationMaps()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00043">collectValidReferencesFor()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00464">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00536">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00032">computeConversionSet()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00238">mlir::AffineMap::constantFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02085">mlir::FlatAffineConstraints::constantFoldId()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00263">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02502">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00461">mlir::LLVM::ModuleTranslation::convertOmpOpRegions()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00394">mlir::LLVM::ModuleTranslation::convertOmpParallel()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00577">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="FrozenRewritePatternList_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00085">convertRangeType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01142">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02466">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02481">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00285">convertStructType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02387">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02436">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03011">createFullTiles()</a>, <a class="el" href="Generalization_8cpp_source.html#l00033">createGenericOpFromNamedOp()</a>, <a class="el" href="DecodeAttributesInterfaces_8h_source.html#l00029">mlir::DialectDecodeAttributesInterface::decode()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00019">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00471">emitOptionalError()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00483">emitOptionalRemark()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00477">emitOptionalWarning()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00048">extractCompositeElement()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00558">extractStrides()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00080">extractValueFromConstOp()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00153">finalizeBufferAllocation()</a>, <a class="el" href="FoldInterfaces_8h_source.html#l00033">mlir::DialectFoldInterface::fold()</a>, <a class="el" href="Operation_8cpp_source.html#l00574">mlir::Operation::fold()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00652">foldExtractOpFromExtractChain()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00675">foldExtractOpFromTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01694">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01675">foldLoopBounds()</a>, <a class="el" href="OpDefinition_8h_source.html#l01388">mlir::op_definition_impl::foldTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01440">mlir::op_definition_impl::foldTraits()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02114">foldTransferMaskAttribute()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00877">forwardPassthroughAttributes()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00935">mlir::linalg::fuseTensorOps()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00437">fuseWithReshapeByExpansion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00928">genStmt()</a>, <a class="el" href="OpImplementation_8h_source.html#l00881">mlir::OpAsmDialectInterface::getAlias()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00163">getBase()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00180">getBasePtr()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00218">getDefaultABIAttrs()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00211">mlir::spirv::getExecutionModel()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00070">getFlattenedAffineExprs()</a>, <a class="el" href="OpDefinition_8h_source.html#l01559">mlir::Op&lt; DmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;::getFromOpaquePointer()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00206">getIndexedPtrs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00088">getIndexSet()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00071">getInterfaceVariables()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00102">getLaunchConfigIndex()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00489">getLLVMAtomicOrdering()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="TargetAndABI_8cpp_source.html#l00222">mlir::spirv::getMemoryModel()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00146">getMemRefAlignment()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00433">getMemRefSizeInBytes()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00219">mlir::detail::PassOptions::getOptionWidth()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00157">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Ops_8cpp_source.html#l03316">getOrCreateRanges()</a>, <a class="el" href="SCF_8cpp_source.html#l01012">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html#l00025">getSrcVectorElementType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01606">handleMultidimensionalVectors()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00515">hasSizeMismatch()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">hoistAffineIfOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01803">hoistOpsBetween()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00024">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00505">initializeAliases()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00297">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00432">inlineCallsInSCC()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00140">inlineRegion()</a>, <a class="el" href="Interchange_8cpp_source.html#l00035">mlir::linalg::interchangeGenericLinalgOpPrecondition()</a>, <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00311">isAsyncWithOneDependency()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00069">isContraction()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="Ops_8cpp_source.html#l03864">joinShapes()</a>, <a class="el" href="Loops_8cpp_source.html#l00673">mlir::linalg::linalgOpToAffineLoops()</a>, <a class="el" href="Loops_8cpp_source.html#l00680">mlir::linalg::linalgOpToLoops()</a>, <a class="el" href="Loops_8cpp_source.html#l00508">linalgOpToLoopsImpl()</a>, <a class="el" href="Loops_8cpp_source.html#l00686">mlir::linalg::linalgOpToParallelLoops()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00090">logFailure()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00313">lookupSymbolInImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01031">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00292">lowerAffineLowerBound()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="Loops_8cpp_source.html#l00572">lowerLinalgToLoopsImpl()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00025">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00102">mlir::linalg::LinalgOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00040">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="IndexIntrinsicsOpLowering_8h_source.html#l00044">mlir::GPUIndexIntrinsicOpLowering&lt; Op, XOp, YOp, ZOp &gt;::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00119">mlir::linalg::CopyOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00111">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00139">mlir::linalg::CopyTransposeRewrite::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00162">mlir::linalg::IndexedGenericOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00124">mlir::vector::UnrollVectorPattern::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00173">mlir::RewritePattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02455">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00220">mlir::OpRewritePattern&lt; vector::ContractionOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02470">mlir::vector::PointwiseExtractPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00328">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01685">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01798">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00405">mlir::OpConversionPattern&lt; SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00421">mlir::linalg::LinalgTilingPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01930">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00163">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00249">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00275">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00534">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00302">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00598">mlir::ConvertOpToLLVMPattern&lt; gpu::ReturnOp &gt;::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00410">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00487">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00466">mlir::linalg::AffineMinSCFCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00535">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02524">TransferReadExtractPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02562">TransferWriteInsertPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00119">mlir::linalg::LinalgBaseTilingPattern::matchAndRewriteBase()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l03752">matchSimpleAtomicOp()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00620">mergeIdenticalBlocks()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00235">mlir::LLVM::detail::LLVMStructTypeStorage::mutate()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00923">mlir::spirv::detail::StructTypeStorage::mutate()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00396">normalizeMemRef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00518">mlir::PatternRewriter::notifyMatchFailure()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01242">mlir::detail::ConversionPatternRewriterImpl::notifyMatchFailure()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01568">mlir::LLVM::detail::oneToOneRewrite()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00166">mlir::Diagnostic::operator LogicalResult()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00174">mlir::InFlightDiagnostic::operator LogicalResult()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00788">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01130">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01521">mlir::DmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01680">mlir::DmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01279">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00961">parseAccessChainOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00480">parseAffineApplyOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01525">parseAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02049">parseAffineIfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02225">parseAffineLoadOp()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02427">parseAffineMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02904">parseAffineParallelOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02516">parseAffinePrefetchOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02339">parseAffineStoreOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03063">parseAffineVectorLoadOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03149">parseAffineVectorStoreOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00136">parseAllocaOp()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00086">parseAllocateAndAllocator()</a>, <a class="el" href="Shape_8cpp_source.html#l00165">parseAssumingOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01533">parseAtomicBinOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01655">parseAtomicCmpXchgOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01065">parseAtomicCompareExchangeWeakOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01559">parseAtomicOrdering()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01596">parseAtomicRMWOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00656">parseAtomicUpdateOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00043">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00285">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00454">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00246">mlir::detail::Parser::parseAttributeDict()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00569">parseAttributions()</a>, <a class="el" href="Async_8cpp_source.html#l00330">parseAwaitResultType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01434">parseBound()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01189">parseBranchConditionalOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00645">parseCallOp()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="Operation_8cpp_source.html#l01191">mlir::impl::parseCastOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00062">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00794">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="Parser_8cpp_source.html#l00039">mlir::detail::Parser::parseCommaSeparatedList()</a>, <a class="el" href="Parser_8cpp_source.html#l00059">mlir::detail::Parser::parseCommaSeparatedListUntil()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01526">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01278">parseCompositeConstructOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01363">parseCompositeExtractOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01420">parseCompositeInsertOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01474">parseConstantOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00363">parseConstShapeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00211">parseContractionOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00171">parseControlAttribute()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02991">parseCooperativeMatrixLoadNVOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03045">parseCooperativeMatrixStoreNVOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03178">parseCopyMemoryOp()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00032">parseCreateOperationOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00435">parseDimAndSymbolList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00484">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="Ops_8cpp_source.html#l01736">parseDynamicTensorFromElementsOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01614">parseEntryPointOp()</a>, <a class="el" href="ParserUtils_8h_source.html#l00025">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00156">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00113">parseEnumStrAttr()</a>, <a class="el" href="Async_8cpp_source.html#l00212">parseExecuteOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01675">parseExecutionModeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00749">parseExtractElementOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00595">parseExtractOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00829">parseExtractValueOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01708">parseFenceOp()</a>, <a class="el" href="SCF_8cpp_source.html#l00178">parseForOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00137">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01717">parseFuncOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00016">mlir::impl::parseFunctionArgumentList()</a>, <a class="el" href="Shape_8cpp_source.html#l00584">parseFunctionLibraryOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00163">mlir::impl::parseFunctionLikeOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00095">parseFunctionResultList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFunctionResultTypes()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00128">mlir::impl::parseFunctionSignature()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="Ops_8cpp_source.html#l00518">parseGenericAtomicRMWOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00318">parseGenericOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02045">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01150">parseGlobalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01935">parseGlobalVariableOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00602">parseGPUFuncOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00815">parseGPUModuleOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00717">parseGroupNonUniformArithmeticOp()</a>, <a class="el" href="SCF_8cpp_source.html#l00627">parseIfOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00867">parseInsertElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00911">parseInsertValueOp()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00363">parseInvokeOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00845">parseKeywordList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00833">mlir::OpAsmParser::parseKeywordType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00517">parseLandingpadOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00384">parseLaunchOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00107">parseListOfOperandsOrIntegers()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01368">parseLLVMFuncOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00233">parseLoadOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00836">parseLogicalBinaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00824">parseLogicalUnaryOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00464">parseLoopOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00192">parseMemoryAccessAttributes()</a>, <a class="el" href="Ops_8cpp_source.html#l02341">parseMemRefReinterpretCastOp()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02451">parseModuleOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01578">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01517">parseNamedStructuredOpResults()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00095">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00046">parseNVVMShflSyncBflyOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00071">parseNVVMVoteBallotOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00155">parseOffsetsSizesAndStrides()</a>, <a class="el" href="Operation_8cpp_source.html#l01151">mlir::impl::parseOneResultSameOperandTypeOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00104">parseOperandAndType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00058">parseOperandAndTypeList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00046">parseOperandList()</a>, <a class="el" href="PDL_8cpp_source.html#l00120">parseOperationOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00244">parseOptionalArrayStride()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00197">mlir::detail::Parser::parseOptionalAttributeWithToken()</a>, <a class="el" href="Parser_8cpp_source.html#l00098">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01131">parseOptionalLLVMKeyword()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00089">parseOptionalOperand()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00118">parseOptionalOperandAndType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">mlir::detail::Parser::parseOptionalType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01007">mlir::impl::parseOptionalVisibilityKeyword()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01488">parseOuterProductOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00183">parseParallelOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00470">parsePassPipeline()</a>, <a class="el" href="Ops_8cpp_source.html#l02521">parsePrefetchOp()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00162">parseQuantParams()</a>, <a class="el" href="SCF_8cpp_source.html#l01141">parseReduceOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00155">parseReductionOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00030">parseRegions()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00769">parseReturnOp()</a>, <a class="el" href="ROCDLDialect_8cpp_source.html#l00040">parseROCDLMubufLoadOp()</a>, <a class="el" href="ROCDLDialect_8cpp_source.html#l00060">parseROCDLMubufStoreOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02649">parseSelectionOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02640">parseSelectOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00853">parseShiftOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00200">parseShuffleOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01260">parseShuffleVectorOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00356">parseSizeAssignment()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01053">parseSliceOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00223">parseSourceMemoryAccessAttributes()</a>, <a class="el" href="Parser_8cpp_source.html#l02127">parseSourceString()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03313">parseSpecConstantCompositeOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02767">parseSpecConstantOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03419">parseSpecConstantOperationOp()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00281">parseStoreOp()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00541">mlir::detail::Parser::parseStrideList()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00540">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02086">parseSubgroupBlockReadINTELOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02129">parseSubgroupBlockWriteINTELOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03782">parseSubTensorInsertOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03668">parseSubTensorOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03059">parseSubViewOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02004">parseTransferReadOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02181">parseTransferWriteOp()</a>, <a class="el" href="Ops_8cpp_source.html#l04013">parseTransposeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02898">parseTupleGetOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02760">parseTupleOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00314">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00755">mlir::OpAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00772">mlir::OpAsmParser::parseTypeList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">mlir::detail::Parser::parseTypeListNoParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">mlir::detail::Parser::parseTypeListParens()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00799">parseUnaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00491">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02889">parseVariableOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00939">parseVerCapExtAttr()</a>, <a class="el" href="Ops_8cpp_source.html#l04134">parseViewOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01108">parseYieldOp()</a>, <a class="el" href="PassRegistry_8h_source.html#l00167">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00189">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00045">performActions()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00040">populateCallOpTypeConversionPattern()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02100">print()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00377">processParallelLoop()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, <a class="el" href="Promotion_8cpp_source.html#l00367">mlir::linalg::promoteSubviewsPrecondition()</a>, <a class="el" href="LLVMArmNeonIntr_8cpp_source.html#l00046">registerArmNeonToLLVMIRTranslation()</a>, <a class="el" href="LLVMArmSVEIntr_8cpp_source.html#l00046">registerArmSVEToLLVMIRTranslation()</a>, <a class="el" href="LLVMAVX512Intr_8cpp_source.html#l00046">registerAVX512ToLLVMIRTranslation()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00039">registerToLLVMIRTranslation()</a>, <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00100">registerToNVVMIRTranslation()</a>, <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00104">registerToROCDLIRTranslation()</a>, <a class="el" href="Translation_8cpp_source.html#l00060">registerTranslateToMLIRFunction()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00849">replaceAllSymbolUsesImpl()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00157">replaceBlockArgForUnitDimLoops&lt; IndexedGenericOp &gt;()</a>, <a class="el" href="SCF_8cpp_source.html#l00398">replaceOpWithRegion()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00220">replaceTransferOpWithLoadOrStore()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00232">replaceTransferOpWithMasked()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00040">replaceTransferOpWithMubuf()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00247">replaceUnitExtents()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00220">replaceWithLoadOrStore()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00110">reshapeLowerToHigher()</a>, <a class="el" href="OpImplementation_8h_source.html#l00624">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00111">resolveSourceIndices()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00358">runRegionDCE()</a>, <a class="el" href="Inliner_8cpp_source.html#l00286">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03066">separateFullTiles()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00082">serializeModule()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00325">mlir::OpPassManager::setNesting()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00410">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00021">splitAndProcessBuffer()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02382">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02154">mlir::vector::splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">structFuncArgTypeConverter()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00902">tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00944">tilePerfectlyNestedParametric()</a>, <a class="el" href="Translation_8cpp_source.html#l00094">mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00400">mlir::OpBuilder::tryFold()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01845">tryIsolateBands()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00087">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02789">mlir::FlatAffineConstraints::unionBoundingBox()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00634">mlir::vector::unrollTransferWriteOp()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00082">updateCalls()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00798">vectorizeAffineForOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00277">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01170">vectorizeLoopNest()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00853">vectorizeLoopsAndLoads()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01097">vectorizeNonTerminals()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">verify()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00693">mlir::SourceMgrDiagnosticVerifierHandler::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01393">verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00721">verifyAttributions()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00054">verifyCompatibleShape()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00252">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00220">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00341">mlir::IntegerAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00256">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00310">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00115">verifyConvOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03220">verifyCopyMemory()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00092">verifyDependencies()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00499">verifyGenericOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00049">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00615">verifyLoopOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01639">verifyNamedStructuredOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00904">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00871">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00928">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00890">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00859">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01260">verifySingleInputPoolingOp()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00074">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00109">mlir::OpTrait::linalg::NamedStructuredOpTrait&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00467">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01134">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01486">mlir::op_definition_impl::verifyTraitsImpl()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00151">mlir::detail::verifyTypesAlongControlFlowEdges()</a>, <a class="el" href="Serialization_8cpp_source.html#l00065">visitInPrettyBlockOrder()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01271">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="aaad29aea3470290e8766e38917b9e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad29aea3470290e8766e38917b9e65b">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00055">55</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::den</a>, <a class="el" href="MathExtras_8h_source.html#l00032">floorDiv()</a>, and <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::num</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l01102">mlir::Simplex::computeIntegerBounds()</a>.</p>

</div>
</div>
<a id="a3983eab6c9a05efd28747c0e79dd9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983eab6c9a05efd28747c0e79dd9d44">&#9670;&nbsp;</a></span>floorDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::floorDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's floordiv operation on constants. </p>
<p>The RHS is expected to be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00032">32</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01074">mlir::FlatAffineConstraints::containsPoint()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00775">createPrivateMemRef()</a>, <a class="el" href="Fraction_8h_source.html#l00055">floor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02118">mlir::FlatAffineConstraints::getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01483">mlir::FlatAffineConstraints::getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>, <a class="el" href="Simplex_8cpp_source.html#l00776">mlir::GBRSimplex::removeLastEquality()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00386">substituteLoopInExpr()</a>.</p>

</div>
</div>
<a id="ab80da81dcbeeee5cc76ed25a83f10200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80da81dcbeeee5cc76ed25a83f10200">&#9670;&nbsp;</a></span>fullyComposeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::fullyComposeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an AffineApplyOp. </p>
<p>When this function returns, <code>map</code> becomes the composed affine map, and each <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <code>operands</code> is guaranteed to be either a loop IV or a terminal symbol, i.e., a symbol defined at the top level or a block/function argument. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00839">839</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00828">composeAffineMapAndOperands()</a>, and <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00044">applyMapToValues()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00328">createAffineComputationSlice()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02907">createCanonicalizedAffineForOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00035">createFoldedComposedAffineApply()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02219">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00757">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00406">substitute()</a>.</p>

</div>
</div>
<a id="ac36b4ab10b3417f15b045f8428a3f164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36b4ab10b3417f15b045f8428a3f164">&#9670;&nbsp;</a></span>fuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::fuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSlice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">367</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00980">canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01903">getForInductionVarOwner()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00074">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00070">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::lbs</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00072">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8h_source.html#l00077">mlir::FusionStrategy::FusionStrategy()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a419814bc8dbc6700ad0e76e437acacc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419814bc8dbc6700ad0e76e437acacc0">&#9670;&nbsp;</a></span>gatherLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::gatherLoops </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>depthToLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers all AffineForOps in 'func' grouped by loop depth. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02891">2891</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02875">gatherLoopsInBlock()</a>.</p>

</div>
</div>
<a id="aac4e3e10aeb7dc1e0f93a00c4a3723c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4e3e10aeb7dc1e0f93a00c4a3723c0">&#9670;&nbsp;</a></span>generateCopyForMemRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateCopyForMemRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>memrefRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>analyzedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1CopyGenerateResult.html">CopyGenerateResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateCopyForMemRegion is similar to affineDataCopyGenerate, but works with a single memref region. </p>
<p><code>memrefRegion</code> is supposed to contain analysis information within analyzedOp. The generated prologue and epilogue always surround <code>analyzedOp</code>.</p>
<p>Note that <code>analyzedOp</code> is a single op for API convenience, and the [begin, end) version can be added as needed.</p>
<p>Also note that certain options in <code>copyOptions</code> aren't looked at anymore, like slowMemorySpace. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02851">2851</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8h_source.html#l00212">mlir::CopyGenerateResult::alloc</a>, <a class="el" href="LoopUtils_8h_source.html#l00216">mlir::CopyGenerateResult::copyNest</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="Operation_8h_source.html#l00096">mlir::Operation::getBlock()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00269">mlir::MemRefRegion::memref</a>, <a class="el" href="LoopUtils_8h_source.html#l00209">mlir::CopyGenerateResult::sizeInBytes</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a2d3bd1afbf84ef9cca6c336a104d7280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3bd1afbf84ef9cca6c336a104d7280">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations replace the current operation locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00095">95</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LocationSnapshot_8cpp_source.html#l00111">generateLocationsFromIR()</a>, and <a class="el" href="LocationSnapshot_8cpp_source.html#l00065">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="af16c6823f94d6ce99fa7da7547658345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16c6823f94d6ce99fa7da7547658345">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00102">102</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LocationSnapshot_8cpp_source.html#l00024">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="a94e9bde94caabba0feba96a044a09afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9bde94caabba0feba96a044a09afc">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given stream, and using the printed locations within that stream. </p>
<p>The generated locations are represented as a <a class="el" href="classmlir_1_1NameLoc.html" title="Represents an identity name attached to a child location. ">NameLoc</a> with the given tag as the name, and then fused with the existing locations. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00111">111</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LocationSnapshot_8cpp_source.html#l00095">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="ab170389f5f17475f89037e332018b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170389f5f17475f89037e332018b4f8">&#9670;&nbsp;</a></span>generateLocationsFromIR() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::generateLocationsFromIR </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates new locations from the given IR by snapshotting the IR to the given file, and using the printed locations within that file. </p>
<p>If <code>filename</code> is empty, a temporary file is generated instead. </p>

<p class="definition">Definition at line <a class="el" href="LocationSnapshot_8cpp_source.html#l00119">119</a> of file <a class="el" href="LocationSnapshot_8cpp_source.html">LocationSnapshot.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00024">generateLocationsFromIR()</a>, and <a class="el" href="LocationSnapshot_8cpp_source.html#l00095">generateLocationsFromIR()</a>.</p>

</div>
</div>
<a id="a6e8a0f44c623301035b6151ca51cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a0f44c623301035b6151ca51cca4d">&#9670;&nbsp;</a></span>getAffineBinaryOpExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineBinaryOpExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00043">43</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baec211f7c20af43e742bf2570c3cb84f9">Add</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">CeilDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00752">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00709">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>.</p>

<p class="reference">Referenced by <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00099">mlirAffineAddExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00152">mlirAffineCeilDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00138">mlirAffineFloorDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00125">mlirAffineModExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00112">mlirAffineMulExprGet()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00105">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00062">mlir::AffineExpr::replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">simplifyAdd()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00403">simplifySemiAffine()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00353">substWithMin()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00346">symbolicDivide()</a>.</p>

</div>
</div>
<a id="ab26cdced424aa629fde4150cc8674d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cdced424aa629fde4150cc8674d50">&#9670;&nbsp;</a></span>getAffineConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineConstantExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">478</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00175">mlir::StorageUniquer::get()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00851">mlir::MLIRContext::getAffineUniquer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00904">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00087">categorizeValueByAffineType()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00752">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00336">mlir::AffineMap::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01312">detectAsFloorDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00709">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00305">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00826">getAffineExprFromFlatForm()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02999">mlir::FlatAffineConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00094">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="IntegerSet_8h_source.html#l00054">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="Loops_8cpp_source.html#l00220">getPaddedInput()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00458">getProjectedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00176">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00723">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00083">mlirAffineConstantExprGet()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00799">mlir::AffineExpr::operator%()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::AffineExpr::operator*()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00583">mlir::AffineExpr::operator+()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00656">mlir::AffineExpr::operator-()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00474">mlir::AffineExpr::operator==()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00257">mlir::AffineMap::partialConstantFold()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00247">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00488">simplifyAdd()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00722">simplifyCeilDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00666">simplifyFloorDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00765">simplifyMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00596">simplifyMul()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00403">simplifySemiAffine()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00346">symbolicDivide()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00285">verifyOutputShape()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00974">mlir::SimpleAffineExprFlattener::visitConstantExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00900">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="addfd4323ef72147332661606b030d04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4323ef72147332661606b030d04d">&#9670;&nbsp;</a></span>getAffineDimExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineDimExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These free functions allow clients of the API to not use classes in detail. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">453</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bab49b848e4bb608f4d5650e4b2817c641">DimId</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00442">getAffineDimOrSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00073">adjustMap()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00282">mlir::detail::bindDims()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01058">calculateImplicitMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00904">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00861">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00087">categorizeValueByAffineType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00573">collapseReassociationMaps()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">mlir::AffineMap::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02916">computeLocalVars()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00297">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00826">getAffineExprFromFlatForm()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00454">getDimMap()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01325">mlir::linalg::getDimsOfType()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00168">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Loops_8cpp_source.html#l00220">getPaddedInput()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00114">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00458">getProjectedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00417">inversePermutation()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00253">mlir::AffineExpr::isFunctionOfDim()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01351">mlir::linalg::makeAffineDimExprs()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00828">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00176">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00723">makeStridedLinearLayoutMap()</a>, <a class="el" href="Tiling_8cpp_source.html#l00222">makeTiledShapes()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00535">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00059">mlirAffineDimExprGet()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">operator-()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00632">promoteComposedSymbolsAsDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00247">replaceUnitExtents()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00406">substitute()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00386">substituteLoopInExpr()</a>, <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00039">mlir::scf::tileParallelLoop()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00510">verify()</a>.</p>

</div>
</div>
<a id="a8ad71c14bebce843758768ff160e2283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad71c14bebce843758768ff160e2283">&#9670;&nbsp;</a></span>getAffineExprFromFlatForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineExprFromFlatForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>flatExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an affine expression from a flat ArrayRef. </p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, 'localExprs' is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> for it, and is substituted into. The ArrayRef 'eq' is expected to be in the format [dims, symbols, locals, constant term].</p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <code>localExprs</code> is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> for it, and is substituted into. The ArrayRef <code>flatExprs</code> is expected to be in the format [dims, symbols, locals, constant term]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00826">826</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00177">mlir::AffineExpr::expr</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">getAffineDimExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00463">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02999">mlir::FlatAffineConstraints::getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02946">mlir::FlatAffineConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01483">mlir::FlatAffineConstraints::getLowerAndUpperBound()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">operator-()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01072">simplifyAffineExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00974">mlir::SimpleAffineExprFlattener::visitConstantExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00900">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="aefb7ba5a55b4f16631528884d3617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb7ba5a55b4f16631528884d3617a47">&#9670;&nbsp;</a></span>getAffineSymbolExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineSymbolExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00463">463</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00442">getAffineDimOrSymbol()</a>, and <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00904">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00861">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00087">categorizeValueByAffineType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">mlir::AffineMap::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02916">computeLocalVars()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00826">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00301">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00723">makeStridedLinearLayoutMap()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00071">mlirAffineSymbolExprGet()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">operator-()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00632">promoteComposedSymbolsAsDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00096">mlir::AffineExpr::shiftSymbols()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00386">substituteLoopInExpr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00510">verify()</a>.</p>

</div>
</div>
<a id="ac79d3eafe91790995ee06ed0e61ebc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79d3eafe91790995ee06ed0e61ebc82">&#9670;&nbsp;</a></span>getAllIteratorTypeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;StringRef&gt; mlir::getAllIteratorTypeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has window semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00099">99</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00078">getParallelIteratorTypeName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00085">getReductionIteratorTypeName()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00092">getWindowIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00107">getNumIterators()</a>.</p>

</div>
</div>
<a id="a40741d257063d17fe7e8da3ebea443a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40741d257063d17fe7e8da3ebea443a3">&#9670;&nbsp;</a></span>getBackwardSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>backwardSlice</code> with the computed backward slice (i.e. </p>
<p>all the transitive defs of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at defs transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForInst or the scope within an IfInst.</p>
<p>The implementation traverses the def chains in postorder traversal for efficiency reasons: if an operation is already in <code>backwardSlice</code>, no need to traverse its definitions again. Since useuse-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>backwardSlice</code> is filled with a postorder list of defs. This happens to be a topological order, from the point of view of the use-def chains.</p>
<h1>Example starting from node 8 </h1>
<p>1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order: {1, 2, 5, 3, 4, 6} </p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00082">getBackwardSliceImpl()</a>, and <a class="el" href="SliceAnalysis_8cpp_source.html#l00136">getSlice()</a>.</p>

</div>
</div>
<a id="a68dfa6bfaaa9a03dcbfdaeee28dc80ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dfa6bfaaa9a03dcbfdaeee28dc80ab">&#9670;&nbsp;</a></span>getComputationSliceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getComputationSliceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSourceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSinkOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'. </p>
<p>If 'isBackwardSlice' is true, a backwards slice is computed in which the slice bounds of loop nest surrounding 'depSourceAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSinkAccess' at 'loopDepth'. If 'isBackwardSlice' is false, a forward slice is computed in which the slice bounds of loop nest surrounding 'depSinkAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSourceAccess' at 'loopDepth'. The slice loop bounds and associated operands are returned in 'sliceState'. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00757">757</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00214">mlir::Operation::getContext()</a>, <a class="el" href="AffineStructures_8h_source.html#l00454">mlir::FlatAffineConstraints::getIdValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00461">mlir::FlatAffineConstraints::getIdValues()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">getLoopIVs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00436">mlir::FlatAffineConstraints::getNumDimAndSymbolIds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01043">getSequentialLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00074">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00752">kSliceFusionBarrierAttrName</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00070">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">mlir::FlatAffineConstraints::projectOut()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00072">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00087">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a61eaf936f054b483e983fa6be1cb27f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eaf936f054b483e983fa6be1cb27f3">&#9670;&nbsp;</a></span>getComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::getComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the total cost of the loop nest rooted at 'forOp' using 'stats'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00554">554</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00454">getComputeCostHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a8cdcd2c284243df5d427fcdfe4edde75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdcd2c284243df5d427fcdfe4edde75">&#9670;&nbsp;</a></span>getConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt; mlir::getConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop if it's a constant, None otherwise. </p>
<p>This uses affine expression analysis and is able to determine constant trip count in non-trivial cases.</p>
<p>This method uses affine expression analysis (in turn using getTripCount) and is able to determine constant trip count in non-trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">87</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00033">buildTripCountMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00305">affineForOpBodySkew()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00517">buildSliceTripCountMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00822">constructTiledIndexSetHyperRect()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00164">findMatchingStartFinishInsts()</a>, <a class="el" href="LoopUnroll_8cpp_source.html#l00077">gatherInnermostLoops()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00402">getLoopNestStats()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01031">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01274">loopUnrollJamUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01044">loopUnrollUpToFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="a35604920235d89beb11e9bc64ae45a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35604920235d89beb11e9bc64ae45a33">&#9670;&nbsp;</a></span>getDenseDimName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getDenseDimName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00142">142</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00143">isDenseDim()</a>.</p>

</div>
</div>
<a id="a7a72abd84dcc66c8c890fc6c5e0d24f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a72abd84dcc66c8c890fc6c5e0d24f8">&#9670;&nbsp;</a></span>getDependenceComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getDependenceComponents </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>depCompsVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth]. </p>
<p>Gathers dependence components for dependences between all ops in loop nest rooted at 'forOp' at loop depths in range [1, maxLoopDepth].</p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00952">952</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00859">checkMemrefAccessDependence()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00120">hasDependence()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8h_source.html#l00120">hasDependence()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01462">isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01568">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a4a4509af87b284808008015597b3f96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4509af87b284808008015597b3f96a">&#9670;&nbsp;</a></span>getDilationsAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getDilationsAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of dilations. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00072">72</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a8c6eb5b9274486d9ed3f4dff655d4cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6eb5b9274486d9ed3f4dff655d4cbd">&#9670;&nbsp;</a></span>getDocAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getDocAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the <a class="el" href="classmlir_1_1StringAttr.html">StringAttr</a> which encodes an optional documentation string of the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00059">59</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a82686ceb29eb0f78b59e29021f1b2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82686ceb29eb0f78b59e29021f1b2cdd">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00021">21</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00234">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01453">buildNamedStructuredOpRegionAndAttributesImpl()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02710">extractShape()</a>, <a class="el" href="Traits_8cpp_source.html#l00106">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00027">getElementTypeOrSelf()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00024">mlir::edsc::makeGenericLinalgOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01930">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="Ops_8cpp_source.html#l02688">verify()</a>, <a class="el" href="Operation_8cpp_source.html#l00904">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00928">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, and <a class="el" href="Operation_8cpp_source.html#l00890">mlir::OpTrait::impl::verifySameOperandsElementType()</a>.</p>

</div>
</div>
<a id="a252aee27751e05d584d0b1a8e793ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252aee27751e05d584d0b1a8e793ecf0">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00031">31</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00021">getElementTypeOrSelf()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00035">mlir::Attribute::getType()</a>.</p>

</div>
</div>
<a id="ae81d443c449b61825fb2c2ec6aa90d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d443c449b61825fb2c2ec6aa90d35">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00027">27</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00021">getElementTypeOrSelf()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ad1ccc3f1298ad67bd387a804aa82fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ccc3f1298ad67bd387a804aa82fa65">&#9670;&nbsp;</a></span>getEnclosingAffineForAndIfOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getEnclosingAffineForAndIfOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> or <code>affine.if</code> operation to the innermost one. </p>
<p>Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> operation to the innermost one.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00050">50</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00231">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00119">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="a7746ab6b30038f20f1508c7821fa3052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7746ab6b30038f20f1508c7821fa3052">&#9670;&nbsp;</a></span>getFlattenedAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>flattenedExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions. </p>
<p>Returns failure if 'expr' could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local identifiers to existing dimensional and symbolic identifiers. See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00103">103</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00116">getFlattenedAffineExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00481">mlir::FlatAffineConstraints::setIdValues()</a>.</p>

</div>
</div>
<a id="ae54668e284d7e980f404164472f75c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54668e284d7e980f404164472f75c62">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>localVarCst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns failure if any expression in the map could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local identifiers to existing dimensional and / symbolic identifiers. See documentation for AffineExprFlattener on how mod's and div's are flattened. For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns failure if 'expr' was unable to be flattened (i.e., semi-affine expressions not handled yet). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00116">116</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00070">getFlattenedAffineExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00209">mlir::FlatAffineConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00464">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00536">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00176">mlir::FlatAffineConstraints::FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00103">getFlattenedAffineExpr()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00481">mlir::FlatAffineConstraints::setIdValues()</a>.</p>

</div>
</div>
<a id="a50f3de480d05c0d64fcc14fd29efde14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f3de480d05c0d64fcc14fd29efde14">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00128">128</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00070">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00209">mlir::FlatAffineConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a46bbb7497276c5ea7e8ed4ad1315bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">&#9670;&nbsp;</a></span>getFlattenedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt; mlir::getFlattenedTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TupleType.html">TupleType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types within a nested Tuple. </p>
<p>A helper for the class method that handles storage concerns, which is tricky to do in tablegen. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00035">35</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00711">mlir::TupleType::getFlattenedTypes()</a>.</p>

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01903">1903</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00090">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00275">mlir::BlockArgument::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00037">mlir::Block::getParent()</a>, and <a class="el" href="IR_2Region_8cpp_source.html#l00051">mlir::Region::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00634">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00552">addMissingLoopIVBounds()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00517">buildSliceTripCountMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00621">mlir::FlatAffineConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">fuseLoops()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00082">getBackwardSliceImpl()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00603">getCommonBlock()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00581">getNumCommonLoops()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01897">isForInductionVar()</a>, and <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00070">isOpLoopInvariant()</a>.</p>

</div>
</div>
<a id="ab3c9138cd38e82a78b5895b0e606d5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c9138cd38e82a78b5895b0e606d5d6">&#9670;&nbsp;</a></span>getForwardSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>forwardSlice</code> with the computed forward slice (i.e. </p>
<p>all the transitive uses of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at uses transitively, an operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForInst or the scope within an IfInst.</p>
<p>The implementation traverses the use chains in postorder traversal for efficiency reasons: if an operation is already in <code>forwardSlice</code>, no need to traverse its uses again. Since use-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>forwardSlice</code> is filled with a postorder list of uses (i.e. a reverse topological order). To get a proper topological order, we just just reverse the order in <code>forwardSlice</code> before returning.</p>
<h1>Example starting from node 0 </h1>
<pre class="fragment">          0
</pre><p> ___________|___________ 1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order:</p><ol type="1">
<li>after getting back to the root getForwardSlice, <code>forwardSlice</code> may contain: {9, 7, 8, 5, 1, 2, 6, 3, 4}</li>
<li>reversing the result of 1. gives: {4, 3, 6, 2, 1, 5, 8, 7, 9} </li>
</ol>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00030">getForwardSliceImpl()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00136">getSlice()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01803">hoistOpsBetween()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00084">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01097">vectorizeNonTerminals()</a>.</p>

</div>
</div>
<a id="afde43535284e6667536f8ed8c7906063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde43535284e6667536f8ed8c7906063">&#9670;&nbsp;</a></span>getFusionComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getFusionComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>srcStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>dstStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>computeCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. Returns true on success, failure otherwise (e.g. non-constant trip counts).</p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00565">565</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00517">buildSliceTripCountMap()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00454">getComputeCostHelper()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">getLoopIVs()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00503">getSliceIterationCount()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00074">mlir::ComputationSliceState::insertPoint</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a348eec2f2303d75aeea3e11b11a9b864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348eec2f2303d75aeea3e11b11a9b864">&#9670;&nbsp;</a></span>getIndexingMapsAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getIndexingMapsAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the AffineArrayAttr which encodes the relationship between a structured op iterators' and its operands. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00051">51</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00056">mlir::linalg::interchange()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00177">print()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00371">verify()</a>.</p>

</div>
</div>
<a id="a66f085159bef0da235a45ebac17172a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f085159bef0da235a45ebac17172a9">&#9670;&nbsp;</a></span>getIndexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getIndexSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order. </p>
<p>Bounds of the loop are used to add appropriate inequalities. Constraints from the index sets of AffineIfOp are also added. Any symbols founds in the bound operands are added as symbols in the system. Returns failure for the yet unimplemented cases. <code>ops</code> accepts both AffineForOp and AffineIfOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00088">88</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00656">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00709">mlir::FlatAffineConstraints::addAffineIfOpDomain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01913">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00209">mlir::FlatAffineConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00582">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03011">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02929">createSeparationCondition()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00119">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="abde4236d0e9455a3983834b085f73224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde4236d0e9455a3983834b085f73224">&#9670;&nbsp;</a></span>getInnermostCommonLoopDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getInnermostCommonLoopDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>surroundingLoops</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the innermost common loop depth for the set of operations in 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00568">568</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">getLoopIVs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00194">getMaxLoopDepth()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a4243a75480867bb61c05aa5879d2a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4243a75480867bb61c05aa5879d2a32f">&#9670;&nbsp;</a></span>getInvariantAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getInvariantAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type IndexType, returns the set of <code>indices</code> that are independent of <code>iv</code>. </p>
<p>Prerequisites (inherited from <code>isAccessInvariant</code> above):</p><ol type="1">
<li><code>iv</code> and <code>indices</code> of the proper type;</li>
<li>at most one affine.apply is reachable from each index in <code>indices</code>;</li>
</ol>
<p>Emits a note if it encounters a chain of affine.apply and conservatively those cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00187">187</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00163">isAccessIndexInvariant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00176">makePermutationMap()</a>.</p>

</div>
</div>
<a id="aeb614cbb4a83d4b3ec1ef9b5c7cade43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb614cbb4a83d4b3ec1ef9b5c7cade43">&#9670;&nbsp;</a></span>getIteratorTypesAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getIteratorTypesAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the type of a structured op's iterators. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00055">55</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00056">mlir::linalg::interchange()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00177">print()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00371">verify()</a>.</p>

</div>
</div>
<a id="a8c3272c7e5d627a525a70f55fb93fb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3272c7e5d627a525a70f55fb93fb57">&#9670;&nbsp;</a></span>getLargestDivisorOfTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::getLargestDivisorOfTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the greatest known integral divisor of the trip count. </p>
<p>Affine expression analysis is used (indirectly through getTripCount), and this method is thus able to determine non-trivial divisors. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00113">113</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00033">buildTripCountMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00822">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a39d25e27ccff1d123995abe189add986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d25e27ccff1d123995abe189add986">&#9670;&nbsp;</a></span>getLibraryCallAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getLibraryCallAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the external library function that implements the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00063">63</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a991e7b35354627941316244640aa4392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e7b35354627941316244640aa4392">&#9670;&nbsp;</a></span>getLoopIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getLoopIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">33</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00231">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02139">findHighestBlockForPlacement()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00757">getComputationSliceState()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02599">getFullMemRefAsRegion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00565">getFusionComputeCost()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00568">getInnermostCommonLoopDepth()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00092">getLastDependentOpInRange()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00974">getNumCommonSurroundingLoops()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00855">insertBackwardComputationSlice()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00072">isMemRefDereferencingOp()</a>, and <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00070">isOpLoopInvariant()</a>.</p>

</div>
</div>
<a id="a1b8c56a4421761c1f8658aa16c292463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8c56a4421761c1f8658aa16c292463">&#9670;&nbsp;</a></span>getLoopNestStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getLoopNestStats </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect loop nest statistics (eg. </p>
<p>loop trip count and operation count) in 'stats' for loop nest rooted at 'forOp'. Returns true on success, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00402">402</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00046">mlir::WalkResult::advance()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, <a class="el" href="Visitors_8h_source.html#l00045">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00105">mlir::LoopNestStats::loopMap</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00107">mlir::LoopNestStats::opCountMap</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00109">mlir::LoopNestStats::tripCountMap</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a1670cd81ab396ba425cd0063d516b9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1670cd81ab396ba425cd0063d516b9a9">&#9670;&nbsp;</a></span>getMemoryFootprintBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; mlir::getMemoryFootprintBytes </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l01033">1033</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00989">getMemoryFootprintBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00087">createAffineDataCopyGenerationPass()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a5bd0c019a961c60a1fd09225b7dcd3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd0c019a961c60a1fd09225b7dcd3be">&#9670;&nbsp;</a></span>getMemRefSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt; mlir::getMemRefSizeInBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>memRefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of memref data in bytes if it's statically shaped, None otherwise. </p>
<p>If the element of the memref has vector type, takes into account size of the vector as well. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00433">433</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01896">mlir::FlatAffineConstraints::addConstantUpperBound()</a>, <a class="el" href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">boundCheckLoadOrStoreOp()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00301">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00389">getMemRefEltSizeInBytes()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>.</p>

</div>
</div>
<a id="ac2db02976864d1e32f9f500d9d719d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2db02976864d1e32f9f500d9d719d5a">&#9670;&nbsp;</a></span>getNestingDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNestingDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation. </p>
<p>Returns the nesting depth of this statement, i.e., the number of loops surrounding this statement.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00944">944</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00231">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02651">affineDataCopyGenerate()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00081">createMemRefDataFlowOptPass()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00989">getMemoryFootprintBytes()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l01053">isLoopParallel()</a>.</p>

</div>
</div>
<a id="af9ce1eb0663c1448ebc1bbeccc2b6bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce1eb0663c1448ebc1bbeccc2b6bcf">&#9670;&nbsp;</a></span>getNumCommonSurroundingLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNumCommonSurroundingLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of surrounding loops common to both A and B. </p>
<p>Returns the number of surrounding loops common to 'loopsA' and 'loopsB', where each lists loops from outer-most to inner-most in loop nest.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00974">974</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">getLoopIVs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00263">canFuseLoops()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00081">createMemRefDataFlowOptPass()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00194">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="a729f6e1552c6df7db231ce20f67947b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729f6e1552c6df7db231ce20f67947b2">&#9670;&nbsp;</a></span>getNumIterators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNumIterators </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator of a certain type. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00107">107</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00114">mlir::Attribute::cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00099">getAllIteratorTypeNames()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00116">getNumIterators()</a>.</p>

</div>
</div>
<a id="a6d068f0cba2b5a92fe603c4118664b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d068f0cba2b5a92fe603c4118664b61">&#9670;&nbsp;</a></span>getNumIterators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::getNumIterators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>iteratorTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00116">116</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00099">getAllIteratorTypeNames()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00107">getNumIterators()</a>.</p>

</div>
</div>
<a id="a45e134959101de052e7dbfd12610b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e134959101de052e7dbfd12610b5d6">&#9670;&nbsp;</a></span>getOrCreateRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 8 &gt; mlir::getOrCreateRanges </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of <a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> (i.e. </p>
<p>offset, size, stride). Each <a class="el" href="structmlir_1_1Range.html" title="Auxiliary range data structure to unpack the offset, size and stride operands into a list of triples...">Range</a> entry contains either the dynamic value or a <a class="el" href="classmlir_1_1ConstantIndexOp.html" title="This is a refinement of the &quot;constant&quot; op for the case where it is returning an integer value of Inde...">ConstantIndexOp</a> constructed with <code>b</code> at location <code>loc</code>. </p>

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l03316">3316</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Ops_8cpp_source.html#l00254">extractFromI64ArrayAttr()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00311">mlir::ShapedType::isDynamic()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00314">mlir::ShapedType::isDynamicStrideOrOffset()</a>, <a class="el" href="Ops_8cpp_source.html#l00176">m_ConstantIndex()</a>, <a class="el" href="Matchers_8h_source.html#l00244">matchPattern()</a>, <a class="el" href="PatternMatch_8h_source.html#l00458">mlir::PatternRewriter::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="aef47d572d82ccbf6419876301669cd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef47d572d82ccbf6419876301669cd6a">&#9670;&nbsp;</a></span>getPaddingAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getPaddingAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of paddings. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00075">75</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a3cf9bb42bc7ec9e1668e6e121d0b69b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9bb42bc7ec9e1668e6e121d0b69b0">&#9670;&nbsp;</a></span>getParallelIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getParallelIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has parallel semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00078">78</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00656">collectFusableLoops()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00437">fuseWithReshapeByExpansion()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00099">getAllIteratorTypeNames()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00454">getDimMap()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00018">isElementwiseMappableOpOnRankedTensors()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00410">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">isParallelIterator()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00060">mlir::linalg::isParallelIteratorType()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00157">replaceBlockArgForUnitDimLoops&lt; IndexedGenericOp &gt;()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00126">toString()</a>.</p>

</div>
</div>
<a id="a7cd53e808ea039aa9738dfab187468f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd53e808ea039aa9738dfab187468f8">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01006">1006</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00987">getPerfectlyNestedLoopsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01019">getTileableBands()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01568">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a002c6258ba17b3a08e25cde241861c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c6258ba17b3a08e25cde241861c3f">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; scf::ForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01011">1011</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00987">getPerfectlyNestedLoopsImpl()</a>.</p>

</div>
</div>
<a id="ab221e5dde89586cce7d959284af9f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab221e5dde89586cce7d959284af9f05e">&#9670;&nbsp;</a></span>getProjectedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::getProjectedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>projectedDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00458">458</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">mlir::AffineMap::compose()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00177">mlir::AffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8h_source.html#l00237">mlir::MutableAffineMap::getContext()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00532">pruneReductionDimsFromMap()</a>.</p>

</div>
</div>
<a id="a1522039bca148f6d365612eb404e0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1522039bca148f6d365612eb404e0994">&#9670;&nbsp;</a></span>getReachableAffineApplyOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getReachableAffineApplyOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in <code>affineApplyOps</code>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an AffineApplyOp. </p>
<p>Returns the sequence of AffineApplyOp Operations operation in 'affineApplyOps', which are reachable via a search starting from 'operands', and ending at operands which are not defined by AffineApplyOps.</p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00038">38</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00328">createAffineComputationSlice()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00164">findMatchingStartFinishInsts()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00163">isAccessIndexInvariant()</a>.</p>

</div>
</div>
<a id="a52c9b6dd4f7515747a96c7de3ed325f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c9b6dd4f7515747a96c7de3ed325f9">&#9670;&nbsp;</a></span>getReductionIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getReductionIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has reduction semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00085">85</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00099">getAllIteratorTypeNames()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00454">getDimMap()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00086">isReductionIterator()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00067">mlir::linalg::isReductionIteratorType()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00126">toString()</a>.</p>

</div>
</div>
<a id="a4052bdb6ce4bde76e5de054805848162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4052bdb6ce4bde76e5de054805848162">&#9670;&nbsp;</a></span>getSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *&#160;</td>
          <td class="paramname"><em>sequentialLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l01043">1043</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l01053">isLoopParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00757">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="ae7beb62292ad20dc8c447387c371f9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7beb62292ad20dc8c447387c371f9a2">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>backwardFilter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>forwardFilter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively computes backward slices and forward slices until a fixed point is reached. </p>
<p>Returns an <code>llvm::SetVector&lt;<a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> *&gt;</code> which <b>includes</b> the original operation.</p>
<p>This allows building a slice (i.e. multi-root DAG where everything that is reachable from an <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in forward and backward direction is contained in the slice). This is the abstraction we need to materialize all the operations for supervectorization without worrying about orderings and <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> replacements.</p>
<h1>Example starting from any node </h1>
<p>1 2 3 4 |_______| |______| | | | | | 5 6___| |___|_____________| | | | | 7 8 | |_______________| | | | 9 10</p>
<p>Return the whole DAG in some topological order.</p>
<p>The implementation works by just filling up a worklist with iterative alternate calls to <code>getBackwardSlice</code> and <code>getForwardSlice</code>.</p>
<p>The following section describes some additional implementation considerations for a potentially more efficient implementation but they are just an intuition without proof, we still use a worklist for now.</p>
<h1>Additional implementation considerations </h1>
<p>Consider the defs-op-uses hourglass. </p><hr/>
<p> \ / defs (in some topological order) \/ op /\ / \ uses (in some topological order) /____\</p>
<p>We want to iteratively apply <code>getSlice</code> to construct the whole list of <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> that are reachable by (use|def)+ from op. We want the resulting slice in topological order. Ideally we would like the ordering to be maintained in-place to avoid copying <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> at each step. Keeping this ordering by construction seems very unclear, so we list invariants in the hope of seeing whether useful properties pop up.</p>
<p>In the following: we use |= for set inclusion; we use &lt;&lt; for set topological ordering (i.e. each pair is ordered).</p>
<h1>Assumption: </h1>
<p>We wish to maintain the following property by a recursive argument: """ defs &lt;&lt; {op} &lt;&lt;uses are in topological order. """ The property clearly holds for 0 and 1-sized uses and defs;</p>
<p>Invariants:</p><ol type="1">
<li>defs and uses are in topological order internally, by construction;</li>
<li>for any {x} |= defs, defs(x) |= defs; because all go through op</li>
<li>for any {x} |= uses, defs |= defs(x); because all go through op</li>
<li>for any {x} |= defs, uses |= uses(x); because all go through op</li>
<li>for any {x} |= uses, uses(x) |= uses; because all go through op</li>
</ol>
<p>Intuitively, we should be able to recurse like: preorder(defs) - op - postorder(uses) and keep things ordered but this is still hand-wavy and not worth the trouble for now: punt to a simple worklist-based solution. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00136">136</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a40741d257063d17fe7e8da3ebea443a3">getBackwardSlice()</a>, <a class="el" href="namespacemlir.html#ab3c9138cd38e82a78b5895b0e606d5d6">getForwardSlice()</a>, and <a class="el" href="namespacemlir.html#a67f5deb263dc3ca56a8c5ae015cba4af">topologicalSort()</a>.</p>

</div>
</div>
<a id="a0b10f5ff1eb61aeea833de1628d38a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b10f5ff1eb61aeea833de1628d38a9e">&#9670;&nbsp;</a></span>getSparseAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getSparseAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the <a class="el" href="classmlir_1_1ArrayAttr.html" title="Array attributes are lists of other attributes. ">ArrayAttr</a> of StrArrayAttr that encodes sparsity. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00066">66</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a6f435eb0710ccc0f46b59f9dd25e7d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f435eb0710ccc0f46b59f9dd25e7d20">&#9670;&nbsp;</a></span>getSparseDimName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getSparseDimName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode a dense or sparse dimension. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00137">137</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00138">isSparseDim()</a>.</p>

</div>
</div>
<a id="a506c478f802ab2f874c0b34a18bc091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506c478f802ab2f874c0b34a18bc091b">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the strides of the MemRef if the layout map is in strided form. </p>
<p>MemRefs with layout maps in strided form include:</p><ol type="1">
<li>empty or identity layout map, in which case the stride information is the canonical form computed from sizes;</li>
<li>single affine map layout of the form <code>K + k0 * d0 + ... kn * dn</code>, where K and ki's are constants or symbols.</li>
</ol>
<p>A stride specification is a list of integer values that are either static or dynamic (encoded with getDynamicStrideOrOffset()). Strides encode the distance in the number of elements between successive entries along a particular dimension. For example, <code>memref&lt;42x16xf32, (64 * d0 + d1)&gt;</code> specifies a view into a non-contiguous memory region of <code>42</code> by <code>16</code> <code>f32</code> elements in which the distance between two consecutive elements along the outer dimension is <code>1</code> and the distance between two consecutive elements along the inner dimension is <code>64</code>.</p>
<p>Returns whether a simple strided form can be extracted from the composition of the layout map.</p>
<p>The convention is that the strides for dimensions d0, .. dn appear in order to make indexing intuitive into the result. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00671">671</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00258">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00252">mlir::ShapedType::kDynamicStrideOrOffset</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l03472">canFoldIntoConsumerOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00727">computeReshapeCollapsedType()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00085">convertRangeType()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00527">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00163">getBase()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02179">getCastCompatibleMemRefType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00604">mlir::spirv::getElementPtr()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01048">mlir::ConvertToLLVMPattern::getStridedElementPtr()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="Ops_8cpp_source.html#l03969">inferTransposeResultType()</a>, <a class="el" href="Ops_8cpp_source.html#l03184">isRankReducedType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00838">isStrided()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00534">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00977">verify()</a>.</p>

</div>
</div>
<a id="ab9d8af8a280cbdd7ffbf4629ee82ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d8af8a280cbdd7ffbf4629ee82ccc4">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In practice, a strided memref must be internally non-aliasing. Test against 0 as a proxy. TODO: static cases can have more advanced checks. TODO: dynamic cases would require a way to compare symbolic expressions and would probably need an affine set context propagated everywhere. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">602</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00558">extractStrides()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineConstantExpr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00514">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00021">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00225">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00512">mlir::MemRefType::getShape()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00179">mlir::AffineMap::isIdentity()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01072">simplifyAffineExpr()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>.</p>

</div>
</div>
<a id="aed3fe0298dee33ee77887d8ad11cc67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3fe0298dee33ee77887d8ad11cc67c">&#9670;&nbsp;</a></span>getStridesAttrName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getStridesAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations. ">Attribute</a> name for the StrArrayAttr which encodes the value of strides. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00069">69</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00846">foldExtractFromShapeCast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01619">inferStridedSliceOpResultType()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l01305">verify()</a>.</p>

</div>
</div>
<a id="a6d63cba95be019caae3db4abae2937da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d63cba95be019caae3db4abae2937da">&#9670;&nbsp;</a></span>getTileableBands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getTileableBands </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 6 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>bands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify valid and profitable bands of loops to tile. </p>
<p>This is currently just a temporary placeholder to test the mechanics of tiled code generation. Returns all maximal outermost perfect loop nests to tile. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01019">1019</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01006">getPerfectlyNestedLoops()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="a9f633b099c2b8b42235818ba7bb70bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f633b099c2b8b42235818ba7bb70bc0">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00058">58</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00231">mlir::OpOperand::get()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00031">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00065">getUsedValuesDefinedAbove()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00080">outlineIfOp()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00138">outlineKernelFuncImpl()</a>, and <a class="el" href="KernelOutlining_8cpp_source.html#l00106">sinkOperationsIntoLaunchOp()</a>.</p>

</div>
</div>
<a id="afdabf77e050b8d684e39d2e5c760a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdabf77e050b8d684e39d2e5c760a2f0">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00065">65</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00058">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="ae14df83d38352e9dfc0eb0e01fc86230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14df83d38352e9dfc0eb0e01fc86230">&#9670;&nbsp;</a></span>getWindowIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringRef mlir::getWindowIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has window semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00092">92</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00099">getAllIteratorTypeNames()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00093">isWindowIterator()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">mlir::linalg::isWindowIteratorType()</a>.</p>

</div>
</div>
<a id="aa3d787cb93ed1e8219f6cf6b2572d30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d787cb93ed1e8219f6cf6b2572d30f">&#9670;&nbsp;</a></span>greedilyMapParallelSCFToGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::greedilyMapParallelSCFToGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the parallel loops found in the given function to workgroups. </p>
<p>The first loop encountered will be mapped to the global workgroup and the second loop encountered to the local workgroup. Within each mapping, the first three dimensions are mapped to x/y/z hardware ids and all following dimensions are mapped to sequential loops. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00148">148</a> of file <a class="el" href="ParallelLoopMapper_8cpp_source.html">ParallelLoopMapper.cpp</a>.</p>

<p class="reference">References <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00122">mapParallelOp()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00250">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ParallelLoopMapper_8h_source.html#l00045">mlir::gpu::getProcessor()</a>.</p>

</div>
</div>
<a id="a0139b17eb17bf529e630ec15f2051472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0139b17eb17bf529e630ec15f2051472">&#9670;&nbsp;</a></span>hasDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element. ">DependenceResult</a> corresponds to a dependence result. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00120">120</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00952">getDependenceComponents()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00105">mlir::DependenceResult::HasDependence</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00437">checkTilingLegalityImpl()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00081">createMemRefDataFlowOptPass()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00952">getDependenceComponents()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00194">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="abb322b17530b4289c3e3ec1f4ad2ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb322b17530b4289c3e3ec1f4ad2ecce">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types. ">TypeRange</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00079">79</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="aafb3bcc9d23b2cfd1367b84f5b00b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb3bcc9d23b2cfd1367b84f5b00b7c1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable hashing <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00096">96</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

</div>
</div>
<a id="a060d54dd4c592884f7bb771cbff354e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060d54dd4c592884f7bb771cbff354e7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00097">97</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00063">mlir::Identifier::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a655bb0e17a21ea2c35194f7c822c9ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655bb0e17a21ea2c35194f7c822c9ca5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IntegerSet_8h_source.html#l00114">114</a> of file <a class="el" href="IntegerSet_8h_source.html">IntegerSet.h</a>.</p>

</div>
</div>
<a id="a68bae84b1d7cdba11b048d9af3478a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae84b1d7cdba11b048d9af3478a07">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00119">119</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00090">mlir::Attribute::impl</a>.</p>

</div>
</div>
<a id="ad9141d8b586a68549d2ecaccbce99a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141d8b586a68549d2ecaccbce99a69">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00219">219</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00177">mlir::AffineExpr::expr</a>.</p>

<p class="reference">Referenced by <a class="el" href="Location_8h_source.html#l00077">mlir::Location::dump()</a>, <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l01530">mlir::MutableDictionaryAttr::empty()</a>, <a class="el" href="TypeID_8h_source.html#l00078">mlir::TypeID::getFromOpaquePointer()</a>, <a class="el" href="Value_8h_source.html#l00216">mlir::Value::getFromOpaquePointer()</a>, <a class="el" href="BuiltinOps_8h_source.html#l00058">llvm::DenseMapInfo&lt; mlir::FuncOp &gt;::getHashValue()</a>, <a class="el" href="Identifier_8h_source.html#l00115">llvm::DenseMapInfo&lt; mlir::Identifier &gt;::getHashValue()</a>, <a class="el" href="IntegerSet_8h_source.html#l00131">llvm::DenseMapInfo&lt; mlir::IntegerSet &gt;::getHashValue()</a>, <a class="el" href="TypeRange_8h_source.html#l00147">llvm::DenseMapInfo&lt; mlir::TypeRange &gt;::getHashValue()</a>, <a class="el" href="TypeID_8h_source.html#l00151">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l00185">llvm::DenseMapInfo&lt; mlir::Attribute &gt;::getHashValue()</a>, <a class="el" href="Types_8h_source.html#l00259">llvm::DenseMapInfo&lt; mlir::Type &gt;::getHashValue()</a>, <a class="el" href="Location_8h_source.html#l00282">llvm::DenseMapInfo&lt; mlir::Location &gt;::getHashValue()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00309">llvm::DenseMapInfo&lt; mlir::AffineExpr &gt;::getHashValue()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00351">llvm::DenseMapInfo&lt; mlir::AffineMap &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00363">llvm::DenseMapInfo&lt; mlir::Value &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00395">llvm::DenseMapInfo&lt; mlir::BlockArgument &gt;::getHashValue()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00610">llvm::DenseMapInfo&lt; mlir::LLVM::LLVMType &gt;::getHashValue()</a>, <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l01538">hash_value()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00095">mlir::AffineMap::operator!=()</a>, and <a class="el" href="IntegerSet_8h_source.html#l00075">mlir::IntegerSet::operator==()</a>.</p>

</div>
</div>
<a id="a032c893ca9a2fff3b16e5a7cb6d413cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c893ca9a2fff3b16e5a7cb6d413cd">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00219">219</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a31eede9183d3fdae566e18d94a5ef51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eede9183d3fdae566e18d94a5ef51b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00220">220</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00172">mlir::Type::impl</a>.</p>

</div>
</div>
<a id="aa6261878bc5197cfcc003e5b3fa735ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261878bc5197cfcc003e5b3fa735ea">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00264">264</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00219">hash_value()</a>, and <a class="el" href="Location_8h_source.html#l00089">mlir::Location::impl</a>.</p>

</div>
</div>
<a id="ab710b1f6f21f3f35197575b609aae4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710b1f6f21f3f35197575b609aae4b4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00346">346</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00237">mlir::Value::ownerAndKind</a>.</p>

</div>
</div>
<a id="ad93109842c1b05424c5052d9bd9a4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93109842c1b05424c5052d9bd9a4394">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00377">377</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00352">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a248f26067c1829c0eb6c4c440865811d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248f26067c1829c0eb6c4c440865811d">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1MutableDictionaryAttr.html">MutableDictionaryAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l01538">1538</a> of file <a class="el" href="IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00219">hash_value()</a>.</p>

</div>
</div>
<a id="a57bafa91f432ad40bb6246fbcbd555fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bafa91f432ad40bb6246fbcbd555fe">&#9670;&nbsp;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>folded</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's. </p>
<p>Returns success if any hoisting happened; folded` is set to true if the op was folded or erased. This hoisting could lead to significant code expansion in some cases. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">180</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00359">applyOpPatternsAndFold()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00044">getOutermostInvariantForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01897">isForInductionVar()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00225">isTopLevelValue()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a51ea257fc0167ade93ef4d07cdd98af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ea257fc0167ade93ef4d07cdd98af8">&#9670;&nbsp;</a></span>initializeLLVMPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::initializeLLVMPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> passes that can be used when running MLIR code using <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a>. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8cpp_source.html#l00047">47</a> of file <a class="el" href="OptUtils_8cpp_source.html">OptUtils.cpp</a>.</p>

</div>
</div>
<a id="afa82b2f82348c0eacc76f1c4a862a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa82b2f82348c0eacc76f1c4a862a796">&#9670;&nbsp;</a></span>inlineCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOpInterface&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation. </p>
<p>This function returns failure if inlining is not possible, success otherwise. On failure, no changes are made to the module. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'call' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00297">297</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::empty()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::front()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="DialectInterface_8h_source.html#l00163">mlir::DialectInterfaceCollection&lt; InterfaceType &gt;::getInterfaceFor()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00278">mlir::BlockArgument::getType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00140">inlineRegion()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00060">mlir::InlinerInterface::isLegalToInline()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00271">materializeConversion()</a>, <a class="el" href="Value_8cpp_source.html#l00124">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="Operation_8cpp_source.html#l00245">mlir::Operation::replaceUsesOfWith()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00328">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00432">inlineCallsInSCC()</a>, and <a class="el" href="InliningUtils_8h_source.html#l00156">mlir::InlinerInterface::processInlinedBlocks()</a>.</p>

</div>
</div>
<a id="a20bc0a33de855f1c9a1a0ccfd8665e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bc0a33de855f1c9a1a0ccfd8665e78">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>regionResultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a region, 'src', into another. </p>
<p>This function returns failure if it is not possible to inline this function. If the function returned failure, then no changes to the module have been made.</p>
<p>The provided 'inlinePoint' must be within a region, and corresponds to the location where the 'src' region should be inlined. 'mapping' contains any remapped operands that are used within the region, and <em>must</em> include remappings for the entry arguments to the region. 'resultsToReplace' corresponds to any results that should be replaced by terminators within the inlined region. 'regionResultTypes' specifies the expected return types of the terminators in the region. 'inlineLoc' is an optional <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> that, if provided, will be used to update the inlined operations' location information. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'inlinePoint' or spliced directly. </p>
<p>Handle the terminators for each of the new blocks. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00140">140</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00152">mlir::Block::addArgument()</a>, <a class="el" href="IR_2Region_8h_source.html#l00051">mlir::Region::begin()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::begin()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00073">mlir::Region::cloneInto()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00049">mlir::BlockAndValueMapping::contains()</a>, <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00052">mlir::Region::end()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::end()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="Block_8cpp_source.html#l00065">mlir::Block::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::front()</a>, <a class="el" href="Operation_8h_source.html#l00096">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="Block_8h_source.html#l00122">mlir::Block::getOperations()</a>, <a class="el" href="Block_8cpp_source.html#l00037">mlir::Block::getParent()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00094">mlir::InlinerInterface::handleTerminator()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00060">mlir::InlinerInterface::isLegalToInline()</a>, <a class="el" href="InliningUtils_8h_source.html#l00156">mlir::InlinerInterface::processInlinedBlocks()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00030">remapInlinedLocations()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00045">remapInlinedOperands()</a>, <a class="el" href="Block_8cpp_source.html#l00275">mlir::Block::splitBlock()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InliningUtils_8cpp_source.html#l00297">inlineCall()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00238">inlineRegion()</a>, and <a class="el" href="InliningUtils_8h_source.html#l00156">mlir::InlinerInterface::processInlinedBlocks()</a>.</p>

</div>
</div>
<a id="a6e080a2ba31bfcc4dd18b9a480051c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e080a2ba31bfcc4dd18b9a480051c74">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00238">238</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00056">mlir::Region::empty()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::front()</a>, <a class="el" href="Value_8h_source.html#l00278">mlir::BlockArgument::getType()</a>, <a class="el" href="OperationSupport_8h_source.html#l00847">mlir::ValueRange::getTypes()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00140">inlineRegion()</a>, and <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>.</p>

</div>
</div>
<a id="aa8c76f66345aba4e6cabb250bf7699c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c76f66345aba4e6cabb250bf7699c1">&#9670;&nbsp;</a></span>insertBackwardComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::insertBackwardComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>dstOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'. </p>
<p>Creates a computation slice of the loop nest surrounding 'srcOpInst', updates the slice loop bounds with any non-null bound maps specified in 'sliceState', and inserts this slice into the loop nest surrounding 'dstOpInst' at loop depth 'dstLoopDepth'.</p>
<p>Returns the top-level loop of the computation slice on success, returns nullptr otherwise.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00855">855</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00286">mlir::Operation::emitError()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00510">findInstPosition()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00527">getInstAtPosition()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">getLoopIVs()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00070">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::lbs</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00072">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8h_source.html#l00087">mlir::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="a9ff3713bf5c6762b9f8239a980ded85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff3713bf5c6762b9f8239a980ded85a">&#9670;&nbsp;</a></span>interchangeLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::interchangeLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs loop interchange on 'forOpA' and 'forOpB'. </p>
<p>Performs loop interchange on 'forOpA' and 'forOpB', where 'forOpB' is nested within 'forOpA' as the only non-terminator operation in its block.</p>
<p>Requires that 'forOpA' and 'forOpB' are part of a perfectly nested sequence of loops.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01404">1404</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="a52b322818d83a2256d4e4391acbf78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b322818d83a2256d4e4391acbf78a2">&#9670;&nbsp;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected. </p>
<p>Returns an empty map if the input map is empty. Returns null map (not empty map) if <code>map</code> is not invertible (i.e. <code>map</code> does not contain a subset that is a permutation of full domain rank).</p>
<p>Prerequisites:</p><ol type="1">
<li><code>map</code> has no symbols.</li>
</ol>
<p>Example 1:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d1, d0, d2, d1, d2, d1, d0)</div><div class="line">                  0       2   3</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div></div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d0 + d1, d0, d2, d1, d2, d1, d0)</div><div class="line">                  0            2   3</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00417">417</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00258">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00177">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00216">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00191">mlir::AffineMap::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00675">foldExtractOpFromTranspose()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00179">fuseTensorOpsImpl()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00437">fuseWithReshapeByExpansion()</a>, <a class="el" href="Fusion_8cpp_source.html#l00548">getConsumerLoopToProducerLoopMap()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00237">mlir::MutableAffineMap::getContext()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00056">getIndexingMapOfProducerOperandsInFusedOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00056">mlir::linalg::interchange()</a>, <a class="el" href="Interchange_8cpp_source.html#l00035">mlir::linalg::interchangeGenericLinalgOpPrecondition()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00157">replaceBlockArgForUnitDimLoops&lt; IndexedGenericOp &gt;()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00247">replaceUnitExtents()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00318">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a0dfea8ee2dd0eba944b0cd299591ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfea8ee2dd0eba944b0cd299591ccf9">&#9670;&nbsp;</a></span>isColumnMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isColumnMajorMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00038">38</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00291">bindDims()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00028">mlir::AffineMapAttr::get()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00038">mlir::ArrayAttr::get()</a>.</p>

</div>
</div>
<a id="a828a1d51b7a77220cf332221beaa3411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828a1d51b7a77220cf332221beaa3411">&#9670;&nbsp;</a></span>isDenseDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isDenseDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00143">143</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00142">getDenseDimName()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00421">mlir::StringAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00280">findSparseAnnotations()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00360">getGenericEffectsImpl()</a>.</p>

</div>
</div>
<a id="a0dd391dd6c617912e9c5e70caa5fb513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd391dd6c617912e9c5e70caa5fb513">&#9670;&nbsp;</a></span>isForInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isForInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is the induction variable of a AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01897">1897</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01903">getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00634">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00552">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00216">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00581">getNumCommonLoops()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">hoistAffineIfOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00302">initDependenceConstraints()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00163">isAccessIndexInvariant()</a>.</p>

</div>
</div>
<a id="a0d9c4fc904589c35cd742b2f96393ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9c4fc904589c35cd742b2f96393ee2">&#9670;&nbsp;</a></span>isLoopParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLoopParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if `forOp' is a parallel loop. </p>
<p>Returns true if 'forOp' is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l01053">1053</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00046">mlir::WalkResult::advance()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00859">checkMemrefAccessDependence()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00944">getNestingDepth()</a>, <a class="el" href="Visitors_8h_source.html#l00045">mlir::WalkResult::interrupt()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00106">mlir::DependenceResult::NoDependence</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01306">createSuperVectorizePass()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l01043">getSequentialLoops()</a>.</p>

</div>
</div>
<a id="a4bd6b581b08699ce79d3e9f820c1ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6b581b08699ce79d3e9f820c1ade9">&#9670;&nbsp;</a></span>isOpaqueTypeWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpaqueTypeWithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dialect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>typeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified type is an opaque type with the specified dialect and typeData. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00043">43</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00234">mlir::Type::dyn_cast()</a>.</p>

</div>
</div>
<a id="a8583719d6a8f0699c36ac4c4b53057f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8583719d6a8f0699c36ac4c4b53057f2">&#9670;&nbsp;</a></span>isOpTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation is unused, and has no side effects on memory that prevent erasing. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00032">32</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00582">mlir::Operation::use_empty()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00093">wouldOpBeTriviallyDead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00240">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="FrozenRewritePatternList_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>.</p>

</div>
</div>
<a id="ac65079eba69cbd732d43736887a06bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65079eba69cbd732d43736887a06bff">&#9670;&nbsp;</a></span>isOpwiseShiftValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpwiseShiftValid </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts. </p>
<p>Checks whether SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.</p>
<p>This method checks if a 'def' and all its uses have the same shift factor. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00361">361</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00199">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00305">affineForOpBodySkew()</a>, and <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00164">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="a588d7472008e08ed39dd3e9d83c42775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d7472008e08ed39dd3e9d83c42775">&#9670;&nbsp;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">79</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00078">getParallelIteratorTypeName()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00421">mlir::StringAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01685">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01798">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00532">pruneReductionDimsFromMap()</a>.</p>

</div>
</div>
<a id="abdac991f1476b0af97ff0620a3ddfdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdac991f1476b0af97ff0620a3ddfdb3">&#9670;&nbsp;</a></span>isPerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVM_ATTRIBUTE_UNUSED mlir::isPerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>loops</code> is a perfectly nested loop nest, where loops appear in it from outermost to innermost. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01476">1476</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00512">performPreTilingChecks()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01498">permuteLoops()</a>.</p>

</div>
</div>
<a id="aea20c60a2e61974ab7981f341e562c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea20c60a2e61974ab7981f341e562c4c">&#9670;&nbsp;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00086">86</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00085">getReductionIteratorTypeName()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00421">mlir::StringAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01685">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01798">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae53f9bcf99efe125a11237ad6b64642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f9bcf99efe125a11237ad6b64642c">&#9670;&nbsp;</a></span>isRowMajorMatmul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isRowMajorMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00027">27</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00291">bindDims()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00028">mlir::AffineMapAttr::get()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00038">mlir::ArrayAttr::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a9dce5ff52e3d7a08fcef27fce25edba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dce5ff52e3d7a08fcef27fce25edba5">&#9670;&nbsp;</a></span>isSparseDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isSparseDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00138">138</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00137">getSparseDimName()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00421">mlir::StringAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sparsification_8cpp_source.html#l00280">findSparseAnnotations()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00360">getGenericEffectsImpl()</a>.</p>

</div>
</div>
<a id="ad0c26bcf64137533f38f2cda9abd75af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c26bcf64137533f38f2cda9abd75af">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isStrided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the layout for <code>t</code> is compatible with strided semantics. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00838">838</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00671">getStridesAndOffset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00040">succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>, <a class="el" href="Dialect_2StandardOps_2EDSC_2Builders_8cpp_source.html#l00017">getMemRefSizes()</a>, <a class="el" href="Ops_8h_source.html#l00252">mlir::DmaStartOp::getNumElementsPerStride()</a>, <a class="el" href="Ops_8h_source.html#l00246">mlir::DmaStartOp::getStride()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01130">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01521">mlir::DmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01108">mlir::AffineDmaStartOp::print()</a>, <a class="el" href="Ops_8cpp_source.html#l01501">mlir::DmaStartOp::print()</a>, <a class="el" href="Ops_8cpp_source.html#l01581">mlir::DmaStartOp::verify()</a>, and <a class="el" href="Ops_8cpp_source.html#l03284">verify()</a>.</p>

</div>
</div>
<a id="aa36b5164871eaf1d6423cd0a2eb4e4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36b5164871eaf1d6423cd0a2eb4e4fd">&#9670;&nbsp;</a></span>isTopLevelValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code> or is a region argument for such an op. </p>
<p>A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code>.</p>
<p>A value of index type defined at the top level is always a valid symbol for all its uses.</p>
<p>If the value is defined in an unlinked region, conservatively assume it is not top-level. A value of index type defined at the top level is always a valid symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00225">225</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00090">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00231">mlir::Operation::getParentOp()</a>, and <a class="el" href="Operation_8h_source.html#l00501">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00634">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">hoistAffineIfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00320">isDimOpValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00276">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00351">isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00045">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a9e447f320894cc02bbaeff66dd31ccee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e447f320894cc02bbaeff66dd31ccee">&#9670;&nbsp;</a></span>isValidDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <code>AffineScope</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00256">256</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00096">mlir::Value::cast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00241">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, and <a class="el" href="Types_8cpp_source.html#l00030">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00087">categorizeValueByAffineType()</a>, <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00420">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00084">remainsLegalAfterInline()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00510">verify()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00458">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="a31448f2e1927a26095c872bbfb4683a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31448f2e1927a26095c872bbfb4683a1">&#9670;&nbsp;</a></span>isValidDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <code>region</code>, i.e., for all its uses in <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00276">276</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00096">mlir::Value::cast()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Types_8cpp_source.html#l00030">mlir::Type::isIndex()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00225">isTopLevelValue()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00351">isValidSymbol()</a>.</p>

</div>
</div>
<a id="aacd689ef70c61ee029b443673c78a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd689ef70c61ee029b443673c78a04e">&#9670;&nbsp;</a></span>isValidLoopInterchangePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidLoopInterchangePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>loopPermMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange). </p>
<p>Checks if the loop interchange permutation 'loopPermMap' of the perfectly nested sequence of loops in 'loops' would violate dependences.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01462">1462</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01427">checkLoopInterchangeDependences()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00952">getDependenceComponents()</a>.</p>

</div>
</div>
<a id="a6f320624f15a47e5732c1142f99dc144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f320624f15a47e5732c1142f99dc144">&#9670;&nbsp;</a></span>isValidSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <code>AffineScope</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00351">351</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00241">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Types_8cpp_source.html#l00030">mlir::Type::isIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00225">isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00216">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00861">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00087">categorizeValueByAffineType()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00302">initDependenceConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00307">isMemRefSizeValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00420">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00276">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00377">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00632">promoteComposedSymbolsAsDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00084">remainsLegalAfterInline()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00510">verify()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00458">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="a6bfdb250aa76df12c7f6a5727e7ceb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfdb250aa76df12c7f6a5727e7ceb4b">&#9670;&nbsp;</a></span>isValidSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <code>region</code>, i.e., for all its uses in <code>region</code>. </p>
<p>A value can be used as a symbol for <code>region</code> iff it meets onf of the the following conditions: *) It is a constant.</p>
<p>*) It is the result of an affine apply operation with symbol arguments. *) It is a result of the dim op on a memref whose corresponding size is a valid symbol. *) It is defined at the top level of 'region' or is its argument. *) It dominates <code>region</code>'s parent op. If <code>region</code> is null, conservatively assume the symbol definition scope does not exist and only accept the values that would be symbols regardless of the surrounding region structure, i.e. the first three cases above. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00377">377</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00051">mlir::Region::getParentOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00227">mlir::Operation::getParentRegion()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00320">isDimOpValidSymbol()</a>, <a class="el" href="Types_8cpp_source.html#l00030">mlir::Type::isIndex()</a>, <a class="el" href="Operation_8h_source.html#l00486">mlir::Operation::isKnownIsolatedFromAbove()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00225">isTopLevelValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00351">isValidSymbol()</a>, <a class="el" href="Matchers_8h_source.html#l00210">m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00244">matchPattern()</a>.</p>

</div>
</div>
<a id="a76b6d2ee408bfc5909eb81779da3e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b6d2ee408bfc5909eb81779da3e0f1">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable; i.e. </p>
<p>:</p><ol type="1">
<li>no conditionals are nested under the loop;</li>
<li>all nested load/stores are to scalar MemRefs. TODO: relax the no-conditionals restriction </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00351">351</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00278">isVectorizableLoopBodyWithOpCond()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l00832">isVectorizableLoopPtrFactory()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01170">vectorizeLoopNest()</a>.</p>

</div>
</div>
<a id="ae13f2a9f8242f345de0163689c30304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f2a9f8242f345de0163689c30304e">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>memRefDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are are either: </p>
<ol type="1">
<li>invariant along the loop induction variable created by 'loop';</li>
<li>varying along at most one memory dimension. If such a unique dimension is found, it is written into <code>memRefDim</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00328">328</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00218">isContiguousAccess()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00278">isVectorizableLoopBodyWithOpCond()</a>.</p>

</div>
</div>
<a id="af846930bde2aa600816a8dadd31bbddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af846930bde2aa600816a8dadd31bbddc">&#9670;&nbsp;</a></span>isWindowIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isWindowIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00093">93</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00111">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00421">mlir::StringAttr::getValue()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00092">getWindowIteratorTypeName()</a>.</p>

</div>
</div>
<a id="afc028da483ef6cf650439fa8b30eae79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc028da483ef6cf650439fa8b30eae79">&#9670;&nbsp;</a></span>JitRunnerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::JitRunnerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1JitRunnerConfig.html">JitRunnerConfig</a>&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for all CPU runners. </p>
<p>Expects the common argc/argv arguments for standard C++ main functions. </p>

<p class="definition">Definition at line <a class="el" href="JitRunner_8cpp_source.html#l00246">246</a> of file <a class="el" href="JitRunner_8cpp_source.html">JitRunner.cpp</a>.</p>

<p class="reference">References <a class="el" href="JitRunner_8cpp_source.html#l00185">compileAndExecuteVoidFunction()</a>, <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00134">getCommandLineOptLevel()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00419">mlir::MLIRContext::getDialectRegistry()</a>, <a class="el" href="JitRunner_8h_source.html#l00047">mlir::JitRunnerConfig::llvmModuleBuilder</a>, <a class="el" href="JitRunner_8cpp_source.html#l00129">make_string_error()</a>, <a class="el" href="OptUtils_8h_source.html#l00050">makeLLVMPassesTransformer</a>, <a class="el" href="JitRunner_8h_source.html#l00041">mlir::JitRunnerConfig::mlirTransformer</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>, <a class="el" href="JitRunner_8cpp_source.html#l00114">parseMLIRInput()</a>, <a class="el" href="InitAllDialects_8h_source.html#l00048">registerAllDialects()</a>, and <a class="el" href="JitRunner_8h_source.html#l00051">mlir::JitRunnerConfig::runtimesymbolMap</a>.</p>

</div>
</div>
<a id="a5f7a5c72c1e0e867f3aac796b26ec2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7a5c72c1e0e867f3aac796b26ec2aa">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::lcm </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the least common multiple of 'a' and 'b'. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00049">49</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00827">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02459">getNewNumDimsSymbols()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00030">mlir::Simplex::Simplex()</a>.</p>

</div>
</div>
<a id="ac84b6a6dfd9d9eb78ca02c17cabbebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b6a6dfd9d9eb78ca02c17cabbebed">&#9670;&nbsp;</a></span>linearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the linearized index of 'offsets' w.r.t. 'basis'. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00073">73</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00846">foldExtractFromShapeCast()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00264">getUnrolledVectorLinearIndex()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>.</p>

</div>
</div>
<a id="af912da94236cff04e9076f6e052676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912da94236cff04e9076f6e052676b1">&#9670;&nbsp;</a></span>LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LLVM_ENABLE_BITMASK_ENUMS_IN_NAMESPACE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Bitmask enums for <a class="el" href="structmlir_1_1OperationEquivalence.html#a292ebf6a0885a07fd4c94f9750587dfe">OperationEquivalence::Flags</a>. </p>

</div>
</div>
<a id="a69f3012781c34e4c455dcb89956d7983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f3012781c34e4c455dcb89956d7983">&#9670;&nbsp;</a></span>loopUnrollByFactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step.</p>
<p>Returns success if the loop is successfully unrolled. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01099">1099</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateUnrolledLoop()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00113">getLargestDivisorOfTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnroll_8cpp_source.html#l00077">gatherInnermostLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01031">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01044">loopUnrollUpToFactor()</a>.</p>

</div>
</div>
<a id="a9c90b04191f7811b8be8e69264e9f26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c90b04191f7811b8be8e69264e9f26e">&#9670;&nbsp;</a></span>loopUnrollByFactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls 'forOp' by 'unrollFactor', returns success if the loop is unrolled. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01163">1163</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00125">ceilDivPositive()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01057">generateUnrolledLoop()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Ops_8h_source.html#l00105">mlir::ConstantIndexOp::getValue()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="ab9a5f6331a28a90f85a2d8498fd6f801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a5f6331a28a90f85a2d8498fd6f801">&#9670;&nbsp;</a></span>loopUnrollFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollFull </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation completely if the trip count is known to be constant. </p>
<p>Unrolls this loop completely.</p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01031">1031</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00305">affineForOpBodySkew()</a>, and <a class="el" href="LoopUnroll_8cpp_source.html#l00077">gatherInnermostLoops()</a>.</p>

</div>
</div>
<a id="ad67a63b71c0fe3f345278eab205e10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a63b71c0fe3f345278eab205e10a3">&#9670;&nbsp;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor. </p>
<p>Returns success if the loop is successfully unroll-jammed. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01284">1284</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00128">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::end()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00297">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00113">getLargestDivisorOfTripCount()</a>, <a class="el" href="Operation_8h_source.html#l00413">mlir::Operation::getRegions()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, <a class="el" href="Value_8cpp_source.html#l00166">mlir::Value::use_empty()</a>, and <a class="el" href="Visitors_8cpp_source.html#l00016">mlir::detail::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00066">createLoopUnrollAndJamPass()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01274">loopUnrollJamUpToFactor()</a>.</p>

</div>
</div>
<a id="ac918847951e0d20706fe61380e119adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918847951e0d20706fe61380e119adb">&#9670;&nbsp;</a></span>loopUnrollJamUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollJamUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01274">1274</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a4a6ed1cfcc6232ad7dae507d67db6462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6ed1cfcc6232ad7dae507d67db6462">&#9670;&nbsp;</a></span>loopUnrollUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this loop by the specified unroll factor or its trip count, whichever is lower. </p>
<p>Unrolls this loop by the specified factor or by the trip count (if constant) whichever is lower.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01044">1044</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnroll_8cpp_source.html#l00077">gatherInnermostLoops()</a>.</p>

</div>
</div>
<a id="afdf4bbbb9eb7a9678bd98d122b837cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf4bbbb9eb7a9678bd98d122b837cbd">&#9670;&nbsp;</a></span>lowerAffineLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineLowerBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the lower bound of the given affine loop using standard arithmetic operations. </p>
<p>Emit instructions that correspond to the affine map in the lower bound applied to the respective operands, and compute the maximum value across the results.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00292">292</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00069">mlir::Location::cast()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00237">mlir::edsc::op::eq()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00181">mlir::PatternRewriter::eraseBlock()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00175">mlir::PatternRewriter::eraseOp()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00213">expandAffineExpr()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00221">expandAffineMap()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="AffineOps_8h_source.html#l00147">mlir::AffineDmaStartOp::getDstMap()</a>, <a class="el" href="Ops_8h_source.html#l00173">mlir::DmaStartOp::getDstMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00126">mlir::AffineDmaStartOp::getDstMemRefOperandIndex()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00312">mlir::IntegerAttr::getInt()</a>, <a class="el" href="OpDefinition_8h_source.html#l00149">mlir::OpState::getLoc()</a>, <a class="el" href="Ops_8h_source.html#l00193">mlir::DmaStartOp::getNumElements()</a>, <a class="el" href="Ops_8h_source.html#l00297">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="Ops_8h_source.html#l00252">mlir::DmaStartOp::getNumElementsPerStride()</a>, <a class="el" href="AffineOps_8h_source.html#l00108">mlir::AffineDmaStartOp::getSrcMap()</a>, <a class="el" href="Ops_8h_source.html#l00161">mlir::DmaStartOp::getSrcMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00096">mlir::AffineDmaStartOp::getSrcMemRefOperandIndex()</a>, <a class="el" href="Ops_8h_source.html#l00246">mlir::DmaStartOp::getStride()</a>, <a class="el" href="AffineOps_8h_source.html#l00296">mlir::AffineDmaWaitOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00176">mlir::AffineDmaStartOp::getTagMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00290">mlir::AffineDmaWaitOp::getTagMap()</a>, <a class="el" href="Ops_8h_source.html#l00198">mlir::DmaStartOp::getTagMemRef()</a>, <a class="el" href="Ops_8h_source.html#l00283">mlir::DmaWaitOp::getTagMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00160">mlir::AffineDmaStartOp::getTagMemRefOperandIndex()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00255">mlir::PatternRewriter::inlineRegionBefore()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00265">lowerAffineMapMax()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00274">lowerAffineMapMin()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00284">lowerAffineUpperBound()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00161">mlir::PatternRewriter::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00458">mlir::PatternRewriter::replaceOpWithNewOp()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00267">mlir::edsc::op::sge()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00072">getOrEmitLowerBound()</a>.</p>

</div>
</div>
<a id="a2d924b9762c352e82e8fe0fb1e222288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d924b9762c352e82e8fe0fb1e222288">&#9670;&nbsp;</a></span>lowerAffineUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineUpperBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the upper bound of the given affine loop using standard arithmetic operations. </p>
<p>Emit instructions that correspond to the affine map in the upper bound applied to the respective operands, and compute the minimum value across the results.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00284">284</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineToStandard_8cpp_source.html#l00274">lowerAffineMapMin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToGPU_8cpp_source.html#l00078">getOrEmitUpperBound()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="ad402a86ee4c9000c6fa1fceaddab560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad402a86ee4c9000c6fa1fceaddab560b">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">detail::constant_op_matcher</a> mlir::m_Constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant foldable operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00210">210</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00904">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="Ops_8cpp_source.html#l00569">collapseBranch()</a>, <a class="el" href="NumberOfExecutions_8cpp_source.html#l00032">computeRegionBlockNumberOfExecutions()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01675">foldLoopBounds()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00157">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00377">isValidSymbol()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00051">materializeConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00126">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00045">remainsLegalAfterInline()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00400">mlir::OpBuilder::tryFold()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00977">verify()</a>.</p>

</div>
</div>
<a id="a10b6da5781fbe1b019fcb64dcd6921dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6da5781fbe1b019fcb64dcd6921dd">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt;AttrT&gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a value from a constant foldable operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00217">217</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00037">mlir::detail::attr_value_binder&lt; AttrClass, ValueType, typename &gt;::bind_value</a>.</p>

</div>
</div>
<a id="a930dbe1d176d999aec049a4581838974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930dbe1d176d999aec049a4581838974">&#9670;&nbsp;</a></span>m_ConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a> mlir::m_ConstantInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerAttr.html#a338d41710c0bd77a572190b8d552c754">IntegerAttr::ValueType</a> *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00260">260</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00290">verify()</a>.</p>

</div>
</div>
<a id="a585ff769cbd1cef62ceda90ccd14062a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585ff769cbd1cef62ceda90ccd14062a">&#9670;&nbsp;</a></span>m_NonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__not__value__matcher.html">detail::constant_int_not_value_matcher</a>&lt;0&gt; mlir::m_NonZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00238">238</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>.</p>

</div>
</div>
<a id="ac4cc1a8746679396a5dfe6e4c7ef8396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cc1a8746679396a5dfe6e4c7ef8396">&#9670;&nbsp;</a></span>m_One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt;1&gt; mlir::m_One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer one. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00222">222</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00048">extractCompositeElement()</a>, and <a class="el" href="Ops_8cpp_source.html#l00290">verify()</a>.</p>

</div>
</div>
<a id="ac2418532386147bec2ca5aadf5414406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2418532386147bec2ca5aadf5414406">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt;OpClass&gt; mlir::m_Op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches the given OpClass. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00227">227</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7ecde76b07cd295bae0d6ef10d1c45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecde76b07cd295bae0d6ef10d1c45d8">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename... Matchers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">Matchers...&#160;</td>
          <td class="paramname"><em>matchers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00265">265</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aacf138ddcdd4a81f4047f2d6bbee3482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf138ddcdd4a81f4047f2d6bbee3482">&#9670;&nbsp;</a></span>m_Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt;0&gt; mlir::m_Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00232">232</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00048">extractCompositeElement()</a>, <a class="el" href="Ops_8cpp_source.html#l00223">getTensorTypeFromMemRefType()</a>, and <a class="el" href="Ops_8cpp_source.html#l00290">verify()</a>.</p>

</div>
</div>
<a id="ac603376cc0dac0b2bd27c2dcde3c2e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac603376cc0dac0b2bd27c2dcde3c2e14">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given MemRef <code>sizes</code> that are either static or dynamic, returns the canonical "contiguous" strides <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>. </p>
<p>Strides are multiplicative and once a dynamic dimension is encountered, all canonical strides become dynamic and need to be encoded with a different symbol. For canonical strides expressions, the offset is always 0 and and fastest varying stride is always <code>1</code>.</p>
<p>Examples:</p><ul>
<li>memref&lt;3x4x5xf32&gt; has canonical stride expression <code>20*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x?x5xf32&gt; has canonical stride expression <code>s0*exprs[0] + 5*exprs[1] + exprs[2]</code>.</li>
<li>memref&lt;3x4x?xf32&gt; has canonical stride expression <code>s1*exprs[0] + s0*exprs[1] + exprs[2]</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">788</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00463">getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00159">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01072">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00764">canonicalizeStridedLayout()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00286">linearizeCollapsedDims()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00828">makeCanonicalStridedLayoutExpr()</a>.</p>

</div>
</div>
<a id="ad25cd8672ecb721d7a4f0ecd22bac6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25cd8672ecb721d7a4f0ecd22bac6e8">&#9670;&nbsp;</a></span>makeCanonicalStridedLayoutExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::makeCanonicalStridedLayoutExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of makeCanonicalStrudedLayoutExpr for the common case where <code>exprs</code> is {d0, d1, .., d_(sizes.size()-1)}. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00828">828</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">getAffineDimExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">makeCanonicalStridedLayoutExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>.</p>

</div>
</div>
<a id="a1186a736d12d4f188f6eac3c02a11b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1186a736d12d4f188f6eac3c02a11b0f">&#9670;&nbsp;</a></span>makeComposedAffineApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a composed AffineApplyOp by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands. </p>
<p>The operands of the resulting AffineApplyOp do not change the length of AffineApplyOp chains. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00848">848</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00828">composeAffineMapAndOperands()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00103">createBinaryIndexHandle()</a>, and <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>.</p>

</div>
</div>
<a id="a923fafcbdcfdcb3b735fab2ab293a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">&#9670;&nbsp;</a></span>makeStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::makeStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of strides (in which <a class="el" href="classmlir_1_1MemRefType.html#acbdbbe58df49b67438c3c03507d0c8b3">MemRefType::getDynamicStrideOrOffset()</a> represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> which represents the linearized strided layout map. </p>
<p>Dimensions correspond to the offset followed by the strides in order. Symbols are inserted for each dynamic dimension in order. A stride cannot take value <code>0</code>.</p>
<h1>Examples: </h1>
<ol type="1">
<li>For offset: 0 strides: ?, ?, 1 return (i, j, k)[M, N]-&gt;(M * i + N * j + k)</li>
<li>For offset: 3 strides: 32, ?, 16 return (i, j, k)[M]-&gt;(3 + 32 * i + M * j + 16 * k)</li>
<li>For offset: ? strides: ?, ?, ? return (i, j, k)[off, M, N, P]-&gt;(off + M * i + N * j + P * k) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00723">723</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00463">getAffineSymbolExpr()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00543">mlir::MemRefType::getDynamicStrideOrOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00674">mlir::TensorType::classof()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00727">computeReshapeCollapsedType()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00822">eraseStridedLayout()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02179">getCastCompatibleMemRefType()</a>, <a class="el" href="Ops_8cpp_source.html#l03969">inferTransposeResultType()</a>, <a class="el" href="Ops_8cpp_source.html#l03184">isRankReducedType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">mlir::detail::Parser::parseMemRefType()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00977">verify()</a>.</p>

</div>
</div>
<a id="abdc308b7190d3d087a4c12adb23b387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc308b7190d3d087a4c12adb23b387b">&#9670;&nbsp;</a></span>mapLoopToProcessorIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::mapLoopToProcessorIds </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>processorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>numProcessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>. </p>
<p>This is achieved by embedding the SSA values corresponding to <code>processorIds</code> and <code>numProcessors</code> into the bounds and step of the <code>forOp</code>. No check is performed on the legality of the rewrite, it is the caller's responsibility to ensure legality.</p>
<p>Requires that <code>processorIds</code> and <code>numProcessors</code> have the same size and that for each idx, <code>processorIds</code>[idx] takes, at runtime, all values between 0 and <code>numProcessors</code>[idx] - 1. This corresponds to traditional use cases for:</p><ol type="1">
<li>GPU (threadIdx, get_local_id(), ...)</li>
<li>MPI (MPI_Comm_rank)</li>
<li>OpenMP (omp_get_thread_num)</li>
</ol>
<p>Example: Assuming a 2-d grid with processorIds = [blockIdx.x, threadIdx.x] and numProcessors = [gridDim.x, blockDim.x], the loop:</p>
<div class="fragment"><div class="line">scf.for %i = %lb to %ub step %step {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>is rewritten into a version resembling the following pseudo-IR:</p>
<div class="fragment"><div class="line">scf.for %i = %lb + %step * (threadIdx.x + blockIdx.x * blockDim.x)</div><div class="line">   to %ub step %gridDim.x * blockDim.x * %step {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02111">2111</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00126">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, and <a class="el" href="MemoryPromotion_8cpp_source.html#l00043">insertCopyLoops()</a>.</p>

</div>
</div>
<a id="a0190228b09e7b51a4bc1e013c01d404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190228b09e7b51a4bc1e013c01d404c">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00244">244</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>, <a class="el" href="Ops_8cpp_source.html#l03544">canFoldIntoConsumerOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00904">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="Ops_8cpp_source.html#l00569">collapseBranch()</a>, <a class="el" href="NumberOfExecutions_8cpp_source.html#l00032">computeRegionBlockNumberOfExecutions()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00048">extractCompositeElement()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01675">foldLoopBounds()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00157">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Ops_8cpp_source.html#l03316">getOrCreateRanges()</a>, <a class="el" href="Ops_8cpp_source.html#l00223">getTensorTypeFromMemRefType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00377">isValidSymbol()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00051">materializeConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00126">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00045">remainsLegalAfterInline()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00400">mlir::OpBuilder::tryFold()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00977">verify()</a>.</p>

</div>
</div>
<a id="a1b97d57dcd6c08b495fbd3ef22aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00253">253</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00042">mlir::detail::attr_value_binder&lt; AttrClass, ValueType, typename &gt;::match()</a>.</p>

</div>
</div>
<a id="a25555f0964e7a67b96b5fc89f1bee1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25555f0964e7a67b96b5fc89f1bee1fc">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a> &amp;&#160;</td>
          <td class="paramname"><em>passPipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitInputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyDiagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyPasses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowUnregisteredDialects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preloadDialectsInContext</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the core processing behind <code>mlir-opt</code>: </p>
<ul>
<li>outputStream is the stream where the resulting IR is printed.</li>
<li>buffer is the in-memory file to parser and process.</li>
<li>passPipeline is the specification of the pipeline that will be applied.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>splitInputFile will look for a "-----" marker in the input file, and load each chunk in an individual ModuleOp processed separately.</li>
<li>verifyDiagnostics enables a verification mode where comments starting with "expected-(error|note|remark|warning)" are parsed in the input and matched against emitted diagnostics.</li>
<li>verifyPasses enables the IR verifier in-between each pass in the pipeline.</li>
<li>allowUnregisteredDialects allows to parse and create operation without registering the <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations, types and attributes, as well as behavior associated with the...">Dialect</a> in the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>.</li>
<li>preloadDialectsInContext will trigger the upfront loading of all dialects from the global registry in the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. This option is deprecated and will be removed soon. </li>
</ul>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00086">processBuffer()</a>.</p>

</div>
</div>
<a id="a5529e09fff7b03bab31277d063302a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5529e09fff7b03bab31277d063302a7b">&#9670;&nbsp;</a></span>MlirOptMain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preloadDialectsInContext</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation for tools like <code>mlir-opt</code>. </p>
<ul>
<li>toolName is used for the header displayed by <code>--help</code>.</li>
<li>registry should contain all the dialects that can be parsed in the source.</li>
<li>preloadDialectsInContext will trigger the upfront loading of all dialects from the global registry in the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. This option is deprecated and will be removed soon. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MlirOptMain_8cpp_source.html#l00151">151</a> of file <a class="el" href="MlirOptMain_8cpp_source.html">MlirOptMain.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="namespacemlir.html#a25555f0964e7a67b96b5fc89f1bee1fc">MlirOptMain()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00105">registerAsmPrinterCLOptions()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00079">registerMLIRContextCLOptions()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">registerPassManagerCLOptions()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="aea8a2eef6c85897dbfc1b6437251776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8a2eef6c85897dbfc1b6437251776b">&#9670;&nbsp;</a></span>mlirTranslateMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::mlirTranslateMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>toolName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate to/from an MLIR module from/to an external representation (e.g. </p>
<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR, SPIRV binary, ...). This is the entry point for the implementation of tools like <code>mlir-translate</code>. The translation to perform is parsed from the command line. The <code>toolName</code> argument is used for the header displayed by <code>--help</code>. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00129">129</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile()</a>, <a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00533">mlir::MLIRContext::printOpOnDiagnostic()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00086">processBuffer()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00105">registerAsmPrinterCLOptions()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00079">registerMLIRContextCLOptions()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00021">splitAndProcessBuffer()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00693">mlir::SourceMgrDiagnosticVerifierHandler::verify()</a>.</p>

</div>
</div>
<a id="afca33cad5b0cd935568ea0fc0a439abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca33cad5b0cd935568ea0fc0a439abd">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::mod </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns MLIR's mod operation on constants. </p>
<p>MLIR's mod operation yields the remainder of the Euclidean division of 'lhs' by 'rhs', and is therefore not C's % operator. The RHS is always expected to be positive, and the result is always non-negative. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00043">43</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00765">simplifyMod()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>.</p>

</div>
</div>
<a id="ae4bde3ce64d571a88aefe7dc3bbca323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bde3ce64d571a88aefe7dc3bbca323">&#9670;&nbsp;</a></span>moveLoopInvariantCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::moveLoopInvariantCode </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>looplike</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move loop invariant code out of <code>looplike</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00078">78</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00042">canBeHoisted()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00084">mlir::linalg::hoistRedundantVectorTransfers()</a>.</p>

</div>
</div>
<a id="ac0a1fe4deb3e0ecb3d92460a0ffec72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a1fe4deb3e0ecb3d92460a0ffec72e">&#9670;&nbsp;</a></span>normalizeAffineParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::normalizeAffineParallel </td>
          <td>(</td>
          <td class="paramtype">AffineParallelOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a affine.parallel op so that lower bounds are 0 and steps are 1. </p>
<p>As currently implemented, this transformation cannot fail and will return early if the op is already in a normalized form. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00023">23</a> of file <a class="el" href="AffineLoopNormalize_8cpp_source.html">AffineLoopNormalize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00211">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00752">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00305">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00069">mlir::AffineValueMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00070">mlir::AffineValueMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00097">mlir::AffineValueMap::getOperands()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00067">mlir::AffineValueMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00225">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, and <a class="el" href="Value_8cpp_source.html#l00131">mlir::Value::replaceAllUsesExcept()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00088">normalizeAffineFor()</a>.</p>

</div>
</div>
<a id="ae4f3ffb3d4089a4a62f1b01ef2cc80df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f3ffb3d4089a4a62f1b01ef2cc80df">&#9670;&nbsp;</a></span>normalizeMemRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::normalizeMemRef </td>
          <td>(</td>
          <td class="paramtype">AllocOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the memref defined by this alloc op to have an identity layout map and updates all its indexing uses. </p>
<p>Returns failure if any of its uses escape (while leaving the IR in a valid state). </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00396">396</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00514">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="Value_8h_source.html#l00199">mlir::Value::getUsers()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00437">normalizeMemRefType()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00220">replaceAllMemRefUsesWith()</a>, <a class="el" href="Value_8cpp_source.html#l00124">mlir::Value::replaceAllUsesWith()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>.</p>

</div>
</div>
<a id="ad139b18a8e4fed885a7c7040ac8c9a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139b18a8e4fed885a7c7040ac8c9a42">&#9670;&nbsp;</a></span>normalizeMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::normalizeMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbolicOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the old memref type map layout and computes the new memref type to have a new shape and a layout map, where the old layout map has been normalized to an identity layout map. </p>
<p>It returns the old memref in case no normalization was needed or a failure occurs while transforming the old map layout to an identity layout map. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00437">437</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01886">mlir::FlatAffineConstraints::addConstantLowerBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01896">mlir::FlatAffineConstraints::addConstantUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00536">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00514">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02307">mlir::FlatAffineConstraints::getConstantUpperBound()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00320">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="AffineStructures_8h_source.html#l00433">mlir::FlatAffineConstraints::getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00437">mlir::FlatAffineConstraints::getNumLocalIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00512">mlir::MemRefType::getShape()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">mlir::FlatAffineConstraints::projectOut()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00483">mlir::MemRefType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00396">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">&#9670;&nbsp;</a></span>openInputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::MemoryBuffer&gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>, and <a class="el" href="JitRunner_8cpp_source.html#l00114">parseMLIRInput()</a>.</p>

</div>
</div>
<a id="a4c8c9750d9c8efdbcc7542f3b1564d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">&#9670;&nbsp;</a></span>openOutputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::ToolOutputFile&gt; mlir::openOutputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for writing. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00084">mlir::SimpleObjectCache::dumpToObjectFile()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00065">generateLocationsFromIR()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00515">hasSizeMismatch()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, and <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>.</p>

</div>
</div>
<a id="aeec87c8e176e5200de6eabb890d01e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec87c8e176e5200de6eabb890d01e96">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00089">89</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

</div>
</div>
<a id="ab8d0033d79ef89bd4fe840819c0e5b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d0033d79ef89bd4fe840819c0e5b44">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00094">94</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

</div>
</div>
<a id="aa956129148e25edd5ec7b39b592c6082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956129148e25edd5ec7b39b592c6082">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00094">94</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

</div>
</div>
<a id="aee326f96469cd288efb48265e173295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee326f96469cd288efb48265e173295e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00269">269</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00109">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a5da97a01717dee2c2fa7ad551de8dc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da97a01717dee2c2fa7ad551de8dc46">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00372">372</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00352">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a6187ff461b8d15899e73b828f3bcecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6187ff461b8d15899e73b828f3bcecf0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00071">71</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::den</a>, <a class="el" href="Fraction_8h_source.html#l00028">mlir::Fraction::Fraction()</a>, and <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::num</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8h_source.html#l00082">mlir::ArrayAttr::empty()</a>, <a class="el" href="EDSC_2Builders_8h_source.html#l00217">mlir::edsc::TemplatedIndexedValue&lt; Load, Store &gt;::getElementalTypeAs()</a>, and <a class="el" href="IR_2AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="a9137193b56dc5134c3092273b13e3f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137193b56dc5134c3092273b13e3f47">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00224">224</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a014242a015c4e9c9aa58c829af2fc4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014242a015c4e9c9aa58c829af2fc4d4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00057">57</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>, <a class="el" href="SDBM_8h_source.html#l00037">mlir::IntInfty::infty</a>, and <a class="el" href="SDBM_8h_source.html#l00051">mlir::IntInfty::isFinite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EDSC_2Builders_8h_source.html#l00217">mlir::edsc::TemplatedIndexedValue&lt; Load, Store &gt;::getElementalTypeAs()</a>, and <a class="el" href="IR_2AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="a8f6f52bcd2d859c9d9a6f393ad5481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00223">223</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="ac541b3ac36d683b618cd7dede91a50b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac541b3ac36d683b618cd7dede91a50b5">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00059">59</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::den</a>, <a class="el" href="Fraction_8h_source.html#l00028">mlir::Fraction::Fraction()</a>, and <a class="el" href="Fraction_8h_source.html#l00040">mlir::Fraction::num</a>.</p>

<p class="reference">Referenced by <a class="el" href="EDSC_2Builders_8h_source.html#l00217">mlir::edsc::TemplatedIndexedValue&lt; Load, Store &gt;::getElementalTypeAs()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>, <a class="el" href="SDBMExpr_8h_source.html#l00106">mlir::SDBMExpr::operator!()</a>, and <a class="el" href="SDBMExpr_8h_source.html#l00474">mlir::ops_assertions::operator+()</a>.</p>

</div>
</div>
<a id="a72aa3fc8e169b33e5d4a63f593172d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa3fc8e169b33e5d4a63f593172d4e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">225</a> of file <a class="el" href="IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00043">getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00478">getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00453">getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00826">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00463">getAffineSymbolExpr()</a>, and <a class="el" href="Ops_8cpp_source.html#l03308">operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="aafa2646a6fd6b2ed304e40fc8ad24f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa2646a6fd6b2ed304e40fc8ad24f20">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00061">61</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00046">compare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PredicateTree_8cpp_source.html#l00173">buildPredicateList()</a>, <a class="el" href="TableGen_2Dialect_8h_source.html#l00070">mlir::tblgen::Dialect::operator!=()</a>, and <a class="el" href="TypeDef_8h_source.html#l00034">mlir::tblgen::TypeDef::TypeDef()</a>.</p>

</div>
</div>
<a id="a9f5e28263eb0fcf092160b8a9e0f6ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5e28263eb0fcf092160b8a9e0f6ce8">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00082">82</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>.</p>

</div>
</div>
<a id="a9db54f641a4e3e28ebdf5a3e42e9964b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db54f641a4e3e28ebdf5a3e42e9964b">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8cpp_source.html#l00049">49</a> of file <a class="el" href="Attributes_8cpp_source.html">Attributes.cpp</a>.</p>

</div>
</div>
<a id="ae54da410db8d38b2bacd3bb5e5045582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54da410db8d38b2bacd3bb5e5045582">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8cpp_source.html#l00052">52</a> of file <a class="el" href="Attributes_8cpp_source.html">Attributes.cpp</a>.</p>

</div>
</div>
<a id="a96266cfa6acb9131f4beeb8b5b4db9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96266cfa6acb9131f4beeb8b5b4db9b4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l03308">3308</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8h_source.html#l00025">mlir::Range::offset</a>, <a class="el" href="ViewLikeInterface_8h_source.html#l00026">mlir::Range::size</a>, and <a class="el" href="ViewLikeInterface_8h_source.html#l00027">mlir::Range::stride</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00225">operator-()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00175">operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a30603aed1417a20bef2b8efae1167bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30603aed1417a20bef2b8efae1167bde">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00056">56</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#a768bb4630d64c0e4c122528d5d5c9285">mlir::DialectAsmPrinter::printAttribute()</a>.</p>

</div>
</div>
<a id="a649ee8579b14d0897aab47f53b883b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649ee8579b14d0897aab47f53b883b29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00061">61</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#ab02ac89957d800e1349a3480de0b54ff">mlir::DialectAsmPrinter::printFloat()</a>.</p>

</div>
</div>
<a id="a1afb696ee471be35a4d1f75c64ea1bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afb696ee471be35a4d1f75c64ea1bd4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00066">66</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="ae26a3adac6475f34a40e802331ee10d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26a3adac6475f34a40e802331ee10d6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00069">69</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="aa2ffb26ef01caacb04bda28d4501f4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ffb26ef01caacb04bda28d4501f4fd">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00073">73</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#a54221cc3b0583573cd7481e3ed3f7633">mlir::DialectAsmPrinter::printType()</a>.</p>

</div>
</div>
<a id="a9f5b241db4d1de80e4879009596797b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5b241db4d1de80e4879009596797b6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00080">80</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00041">mlir::Identifier::print()</a>.</p>

</div>
</div>
<a id="af9916cd8c014a3b0a666cc2fe88a6fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9916cd8c014a3b0a666cc2fe88a6fae">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[8/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_convertible&lt; T &amp;, Attribute &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp;&gt;::value &amp;&amp;!llvm::is_one_of&lt; T, double, float &gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00087">87</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#a78fab18b310c7e80c94b5bf3c7c1f66d">mlir::DialectAsmPrinter::getStream()</a>.</p>

</div>
</div>
<a id="ab097ddf5971ea2a3956fc814005f459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097ddf5971ea2a3956fc814005f459f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[9/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00092">92</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00076">mlir::Location::print()</a>.</p>

</div>
</div>
<a id="a5e8f0e932c305de3ac1584560d1b03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f0e932c305de3ac1584560d1b03d0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[10/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00093">93</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02518">mlir::Attribute::print()</a>.</p>

</div>
</div>
<a id="ae72e36349258a6b2baeae78188a74550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e36349258a6b2baeae78188a74550">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[11/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00145">145</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00057">mlir::DiagnosticArgument::print()</a>.</p>

</div>
</div>
<a id="acabdc4e9d44aae13942c9ea9b41b9a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdc4e9d44aae13942c9ea9b41b9a33">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[12/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00156">156</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a0454cf763cf2a4bab30345a05f174fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0454cf763cf2a4bab30345a05f174fe6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[13/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00165">165</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00049">mlir::OpAsmPrinter::printOperands()</a>.</p>

</div>
</div>
<a id="a9b198f57489cfde31dc674cca18d6e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b198f57489cfde31dc674cca18d6e9d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[14/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00170">170</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acdfd3cf030c2a51ba8746715ca686417">mlir::OpAsmPrinter::printType()</a>.</p>

</div>
</div>
<a id="a6974d43c0e2f0e03e5ffe739237dcae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6974d43c0e2f0e03e5ffe739237dcae4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[15/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00175">175</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a45343700e3bbe60085d5478d073c1009">mlir::OpAsmPrinter::getStream()</a>, <a class="el" href="Ops_8cpp_source.html#l03308">operator&lt;&lt;()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#a693e157c72502460919366e54d2d8080">mlir::OpAsmPrinter::printAttribute()</a>.</p>

</div>
</div>
<a id="acd5bfd80339235fbb32a685ff75f4e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bfd80339235fbb32a685ff75f4e16">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[16/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00175">175</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02527">mlir::Type::print()</a>.</p>

</div>
</div>
<a id="af05b62a76688ea80f262ea5b69665ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05b62a76688ea80f262ea5b69665ae4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[17/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00195">195</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ad554d3204bdbdc4a87d291ed94c1e575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad554d3204bdbdc4a87d291ed94c1e575">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[18/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00199">199</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a922b7c99e121802c2e58a80f964b8561">mlir::OpAsmPrinter::printSuccessor()</a>.</p>

</div>
</div>
<a id="ab8211b996d6a22980eb1685cc95da68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8211b996d6a22980eb1685cc95da68b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[19/29]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueRangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; ValueRangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00205">205</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a136935d6144b1b049ffd094c23ecda73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136935d6144b1b049ffd094c23ecda73">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[20/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00210">210</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="ac6f24a74c286a71cc71f45da9d4919ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f24a74c286a71cc71f45da9d4919ab">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[21/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00214">214</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="a3df16c49c963cdc57cf6f9e7c3e9f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df16c49c963cdc57cf6f9e7c3e9f822">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[22/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00240">240</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02566">mlir::Value::print()</a>.</p>

</div>
</div>
<a id="ae69078b1d3f3263a1769df2e0f1730df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69078b1d3f3263a1769df2e0f1730df">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[23/29]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00816">816</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02541">mlir::AffineExpr::print()</a>.</p>

</div>
</div>
<a id="a310fba6c1ad548d4884cf850b4b7df08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310fba6c1ad548d4884cf850b4b7df08">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[24/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow printing to a stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00279">279</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00697">mlir::OpTrait::impl::foldIdempotent()</a>, <a class="el" href="Operation_8cpp_source.html#l00707">mlir::OpTrait::impl::foldInvolution()</a>, <a class="el" href="OpDefinition_8h_source.html#l00137">mlir::OpState::print()</a>, <a class="el" href="Operation_8cpp_source.html#l00738">mlir::OpTrait::impl::verifyAtLeastNOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00825">mlir::OpTrait::impl::verifyAtLeastNRegions()</a>, <a class="el" href="Operation_8cpp_source.html#l00851">mlir::OpTrait::impl::verifyAtLeastNResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00992">mlir::OpTrait::impl::verifyAtLeastNSuccessors()</a>, <a class="el" href="Operation_8cpp_source.html#l01095">mlir::OpTrait::impl::verifyElementwiseMappable()</a>, <a class="el" href="Operation_8cpp_source.html#l00758">mlir::OpTrait::impl::verifyIsIdempotent()</a>, <a class="el" href="Operation_8cpp_source.html#l00766">mlir::OpTrait::impl::verifyIsInvolution()</a>, <a class="el" href="Operation_8cpp_source.html#l00950">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="Operation_8cpp_source.html#l00729">mlir::OpTrait::impl::verifyNOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l01070">mlir::OpTrait::impl::verifyNoRegionArguments()</a>, <a class="el" href="Operation_8cpp_source.html#l00818">mlir::OpTrait::impl::verifyNRegions()</a>, <a class="el" href="Operation_8cpp_source.html#l00844">mlir::OpTrait::impl::verifyNResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00983">mlir::OpTrait::impl::verifyNSuccessors()</a>, <a class="el" href="Operation_8cpp_source.html#l00723">mlir::OpTrait::impl::verifyOneOperand()</a>, <a class="el" href="Operation_8cpp_source.html#l00812">mlir::OpTrait::impl::verifyOneRegion()</a>, <a class="el" href="Operation_8cpp_source.html#l00838">mlir::OpTrait::impl::verifyOneResult()</a>, <a class="el" href="Operation_8cpp_source.html#l00976">mlir::OpTrait::impl::verifyOneSuccessor()</a>, <a class="el" href="Operation_8cpp_source.html#l00784">mlir::OpTrait::impl::verifyOperandsAreFloatLike()</a>, <a class="el" href="Operation_8cpp_source.html#l00775">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01060">mlir::OpTrait::impl::verifyOperandSizeAttr()</a>, <a class="el" href="Operation_8cpp_source.html#l01002">mlir::OpTrait::impl::verifyResultsAreBoolLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01013">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01022">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01065">mlir::OpTrait::impl::verifyResultSizeAttr()</a>, <a class="el" href="Operation_8cpp_source.html#l00904">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00871">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00928">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00890">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00859">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00793">mlir::OpTrait::impl::verifySameTypeOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00717">mlir::OpTrait::impl::verifyZeroOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00806">mlir::OpTrait::impl::verifyZeroRegion()</a>, <a class="el" href="Operation_8cpp_source.html#l00832">mlir::OpTrait::impl::verifyZeroResult()</a>, and <a class="el" href="Operation_8cpp_source.html#l00968">mlir::OpTrait::impl::verifyZeroSuccessor()</a>.</p>

</div>
</div>
<a id="a85b9a8e647d5e73b7e107b0669ec9e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b9a8e647d5e73b7e107b0669ec9e29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[25/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Diagnostics_8h_source.html#l00297">297</a> of file <a class="el" href="IR_2Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00134">mlir::Diagnostic::print()</a>.</p>

</div>
</div>
<a id="acee66a47ca548fabe02261ad8b96eea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee66a47ca548fabe02261ad8b96eea5">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[26/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PDLValue.html">PDLValue</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00299">299</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00076">mlir::PDLValue::print()</a>.</p>

</div>
</div>
<a id="a6f93a44db5e2d93372201d5a594e51cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f93a44db5e2d93372201d5a594e51cd">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[27/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00333">333</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02554">mlir::AffineMap::print()</a>.</p>

</div>
</div>
<a id="aff09e0657f1f97508b409ac5f6e4e5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff09e0657f1f97508b409ac5f6e4e5b8">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[28/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00363">363</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00045">mlir::OperationName::print()</a>.</p>

</div>
</div>
<a id="a253b4a2344293dfbeab47ede8971fb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b4a2344293dfbeab47ede8971fb29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[29/29]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Operation_8h_source.html#l00757">757</a> of file <a class="el" href="Operation_8h_source.html">Operation.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02598">mlir::Operation::print()</a>.</p>

</div>
</div>
<a id="aa05e51a2c29b9ba3893b6217be170936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05e51a2c29b9ba3893b6217be170936">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00063">63</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00046">compare()</a>.</p>

</div>
</div>
<a id="a8491b7c1cf514aa1510eb26fd5003c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8491b7c1cf514aa1510eb26fd5003c18">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00086">86</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>.</p>

</div>
</div>
<a id="a0db37cd8863ba3c235e95b092062c209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db37cd8863ba3c235e95b092062c209">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00065">65</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00046">compare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8h_source.html#l00075">mlir::AffineExpr::operator!=()</a>, <a class="el" href="IRModules_8h_source.html#l00584">mlir::python::PyAttribute::PyAttribute()</a>, <a class="el" href="IRModules_8h_source.html#l00630">mlir::python::PyType::PyType()</a>, and <a class="el" href="TypeDef_8h_source.html#l00034">mlir::tblgen::TypeDef::TypeDef()</a>.</p>

</div>
</div>
<a id="aa492640c61b36ef2ab8565e5015abd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa492640c61b36ef2ab8565e5015abd1e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00086">86</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00037">mlir::Identifier::strref()</a>.</p>

</div>
</div>
<a id="a572d4713cebe03e129bef601d1041f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572d4713cebe03e129bef601d1041f0f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00090">90</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>.</p>

</div>
</div>
<a id="ad6b0dcdd7e4c238b039144d7840350f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b0dcdd7e4c238b039144d7840350f2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00091">91</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00037">mlir::Identifier::strref()</a>.</p>

</div>
</div>
<a id="a8fc3d1f66f267d9111234fac1effdfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc3d1f66f267d9111234fac1effdfce">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueTypeRange.html">ValueTypeRange</a>&lt; RangeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeRange_8h_source.html#l00127">127</a> of file <a class="el" href="TypeRange_8h_source.html">TypeRange.h</a>.</p>

</div>
</div>
<a id="abc4f129dda2c412845b5ec66a77325a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f129dda2c412845b5ec66a77325a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00266">266</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00109">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a14c6a127d8f1fa12d3c7405b9d51a695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c6a127d8f1fa12d3c7405b9d51a695">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00368">368</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00352">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="aee21eef29c421651c18a73ff7949668e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee21eef29c421651c18a73ff7949668e">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00067">67</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00046">compare()</a>.</p>

</div>
</div>
<a id="abbcfbb1e7cb68e45a545a6c56207962a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcfbb1e7cb68e45a545a6c56207962a">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Fraction.html">Fraction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fraction_8h_source.html#l00069">69</a> of file <a class="el" href="Fraction_8h_source.html">Fraction.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00046">compare()</a>.</p>

</div>
</div>
<a id="abd4acbd7bfe2fc80c3ab32756218d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4acbd7bfe2fc80c3ab32756218d9d6">&#9670;&nbsp;</a></span>outlineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::outlineIfOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncOp *&#160;</td>
          <td class="paramname"><em>thenFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>thenFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncOp *&#160;</td>
          <td class="paramname"><em>elseFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>elseFnName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outline the then and/or else regions of <code>ifOp</code> as follows: </p>
<ul>
<li>if <code>thenFn</code> is not null, <code>thenFnName</code> must be specified and the <code>then</code> region is inlined into a new FuncOp that is captured by the pointer.</li>
<li>if <code>elseFn</code> is not null, <code>elseFnName</code> must be specified and the <code>else</code> region is inlined into a new FuncOp that is captured by the pointer. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00080">80</a> of file <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00034">mlir::Block::clear()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00463">mlir::OpBuilder::clone()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::front()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00129">mlir::FunctionType::get()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="Operation_8h_source.html#l00254">mlir::Operation::getOperands()</a>, <a class="el" href="Operation_8h_source.html#l00286">mlir::Operation::getResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00560">mlir::Operation::getResultTypes()</a>, <a class="el" href="Block_8cpp_source.html#l00216">mlir::Block::getTerminator()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00058">getUsedValuesDefinedAbove()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00070">mlir::BlockAndValueMapping::lookup()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00314">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00352">mlir::OpBuilder::setInsertionPointToEnd()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00347">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="Block_8h_source.html#l00191">mlir::Block::without_terminator()</a>.</p>

</div>
</div>
<a id="ae9152a09d079148a1a2f40d4946f7c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9152a09d079148a1a2f40d4946f7c17">&#9670;&nbsp;</a></span>outlineKernelFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gpu::GPUFuncOp mlir::outlineKernelFunc </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>kernelFnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu.func created from outlining the region of a gpu.launch op with the given <code>kernelFnName</code>. </p>
<p>The region of the <code>launchOp</code> can use values from above. These need to be captured and passed as arguments to the generated gpu.func. The generated function has arguments</p><ul>
<li>corresponding to the values passed in as <code>operands</code>, in that order.</li>
<li>any additional values that might be used within the region of the <code>launchOp</code> and defined above it. These captured values are appended to the <code>operands</code> list. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00197">197</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp_source.html#l00138">outlineKernelFuncImpl()</a>.</p>

</div>
</div>
<a id="af1aa182f707b3cb6a071cf1a9937578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aa182f707b3cb6a071cf1a9937578d">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>attrStr</code>. If the passed <code>attrStr</code> has additional tokens that were not part of the type, an error is emitted. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00565">mlirAttributeParseGet()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00285">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00454">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00218">mlir::DialectAsmParser::parseKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00429">mlir::OpAsmParser::parseOptionalInteger()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00579">parseSymbol()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l01014">parseTargetEnvAttr()</a>.</p>

</div>
</div>
<a id="ae34310a5d6e4690062af470064089068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34310a5d6e4690062af470064089068">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bd19a863e2bf8969c4bae3ecaa84a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd19a863e2bf8969c4bae3ecaa84a16">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>attrStr</code>. The number of characters of <code>attrStr</code> parsed in the process is returned in <code>numRead</code>. </p>

</div>
</div>
<a id="ae61d149703ad4537629141fab7417075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61d149703ad4537629141fab7417075">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_8h_source.html#l00187">parseSourceString()</a>.</p>

</div>
</div>
<a id="adc3d0c425094498fc25bf4856eb029c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3d0c425094498fc25bf4856eb029c8">&#9670;&nbsp;</a></span>parseDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;&#160;</td>
          <td class="paramname"><em>numDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses dimension and symbol list and returns true if parsing failed. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00435">435</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a06b1d7cb826bcceb3ce2fe325faff660">mlir::OpAsmParser::getBuilder()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#acabba33fbd8180d7ad2c752821696f92ae4e85fd5ca8927b9be287e34162aab21">mlir::OpAsmParser::OptionalSquare</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#acabba33fbd8180d7ad2c752821696f92a3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::OpAsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af904bf0873e8641211c3a735eca3bfd8">mlir::OpAsmParser::parseOperandList()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00624">mlir::OpAsmParser::resolveOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00316">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00480">parseAffineApplyOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02049">parseAffineIfOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01434">parseBound()</a>.</p>

</div>
</div>
<a id="a4cdbef9427aac1eeac4dbf017bae583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdbef9427aac1eeac4dbf017bae583b">&#9670;&nbsp;</a></span>parseEnumKeywordAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumClass , typename ParserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseEnumKeywordAttr </td>
          <td>(</td>
          <td class="paramtype">EnumClass &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserType &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em> = <code>spirv::attributeName&lt;EnumClass&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the next keyword in <code>parser</code> as an enumerant of the given <code>EnumClass</code>. </p>

<p class="definition">Definition at line <a class="el" href="ParserUtils_8h_source.html#l00025">25</a> of file <a class="el" href="ParserUtils_8h_source.html">ParserUtils.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVOps_8cpp_source.html#l00171">parseControlAttribute()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00312">parseCooperativeMatrixType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00156">parseEnumKeywordAttr()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l02451">parseModuleOp()</a>.</p>

</div>
</div>
<a id="a2e17f4db35d6a73c034b1878320a9e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e17f4db35d6a73c034b1878320a9e13">&#9670;&nbsp;</a></span>parseOffsetsSizesAndStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>segmentSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>preResolutionFn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>parseOptionalOffsetPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>parseOptionalSizePrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>parseOptionalStridePrefix</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse trailing part of an op of the form: ``<code> &lt;optional-offset-prefix&gt;</code>[<code>offset-list</code>]<code> &lt;optional-size-prefix&gt;</code>[<code>size-list</code>]<code> &lt;optional-stride-prefix&gt;[</code> stride-list <code>]</code> ``` Each entry in the offset, size and stride list either resolves to an integer constant or an operand of index type. </p>
<p>Constants are added to the <code>result</code> as named integer array attributes with name <code>OffsetSizeAndStrideOpInterface::getStaticOffsetsAttrName()</code> (resp. <code>getStaticSizesAttrName()</code>, <code>getStaticStridesAttrName()</code>).</p>
<p>Append the number of offset, size and stride operands to <code>segmentSizes</code> before adding it to <code>result</code> as the named attribute: <code><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html" title="A trait for operations that have an attribute specifying operand segments. ">OpTrait::AttrSizedOperandSegments</a>&lt;void&gt;::getOperandSegmentSizeAttr()</code>.</p>
<p>Offset, size and stride operands resolution occurs after <code>preResolutionFn</code> to give a chance to leading operands to resolve first, after parsing the types. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00155">155</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00423">mlir::OperationState::addAttribute()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a06b1d7cb826bcceb3ce2fe325faff660">mlir::OpAsmParser::getBuilder()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00112">mlir::Builder::getI32VectorAttr()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00251">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00252">mlir::ShapedType::kDynamicStrideOrOffset</a>, <a class="el" href="OperationSupport_8h_source.html#l00392">mlir::OperationState::operands</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00107">parseListOfOperandsOrIntegers()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00624">mlir::OpAsmParser::resolveOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l02341">parseMemRefReinterpretCastOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00145">parseOffsetsSizesAndStrides()</a>, <a class="el" href="Ops_8cpp_source.html#l03782">parseSubTensorInsertOp()</a>, <a class="el" href="Ops_8cpp_source.html#l03668">parseSubTensorOp()</a>, and <a class="el" href="Ops_8cpp_source.html#l03059">parseSubViewOp()</a>.</p>

</div>
</div>
<a id="a2a5e9dc6800ed6910aa89b8598e2046a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5e9dc6800ed6910aa89b8598e2046a">&#9670;&nbsp;</a></span>parseOffsetsSizesAndStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>segmentSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>parseOptionalOffsetPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>parseOptionalSizePrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>parseOptionalStridePrefix</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>preResolutionFn</code>-less version of <code>parseOffsetsSizesAndStrides</code>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00145">145</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00155">parseOffsetsSizesAndStrides()</a>.</p>

</div>
</div>
<a id="ad8d10077c7edf58c1152a1170257d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d10077c7edf58c1152a1170257d739">&#9670;&nbsp;</a></span>parsePassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses the textual representation of a pass pipeline, and adds the result to 'pm' on success. </p>
<p>This function returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing.</p>
<p>This function returns failure if the given pipeline was invalid. 'errorStream' is an optional parameter that, if non-null, will be used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00470">470</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00432">inlineCallsInSCC()</a>, <a class="el" href="CAPI_2IR_2Pass_8cpp_source.html#l00066">mlirParsePassPipeline()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00189">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="a0d1bcc5ded20de449d4a852d340d919c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1bcc5ded20de449d4a852d340d919c">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l02086">2086</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Location_8cpp_source.html#l00050">mlir::FileLineColLoc::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00114">parseMLIRInput()</a>, <a class="el" href="Parser_8cpp_source.html#l02101">parseSourceFile()</a>, <a class="el" href="Parser_8cpp_source.html#l02127">parseSourceString()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00045">performActions()</a>, and <a class="el" href="Translation_8cpp_source.html#l00094">mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration()</a>.</p>

</div>
</div>
<a id="a1795d3dff83a21eba1ca1fc638b5154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1795d3dff83a21eba1ca1fc638b5154b">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l02101">2101</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Parser_8cpp_source.html#l02086">parseSourceFile()</a>.</p>

</div>
</div>
<a id="a981d1bca708b54f222e845276d76500f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981d1bca708b54f222e845276d76500f">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l02108">2108</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00058">mlir::detail::Parser::emitError()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00838">mlir::UnknownLoc::get()</a>, and <a class="el" href="Parser_8cpp_source.html#l02086">parseSourceFile()</a>.</p>

</div>
</div>
<a id="afa8dabbb172a5956aba4955252714442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8dabbb172a5956aba4955252714442">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr. </p>
<p>TODO: These methods are deprecated in favor of the above template versions.</p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait.</p>
<p>They should be removed when usages have been updated. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_8h_source.html#l00129">129</a> of file <a class="el" href="include_2mlir_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, and <a class="el" href="include_2mlir_2Parser_8h_source.html#l00166">parseSourceFile()</a>.</p>

</div>
</div>
<a id="a6c996bdea9718ac54d8fb9fde211d3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c996bdea9718ac54d8fb9fde211d3a0">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_8h_source.html#l00147">147</a> of file <a class="el" href="include_2mlir_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, and <a class="el" href="include_2mlir_2Parser_8h_source.html#l00166">parseSourceFile()</a>.</p>

</div>
</div>
<a id="a4f94dbdefaa6eba8b6b33b5eab1710a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94dbdefaa6eba8b6b33b5eab1710a9">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_8h_source.html#l00166">166</a> of file <a class="el" href="include_2mlir_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_8h_source.html#l00036">mlir::detail::constructContainerOpForParserIfNecessary()</a>, <a class="el" href="include_2mlir_2Parser_8h_source.html#l00129">parseSourceFile()</a>, and <a class="el" href="include_2mlir_2Parser_8h_source.html#l00187">parseSourceString()</a>.</p>

</div>
</div>
<a id="aca40e833eb161d3044d41db30225fb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca40e833eb161d3044d41db30225fb47">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> *&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the IR string and appends parsed operations to the given block. </p>
<p>If the block is non-empty, the operations are placed before the current terminator. If parsing is successful, success is returned. Otherwise, an error message is emitted through the error handler registered in the context, and failure is returned. If <code>sourceFileLoc</code> is non-null, it is populated with a file location representing the start of the source file that is being parsed. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l02127">2127</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, and <a class="el" href="Parser_8cpp_source.html#l02086">parseSourceFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00145">mlirModuleCreateParse()</a>.</p>

</div>
</div>
<a id="a323631c3744d0b0df384c9c7ba0a1c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323631c3744d0b0df384c9c7ba0a1c1b">&#9670;&nbsp;</a></span>parseSourceString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>sourceStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This parses the provided string containing MLIR. </p>
<p>If the source IR contained a single instance of <code>ContainerOpT</code>, it is returned. Otherwise, a new instance of <code>ContainerOpT</code> is constructed containing all of the parsed operations. If parsing was not successful, null is returned and an error message is emitted through the error handler registered in the context, and failure is returned. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_8h_source.html#l00187">187</a> of file <a class="el" href="include_2mlir_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="namespacemlir.html#ae61d149703ad4537629141fab7417075">parseAttribute()</a>, <a class="el" href="include_2mlir_2Parser_8h_source.html#l00166">parseSourceFile()</a>, and <a class="el" href="namespacemlir.html#afafaf30c94bd5327a769f9fd691cd42a">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_8h_source.html#l00036">mlir::detail::constructContainerOpForParserIfNecessary()</a>.</p>

</div>
</div>
<a id="ac5ffe10560be9caf3b9e8de592c20e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ffe10560be9caf3b9e8de592c20e93">&#9670;&nbsp;</a></span>parseType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>typeStr</code>. If the passed <code>typeStr</code> has additional tokens that were not part of the type, an error is emitted. </p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00542">mlirTypeParseGet()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00285">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00505">mlir::detail::Parser::parseExtendedAttr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00833">mlir::OpAsmParser::parseKeywordType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00720">mlir::OpAsmParser::parseRegionArgumentList()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00579">parseSymbol()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00314">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00755">mlir::OpAsmParser::parseType()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00772">mlir::OpAsmParser::parseTypeList()</a>.</p>

</div>
</div>
<a id="afafaf30c94bd5327a769f9fd691cd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafaf30c94bd5327a769f9fd691cd42a">&#9670;&nbsp;</a></span>parseType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>typeStr</code>. The number of characters of <code>typeStr</code> parsed in the process is returned in <code>numRead</code>. </p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_8h_source.html#l00187">parseSourceString()</a>.</p>

</div>
</div>
<a id="a48413a8aa4dcee8ffa93b222cbedfd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48413a8aa4dcee8ffa93b222cbedfd1b">&#9670;&nbsp;</a></span>permuteLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::permuteLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>inputNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>permMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a loop permutation on a perfectly nested loop nest <code>inputNest</code> (where the contained loops appear from outer to inner) as specified by the permutation <code>permMap</code>: loop 'i' in <code>inputNest</code> is mapped to location 'loopPermMap[i]', where positions 0, 1, ... </p>
<p>are from the outermost position to inner. Returns the position in <code>inputNest</code> of the AffineForOp that becomes the new outermost loop of this nest. This method always succeeds, asserts out on invalid input / specifications. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01498">1498</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01476">isPerfectlyNested()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01568">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a0a8c7352bef2e6ad933b0342ac148d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8c7352bef2e6ad933b0342ac148d83">&#9670;&nbsp;</a></span>populateAffineToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAffineToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00645">645</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00664">populateAffineToVectorConversionPatterns()</a>, and <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a028a748bab4727e3a069877feeb334a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028a748bab4727e3a069877feeb334a0">&#9670;&nbsp;</a></span>populateAffineToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAffineToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector-related Affine ops to the <a class="el" href="structVector.html">Vector</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00664">664</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00645">populateAffineToStdConversionPatterns()</a>.</p>

</div>
</div>
<a id="a6f580b687935c80164683be626191011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f580b687935c80164683be626191011">&#9670;&nbsp;</a></span>populateArmNeonToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArmNeonToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from theArmNeon dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from ArmNeon to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ArmNeonToLLVM_8cpp_source.html#l00028">28</a> of file <a class="el" href="ArmNeonToLLVM_8cpp_source.html">ArmNeonToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="ac2cb4a6db7cb734a5397d6bd8ba95ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cb4a6db7cb734a5397d6bd8ba95ed0">&#9670;&nbsp;</a></span>populateArmSVEToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateArmSVEToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the ArmSVE dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from ArmSVE to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ArmSVEToLLVM_8cpp_source.html#l00063">63</a> of file <a class="el" href="ArmSVEToLLVM_8cpp_source.html">ArmSVEToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00108">mlir::TypeConverter::addConversion()</a>, <a class="el" href="ArmSVEToLLVM_8cpp_source.html#l00051">convertScalableVectorTypeToLLVM()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a7c1a01ce69d98daf0f1ff18f3382afef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1a01ce69d98daf0f1ff18f3382afef">&#9670;&nbsp;</a></span>populateAVX512ToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateAVX512ToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the AVX512 dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from AVX512 to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html#l00083">83</a> of file <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html">ConvertAVX512ToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardToLLVM_8cpp_source.html#l00169">mlir::LLVMTypeConverter::getContext()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a5908d0edfe85968d0e0931fac2662a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5908d0edfe85968d0e0931fac2662a1a">&#9670;&nbsp;</a></span>populateBranchOpInterfaceAndReturnOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBranchOpInterfaceAndReturnOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to rewrite branch operations and <code>return</code> to use operands that have been legalized by the conversion framework. </p>
<p>This can only be done if the branch operation implements the BranchOpInterface. Only needed for partial conversions. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00105">105</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a97db3d8a0876c380ebbfb94dea141e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97db3d8a0876c380ebbfb94dea141e31">&#9670;&nbsp;</a></span>populateBufferizeMaterializationLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBufferizeMaterializationLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a>. </p>
<p>This function should be called by all bufferization passes using <a class="el" href="classmlir_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con...">BufferizeTypeConverter</a> so that materializations work proprely. One exception is bufferization passes doing "full" conversions, where it can be desirable for even the materializations to remain illegal so that they are eliminated, such as via the patterns in populateEliminateBufferizeMaterializationsPatterns. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Bufferize_8cpp_source.html#l00049">49</a> of file <a class="el" href="Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00579">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00376">mlir::OpConversionPattern&lt; SourceOp &gt;::OpConversionPattern()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01262">mlir::ConversionPatternRewriter::replaceOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="ae6fe385239da2dd1c47fa998533a19f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fe385239da2dd1c47fa998533a19f6">&#9670;&nbsp;</a></span>populateBuiltinFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateBuiltinFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect. </p>
<p>These patterns do not handle shader interface/ABI; they convert function parameters to be of SPIR-V allowed types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVLowering_8cpp_source.html#l00511">511</a> of file <a class="el" href="SPIRVLowering_8cpp_source.html">SPIRVLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a5eb68d915d09e2a565b90cab3e063725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb68d915d09e2a565b90cab3e063725">&#9670;&nbsp;</a></span>populateCallOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateCallOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the operand and result types of a CallOp with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="FuncConversions_8cpp_source.html#l00040">40</a> of file <a class="el" href="FuncConversions_8cpp_source.html">FuncConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="Operation_8h_source.html#l00096">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00222">mlir::Block::getNumSuccessors()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="Operation_8h_source.html#l00250">mlir::Operation::operand_begin()</a>, <a class="el" href="Operation_8h_source.html#l00251">mlir::Operation::operand_end()</a>, <a class="el" href="Operation_8cpp_source.html#l00255">mlir::Operation::setOperands()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00505">mlir::PatternRewriter::updateRootInPlace()</a>.</p>

</div>
</div>
<a id="a0412428031c74e126cc1967995b459f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0412428031c74e126cc1967995b459f1">&#9670;&nbsp;</a></span>populateConvertShapeConstraintsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateConvertShapeConstraintsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertShapeConstraints_8cpp_source.html#l00108">108</a> of file <a class="el" href="ConvertShapeConstraints_8cpp_source.html">ConvertShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a17e29398e22218a20f0655d54f4ad42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e29398e22218a20f0655d54f4ad42f">&#9670;&nbsp;</a></span>populateDecomposeCallGraphTypesPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateDecomposeCallGraphTypesPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueDecomposer.html">ValueDecomposer</a> &amp;&#160;</td>
          <td class="paramname"><em>decomposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the patterns needed to drive the conversion process for decomposing call graph types with the given <code><a class="el" href="classmlir_1_1ValueDecomposer.html" title="This class provides a hook that expands one Value into multiple Value&#39;s, with a TypeConverter-inspire...">ValueDecomposer</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00185">185</a> of file <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html">DecomposeCallGraphTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DecomposeCallGraphTypes_8h_source.html#l00057">mlir::ValueDecomposer::addDecomposeValueConversion()</a>.</p>

</div>
</div>
<a id="aac0016623ea2aef0f1011f6ab86c292d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0016623ea2aef0f1011f6ab86c292d">&#9670;&nbsp;</a></span>populateElementwiseToLinalgConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateElementwiseToLinalgConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00069">69</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00018">isElementwiseMappableOpOnRankedTensors()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00693">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="ab28503c96b0a48e02a84f1d7648c0170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28503c96b0a48e02a84f1d7648c0170">&#9670;&nbsp;</a></span>populateEliminateBufferizeMaterializationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateEliminateBufferizeMaterializationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to eliminate bufferize materializations. </p>
<p>In particular, these are the tensor_load/tensor_to_memref ops. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Bufferize_8cpp_source.html#l00085">85</a> of file <a class="el" href="Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02698">applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02446">mlir::TypeConverter::isLegal()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00693">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="a3eb6843e869e5285c6352a08eb16990b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb6843e869e5285c6352a08eb16990b">&#9670;&nbsp;</a></span>populateExpandTanhPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateExpandTanhPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandTanh_8cpp_source.html#l00067">67</a> of file <a class="el" href="ExpandTanh_8cpp_source.html">ExpandTanh.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a76943f37953fdc699537f96e8cc88e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76943f37953fdc699537f96e8cc88e73">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFoldReshapeOpsByExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op. </p>

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l01011">1011</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l01019">populateLinalgTensorOpsFusionPatterns()</a>.</p>

</div>
</div>
<a id="a674e12e2081908fa2a5f013000135528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674e12e2081908fa2a5f013000135528">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByLinearizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFoldReshapeOpsByLinearizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic/indexed_generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic/indexed_generic operation. </p>

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l01004">1004</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00935">mlir::linalg::fuseTensorOps()</a>.</p>

</div>
</div>
<a id="a923f103c236da2f1bb3afc9ceff7ac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923f103c236da2f1bb3afc9ceff7ac13">&#9670;&nbsp;</a></span>populateFuncOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateFuncOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the signature of a FuncOp with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l02542">2542</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00405">mlir::OpConversionPattern&lt; SPIRVOp &gt;::matchAndRewrite()</a>, and <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>.</p>

</div>
</div>
<a id="abfabbc14219f84bd165b16d8d3f0d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfabbc14219f84bd165b16d8d3f0d2be">&#9670;&nbsp;</a></span>populateGpuAllReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuAllReducePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite all-reduce ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="AllReduceLowering_8cpp_source.html#l00400">400</a> of file <a class="el" href="AllReduceLowering_8cpp_source.html">AllReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2Passes_8h_source.html#l00031">populateGpuRewritePatterns()</a>.</p>

</div>
</div>
<a id="acd6199c25bfc092bd63f31f982855e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6199c25bfc092bd63f31f982855e1c">&#9670;&nbsp;</a></span>populateGpuRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all patterns to rewrite ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2GPU_2Passes_8h_source.html#l00031">31</a> of file <a class="el" href="Dialect_2GPU_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">References <a class="el" href="AllReduceLowering_8cpp_source.html#l00400">populateGpuAllReducePatterns()</a>.</p>

</div>
</div>
<a id="ad676c79a418c8cea488a81ca033f1bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad676c79a418c8cea488a81ca033f1bfa">&#9670;&nbsp;</a></span>populateGpuToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>gpuBinaryAnnotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00651">651</a> of file <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html">ConvertLaunchFuncToRuntimeCalls.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00108">mlir::TypeConverter::addConversion()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00169">mlir::LLVMTypeConverter::getContext()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00151">mlir::LLVM::LLVMType::getInt8PtrTy()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a2cb104ff278ae6a462a7e4339637f405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb104ff278ae6a462a7e4339637f405">&#9670;&nbsp;</a></span>populateGpuToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00157">157</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00101">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="ab22a5016f3fa28ed9fb7b40a623953fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22a5016f3fa28ed9fb7b40a623953fe">&#9670;&nbsp;</a></span>populateGpuToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGpuToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00093">93</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00101">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="af7d6ea0d1589ae7c3f029568e10156d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d6ea0d1589ae7c3f029568e10156d8">&#9670;&nbsp;</a></span>populateGPUToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateGPUToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops. </p>
<p>For a gpu.func to be converted, it should have a spv.entry_point_abi attribute. </p>

<p class="definition">Definition at line <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00330">330</a> of file <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html">ConvertGPUToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="ad494366e45b9b08aabb18c7172ed2603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad494366e45b9b08aabb18c7172ed2603">&#9670;&nbsp;</a></span>populateLinalgFoldUnitExtentDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLinalgFoldUnitExtentDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors. </p>
<p>Patterns that are used to canonicalize the use of unit-extent dims for broadcasting.</p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00495">495</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="acebcf7e9ee4c9709c85fb51110677d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebcf7e9ee4c9709c85fb51110677d91">&#9670;&nbsp;</a></span>populateLinalgTensorOpsFusionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLinalgTensorOpsFusionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for fusing linalg operation on tensors. </p>

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l01019">1019</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l01011">populateFoldReshapeOpsByExpansionPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00935">mlir::linalg::fuseTensorOps()</a>.</p>

</div>
</div>
<a id="abb0a617ff9771ea0f0e89ff319e236f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0a617ff9771ea0f0e89ff319e236f8">&#9670;&nbsp;</a></span>populateLinalgToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLinalgToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">294</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00108">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00579">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02698">applyFullConversion()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00085">convertRangeType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00645">populateAffineToStdConversionPatterns()</a>, <a class="el" href="SCFToStandard_8cpp_source.html#l00571">populateLoopToStdConversionPatterns()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">populateStdToLLVMConversionPatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01504">populateVectorToLLVMConversionPatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01537">populateVectorToLLVMMatrixConversionPatterns()</a>, and <a class="el" href="VectorToSCF_8cpp_source.html#l00689">populateVectorToSCFConversionPatterns()</a>.</p>

</div>
</div>
<a id="ac9ab10075190617391facb4618b29149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ab10075190617391facb4618b29149">&#9670;&nbsp;</a></span>populateLinalgToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLinalgToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating Linalg ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00204">204</a> of file <a class="el" href="LinalgToSPIRV_8cpp_source.html">LinalgToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a1ca74253af65583026863be8081bbd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca74253af65583026863be8081bbd84">&#9670;&nbsp;</a></span>populateLoopToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateLoopToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the Standard dialect, in particular convert structured control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="SCFToStandard_8cpp_source.html#l00571">571</a> of file <a class="el" href="SCFToStandard_8cpp_source.html">SCFToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00621">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00693">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a9a78c19d5b35b9e7a4f83bf5a880a744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a78c19d5b35b9e7a4f83bf5a880a744">&#9670;&nbsp;</a></span>populateOpenMPToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateOpenMPToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from OpenMP to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00044">44</a> of file <a class="el" href="OpenMPToLLVM_8cpp_source.html">OpenMPToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00589">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00579">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02446">mlir::TypeConverter::isLegal()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a2a4df81f80f7ca782e9d0486a651e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4df81f80f7ca782e9d0486a651e3ac">&#9670;&nbsp;</a></span>populateParallelLoopToGPUPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateParallelLoopToGPUPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern from <code>scf.parallel</code> to <code>gpu.launch</code> to the provided pattern list. </p>

<p class="definition">Definition at line <a class="el" href="SCFToGPU_8cpp_source.html#l00644">644</a> of file <a class="el" href="SCFToGPU_8cpp_source.html">SCFToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a5eba89fba5bddc4eb0e616f6af054159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eba89fba5bddc4eb0e616f6af054159">&#9670;&nbsp;</a></span>populateRemoveShapeConstraintsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateRemoveShapeConstraintsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveShapeConstraints_8cpp_source.html#l00058">58</a> of file <a class="el" href="RemoveShapeConstraints_8cpp_source.html">RemoveShapeConstraints.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="aae43dd9bce38e340317494194d891da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae43dd9bce38e340317494194d891da8">&#9670;&nbsp;</a></span>populateSCFToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSCFToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ScfToSPIRVContext.html">ScfToSPIRVContext</a> &amp;&#160;</td>
          <td class="paramname"><em>scfToSPIRVContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to lower from scf.for, scf.if, and loop.terminator to CFG operations within the SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="SCFToSPIRV_8cpp_source.html#l00292">292</a> of file <a class="el" href="SCFToSPIRV_8cpp_source.html">SCFToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCFToSPIRV_8h_source.html#l00030">mlir::ScfToSPIRVContext::getImpl()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCFToSPIRV_8h_source.html#l00030">mlir::ScfToSPIRVContext::getImpl()</a>.</p>

</div>
</div>
<a id="aeae7578d528972d48e7413de4f08df04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae7578d528972d48e7413de4f08df04">&#9670;&nbsp;</a></span>populateShapeRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the Shape dialect. </p>

<p class="definition">Definition at line <a class="el" href="ShapeToShapeLowering_8cpp_source.html#l00075">75</a> of file <a class="el" href="ShapeToShapeLowering_8cpp_source.html">ShapeToShapeLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a11736fc91b1321cd777e3af89bcff3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11736fc91b1321cd777e3af89bcff3c8">&#9670;&nbsp;</a></span>populateShapeStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for shape dialect structural type conversions and sets up the provided <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types consistently. An example of this is shape.assuming &ndash; the shape.assuming op and the corresponding shape.assuming_yield op need to have consistent types, but the exact types don't matter. So all that we need to do for a structural type conversion is to update both of their types consistently to the new types prescribed by the <a class="el" href="classmlir_1_1TypeConverter.html" title="Type conversion class. ">TypeConverter</a>. </p>

<p class="definition">Definition at line <a class="el" href="Shape_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00059">59</a> of file <a class="el" href="Shape_2Transforms_2StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00589">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a456e7de34f75066daa48f695a9aba0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456e7de34f75066daa48f695a9aba0dc">&#9670;&nbsp;</a></span>populateShapeToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateShapeToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ShapeToStandard_8cpp_source.html#l00603">603</a> of file <a class="el" href="ShapeToStandard_8cpp_source.html">ShapeToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a4a23ded9ba7f08763bf94ef83ed85778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a23ded9ba7f08763bf94ef83ed85778">&#9670;&nbsp;</a></span>populateSPIRVToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns that convert from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01394">1394</a> of file <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html">ConvertSPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00291">mlir::edsc::op::uge()</a>.</p>

</div>
</div>
<a id="a0d44d746cb22b666fef3a65eff78cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d44d746cb22b666fef3a65eff78cfdd">&#9670;&nbsp;</a></span>populateSPIRVToLLVMFunctionConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMFunctionConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns for function conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01509">1509</a> of file <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html">ConvertSPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="ae585d82693c911213445e9f79d1f0534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae585d82693c911213445e9f79d1f0534">&#9670;&nbsp;</a></span>populateSPIRVToLLVMModuleConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMModuleConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given patterns for module conversion from SPIR-V to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01515">1515</a> of file <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html">ConvertSPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="aae66c52897a19a19fdec8d7022372b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae66c52897a19a19fdec8d7022372b7d">&#9670;&nbsp;</a></span>populateSPIRVToLLVMTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateSPIRVToLLVMTypeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates type conversions with additional SPIR-V types. </p>

<p class="definition">Definition at line <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l01379">1379</a> of file <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html">ConvertSPIRVToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00108">mlir::TypeConverter::addConversion()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00247">convertArrayType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00264">convertPointerType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00274">convertRuntimeArrayType()</a>, and <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00285">convertStructType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>.</p>

</div>
</div>
<a id="ad1de38d84e16c5c7e869995fb1c3605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1de38d84e16c5c7e869995fb1c3605b">&#9670;&nbsp;</a></span>populateStandardToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStandardToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating StandardOps to SPIR-V ops. </p>
<p>Also adds the patterns legalize ops not directly translated to SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l01070">1070</a> of file <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html">ConvertStandardToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a976b90bd952df62128137a6a57a1b45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976b90bd952df62128137a6a57a1b45f">&#9670;&nbsp;</a></span>populateStdBufferizePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdBufferizePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2StandardOps_2Transforms_2Bufferize_8cpp_source.html#l00157">157</a> of file <a class="el" href="Dialect_2StandardOps_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00589">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00621">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l02446">mlir::TypeConverter::isLegal()</a>.</p>

</div>
</div>
<a id="ad459188a76d182c2f61e1aa1a903bef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad459188a76d182c2f61e1aa1a903bef0">&#9670;&nbsp;</a></span>populateStdExpandOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdExpandOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the Std dialect. </p>

<p class="definition">Definition at line <a class="el" href="ExpandOps_8cpp_source.html#l00239">239</a> of file <a class="el" href="ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a6ac4da050bc6b23d395d3480f9dfae8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac4da050bc6b23d395d3480f9dfae8a">&#9670;&nbsp;</a></span>populateStdLegalizationPatternsForSPIRVLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdLegalizationPatternsForSPIRVLowering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list patterns to legalize ops that are not directly lowered to SPIR-V. </p>

<p class="definition">Definition at line <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00182">182</a> of file <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html">LegalizeStandardForSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a595c6a19148f86b48b2121b201475618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c6a19148f86b48b2121b201475618">&#9670;&nbsp;</a></span>populateStdToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the patterns to convert from the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>The conversion patterns capture the <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types in the Standard dialect to the LLVM IR dialect. ">LLVMTypeConverter</a> and the <a class="el" href="structmlir_1_1LowerToLLVMOptions.html" title="Options to control the Standard dialect to LLVM lowering. ">LowerToLLVMOptions</a> by reference meaning the references have to remain alive during the entire pattern lifetime. </p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">4030</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardToLLVM_8cpp_source.html#l04022">populateStdToLLVMFuncOpConversionPattern()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l03997">populateStdToLLVMMemoryConversionPatterns()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l03924">populateStdToLLVMNonMemoryConversionPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>, <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00042">mlir::LowerToLLVMOptions::getDefaultOptions()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00044">populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00150">populateVectorToROCDLConversionPatterns()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04077">mlir::LLVMTypeConverter::promoteOperands()</a>.</p>

</div>
</div>
<a id="a37bd1246643bea508b76bd6ce996a957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bd1246643bea508b76bd6ce996a957">&#9670;&nbsp;</a></span>populateStdToLLVMFuncOpConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdToLLVMFuncOpConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the default pattern to convert a FuncOp to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>If <code>emitCWrappers</code> is set, the pattern will also produce functions that pass memref descriptors by pointer-to-structure in addition to the default unpacked form. </p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l04022">4022</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00103">mlir::LLVMTypeConverter::getOptions()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00030">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00042">mlir::LowerToLLVMOptions::getDefaultOptions()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a66b9d5db7551c34987f32f7f15c67d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b9d5db7551c34987f32f7f15c67d4c">&#9670;&nbsp;</a></span>populateStdToLLVMMemoryConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdToLLVMMemoryConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding non-memory-related operations and FuncOp. </p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l03997">3997</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00103">mlir::LLVMTypeConverter::getOptions()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00034">mlir::LowerToLLVMOptions::useAlignedAlloc</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00042">mlir::LowerToLLVMOptions::getDefaultOptions()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ac272d602be4199d577e0a2e42788c50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac272d602be4199d577e0a2e42788c50d">&#9670;&nbsp;</a></span>populateStdToLLVMNonMemoryConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateStdToLLVMNonMemoryConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding the memory-related operations. </p>
<p>Collect a set of patterns to convert from the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.</p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l03924">3924</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00042">mlir::LowerToLLVMOptions::getDefaultOptions()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a7fef8af390494abff0a5c260e79a5527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fef8af390494abff0a5c260e79a5527">&#9670;&nbsp;</a></span>populateTensorBufferizePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateTensorBufferizePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Transforms_2Bufferize_8cpp_source.html#l00037">37</a> of file <a class="el" href="Dialect_2Tensor_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00621">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="abaf243b415be4cf26241baecd91390df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf243b415be4cf26241baecd91390df">&#9670;&nbsp;</a></span>populateVectorToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reassociateFPReductions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableIndexOptimizations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from <a class="el" href="structVector.html">Vector</a> to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01504">1504</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00101">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ae1eaf09c739bbea77d7d3bb88b07a559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1eaf09c739bbea77d7d3bb88b07a559">&#9670;&nbsp;</a></span>populateVectorToLLVMMatrixConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToLLVMMatrixConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from <a class="el" href="structVector.html">Vector</a> contractions to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> <a class="el" href="classmlir_1_1Matrix.html" title="This is a simple class to represent a resizable matrix. ">Matrix</a> Intrinsics. </p>
<p>To lower to assembly, the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> flag -lower-matrix-intrinsics will be needed when invoking <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01537">1537</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a8794a7c16b04bc9cb75603da29f2444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794a7c16b04bc9cb75603da29f2444a">&#9670;&nbsp;</a></span>populateVectorToROCDLConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToROCDLConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a>. </p>

<p class="definition">Definition at line <a class="el" href="VectorToROCDL_8cpp_source.html#l00150">150</a> of file <a class="el" href="VectorToROCDL_8cpp_source.html">VectorToROCDL.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00658">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02678">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l04030">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a542b1f7e2ff91696f54fad650bfa71ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542b1f7e2ff91696f54fad650bfa71ee">&#9670;&nbsp;</a></span>populateVectorToSCFConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToSCFConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to SCF + std. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l00689">689</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00221">applyPatternsAndFoldGreedily()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="VectorToSCF_8h_source.html#l00160">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::options</a>, and <a class="el" href="VectorToSCF_8h_source.html#l00069">mlir::VectorTransferToSCFOptions::unroll</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00294">populateLinalgToLLVMConversionPatterns()</a>, and <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="ab65e6faa1f5b7ff8d09e45e83a39b86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65e6faa1f5b7ff8d09e45e83a39b86d">&#9670;&nbsp;</a></span>populateVectorToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating <a class="el" href="structVector.html">Vector</a> Ops to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSPIRV_8cpp_source.html#l00120">120</a> of file <a class="el" href="VectorToSPIRV_8cpp_source.html">VectorToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02698">applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00668">mlir::spirv::SPIRVConversionTarget::get()</a>, <a class="el" href="PatternMatch_8h_source.html#l00608">mlir::OwningRewritePatternList::insert()</a>, and <a class="el" href="TargetAndABI_8cpp_source.html#l00191">mlir::spirv::lookupTargetEnvOrDefault()</a>.</p>

</div>
</div>
<a id="a32cc57e028b9dcf6b1d9dc54b6489c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cc57e028b9dcf6b1d9dc54b6489c58">&#9670;&nbsp;</a></span>populateVectorToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::populateVectorToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>coarseVectorShape</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fineVectorShape</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the <a class="el" href="structVector.html">Vector</a> dialect to itself. </p>
<p>Should be merged with populateVectorToSCFLoweringPattern. </p>

</div>
</div>
<a id="a0cebee2d47d356a33b95207e67cfe6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cebee2d47d356a33b95207e67cfe6e0">&#9670;&nbsp;</a></span>printOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::printOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>offsetPrefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>sizePrefix</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>stridePrefix</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td>
          <td class="paramname"><em>elidedAttrs</em> = <code>OffsetSizeAndStrideOpInterface::getSpecialAttrNames()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print part of an op of the form: ``<code> &lt;optional-offset-prefix&gt;</code>[<code>offset-list</code>]<code> &lt;optional-size-prefix&gt;</code>[<code>size-list</code>]<code> &lt;optional-stride-prefix&gt;[</code> stride-list <code>]</code> ```. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00080">80</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00311">mlir::ShapedType::isDynamic()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00314">mlir::ShapedType::isDynamicStrideOrOffset()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00065">printListOfOperandsOrIntegers()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l02323">print()</a>.</p>

</div>
</div>
<a id="a9f574bfd0dab3a0967cf1e3c77780fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f574bfd0dab3a0967cf1e3c77780fd4">&#9670;&nbsp;</a></span>promoteIfSingleIteration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a AffineForOp/scf::ForOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp was known to have a single iteration.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00153">153</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">getConstantTripCount()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00316">mlir::Builder::getDimIdentityMap()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00087">createAffineDataCopyGenerationPass()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00250">generateShiftedLoop()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01031">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00088">normalizeAffineFor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00233">promoteSingleIterationLoops()</a>.</p>

</div>
</div>
<a id="ab5e4727751a2af7968a7f722b77620ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e4727751a2af7968a7f722b77620ff">&#9670;&nbsp;</a></span>promoteIfSingleIteration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a forOp to its containing block if the forOp it can be determined that the loop has a single iteration. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00195">195</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="Ops_8h_source.html#l00105">mlir::ConstantIndexOp::getValue()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a30b3888bdf62ec2761952b4cd27770ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3888bdf62ec2761952b4cd27770ef">&#9670;&nbsp;</a></span>promoteSingleIterationLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::promoteSingleIterationLoops </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>. </p>
<p>Promotes all single iteration 'for' ops in <code>f</code>, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00233">233</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>.</p>

</div>
</div>
<a id="a7173c36d6b113dcdb0599eb672526b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173c36d6b113dcdb0599eb672526b43">&#9670;&nbsp;</a></span>promoteToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::promoteToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype">gpu::GPUFuncOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a function argument to workgroup memory in the given function. </p>
<p>The copies will be inserted in the beginning and in the end of the function. </p>

<p class="reference">Referenced by <a class="el" href="MemoryPromotion_8cpp_source.html#l00134">insertCopies()</a>.</p>

</div>
</div>
<a id="afe55df95d48191f0fa2c5ab8f4e81e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe55df95d48191f0fa2c5ab8f4e81e34">&#9670;&nbsp;</a></span>registerAllDialects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00048">48</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8h_source.html#l00240">mlir::DialectRegistry::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00246">JitRunnerMain()</a>, and <a class="el" href="Registration_8cpp_source.html#l00014">mlirRegisterAllDialects()</a>.</p>

</div>
</div>
<a id="afb552a159c6c887b98b3583dfd5cbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb552a159c6c887b98b3583dfd5cbe5d">&#9670;&nbsp;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllPasses_8h_source.html#l00043">43</a> of file <a class="el" href="InitAllPasses_8h_source.html">InitAllPasses.h</a>.</p>

</div>
</div>
<a id="a8d16808b31b66905b067720d428adf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d16808b31b66905b067720d428adf61">&#9670;&nbsp;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00032">32</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="LLVMArmNeonIntr_8cpp_source.html#l00046">registerArmNeonToLLVMIRTranslation()</a>, <a class="el" href="LLVMArmSVEIntr_8cpp_source.html#l00046">registerArmSVEToLLVMIRTranslation()</a>, <a class="el" href="LLVMAVX512Intr_8cpp_source.html#l00046">registerAVX512ToLLVMIRTranslation()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00876">registerFromLLVMIRTranslation()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00067">registerFromSPIRVTranslation()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00039">registerToLLVMIRTranslation()</a>, <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00100">registerToNVVMIRTranslation()</a>, <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00104">registerToROCDLIRTranslation()</a>, and <a class="el" href="TranslateRegistration_8cpp_source.html#l00108">registerToSPIRVTranslation()</a>.</p>

</div>
</div>
<a id="a2f7dbdbbeef63c0597b8f9949126a24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7dbdbbeef63c0597b8f9949126a24e">&#9670;&nbsp;</a></span>registerArmNeonToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmNeonToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMArmNeonIntr_8cpp_source.html#l00046">46</a> of file <a class="el" href="LLVMArmNeonIntr_8cpp_source.html">LLVMArmNeonIntr.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a50b72741d6e7f2256ad4856beaaa6bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b72741d6e7f2256ad4856beaaa6bf5">&#9670;&nbsp;</a></span>registerArmSVEToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerArmSVEToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMArmSVEIntr_8cpp_source.html#l00046">46</a> of file <a class="el" href="LLVMArmSVEIntr_8cpp_source.html">LLVMArmSVEIntr.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="LLVMArmSVEIntr_8cpp_source.html#l00039">translateLLVMArmSVEModuleToLLVMIR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a894a08aa6ed051f55e57bc35859a379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a08aa6ed051f55e57bc35859a379f">&#9670;&nbsp;</a></span>registerAsmPrinterCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAsmPrinterCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the AsmPrinter. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l00105">105</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00101">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmState_8h_source.html#l00049">mlir::AsmState::getImpl()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, and <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>.</p>

</div>
</div>
<a id="aa837e2927c0f27e9bff6711e40a90492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa837e2927c0f27e9bff6711e40a90492">&#9670;&nbsp;</a></span>registerAVX512ToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerAVX512ToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMAVX512Intr_8cpp_source.html#l00046">46</a> of file <a class="el" href="LLVMAVX512Intr_8cpp_source.html">LLVMAVX512Intr.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="accfff33b4e364b14e039f109ea3d9669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfff33b4e364b14e039f109ea3d9669">&#9670;&nbsp;</a></span>registerDialect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteDialect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerDialect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a267e7e7ec38e0a09285a20831414d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a267e7e7ec38e0a09285a20831414d3">&#9670;&nbsp;</a></span>registerFromLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00876">876</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00859">translateLLVMIRToModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a51ef91a9901d4d87a042990ccb79f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ef91a9901d4d87a042990ccb79f2be">&#9670;&nbsp;</a></span>registerFromSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerFromSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TranslateRegistration_8cpp_source.html#l00067">67</a> of file <a class="el" href="TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateRegistration_8cpp_source.html#l00039">deserializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a5254079fbbd31a78a3430bff18df2d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254079fbbd31a78a3430bff18df2d7c">&#9670;&nbsp;</a></span>registerMLIRContextCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerMLIRContextCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure various flags within the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a>. </p>
<p>These flags are used when constructing an MLIR context for initialization. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00079">79</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00074">clOptions</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRContext_8h_source.html#l00137">mlir::MLIRContext::getImpl()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, and <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>.</p>

</div>
</div>
<a id="adceae2b75bb5d4478ea5d9bd218e152e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adceae2b75bb5d4478ea5d9bd218e152e">&#9670;&nbsp;</a></span>registerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00105">105</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00021">passRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00142">mlir::PassRegistration&lt; ConcretePass &gt;::PassRegistration()</a>.</p>

</div>
</div>
<a id="aa5c4edce10b597637635af55bb162477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c4edce10b597637635af55bb162477">&#9670;&nbsp;</a></span>registerPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a pass manager. </p>
<p>The values of these options can be applied via the 'applyPassManagerCLOptions' method below. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00145">145</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManager_8h_source.html#l00305">mlir::PassManager::PassTimingConfig::getDisplayMode()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>.</p>

</div>
</div>
<a id="a83965c855ad737422194336251348893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83965c855ad737422194336251348893">&#9670;&nbsp;</a></span>registerPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerPassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#af4ccb1e7accf2ec0c57b1aea967ccd02">PassRegistryFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(const <a class="el" href="classmlir_1_1detail_1_1PassOptions.html">detail::PassOptions</a> &amp;)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>optHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template. </p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8cpp_source.html#l00071">mlir::PassRegistryEntry::getOptionWidth()</a>, <a class="el" href="PassRegistry_8h_source.html#l00167">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00189">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="a9ed913befc935e3b4b3e622838655b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed913befc935e3b4b3e622838655b30">&#9670;&nbsp;</a></span>registerTestRoundtripDebugSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestRoundtripDebugSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TranslateRegistration_8cpp_source.html#l00168">168</a> of file <a class="el" href="TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>.</p>

</div>
</div>
<a id="a2b336390b16983a364b2d95bd2a64a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b336390b16983a364b2d95bd2a64a2f">&#9670;&nbsp;</a></span>registerTestRoundtripSPIRV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerTestRoundtripSPIRV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TranslateRegistration_8cpp_source.html#l00157">157</a> of file <a class="el" href="TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>.</p>

</div>
</div>
<a id="a003d72c96a8bffacc207ba165212e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003d72c96a8bffacc207ba165212e2db">&#9670;&nbsp;</a></span>registerToLLVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToLLVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00039">39</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a5db7f6440d3749bb04fc783871b7b93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db7f6440d3749bb04fc783871b7b93b">&#9670;&nbsp;</a></span>registerToNVVMIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToNVVMIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00100">100</a> of file <a class="el" href="ConvertToNVVMIR_8cpp_source.html">ConvertToNVVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="namespacemlir.html#ab90c4b2d1ff332cdf4a0b040d53a89be">translateModuleToNVVMIR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="ae1ed3ae8b1ba3c9068710028ae3afbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ed3ae8b1ba3c9068710028ae3afbc3">&#9670;&nbsp;</a></span>registerToROCDLIRTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToROCDLIRTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00104">104</a> of file <a class="el" href="ConvertToROCDLIR_8cpp_source.html">ConvertToROCDLIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="namespacemlir.html#abab089f0f6a252963ae74f63d293294b">translateModuleToROCDLIR()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="af7f5d34c37689ae9b05537a040d9e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5d34c37689ae9b05537a040d9e0a0">&#9670;&nbsp;</a></span>registerToSPIRVTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::registerToSPIRVTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TranslateRegistration_8cpp_source.html#l00108">108</a> of file <a class="el" href="TranslateRegistration_8cpp_source.html">TranslateRegistration.cpp</a>.</p>

<p class="reference">References <a class="el" href="TranslateRegistration_8cpp_source.html#l00082">serializeModule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllTranslations_8h_source.html#l00032">registerAllTranslations()</a>.</p>

</div>
</div>
<a id="a1fa0a7e84eb2af3d70c98d59fc9ccbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0a7e84eb2af3d70c98d59fc9ccbd3">&#9670;&nbsp;</a></span>removeDuplicateExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::removeDuplicateExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map with the same dimension and symbol count as <code>map</code>, but whose results are the unique affine expressions of <code>map</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00408">408</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00177">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01721">canonicalizeLoopBounds()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02907">createCanonicalizedAffineForOp()</a>, and <a class="el" href="IR_2AffineMap_8h_source.html#l00237">mlir::MutableAffineMap::getContext()</a>.</p>

</div>
</div>
<a id="ac8b8fbbebc62328a945ae239955b846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b8fbbebc62328a945ae239955b846e">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>domInstFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>postDomInstFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonDereferencingOps</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceInDeallocOp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>. </p>
<p>The new memref could be of a different shape or rank. <code>extraIndices</code> provides any additional access indices to be added to the start.</p>
<p><code>indexRemap</code> remaps indices of the old memref access to a new set of indices that are used to index the memref. Additional input operands to indexRemap can be optionally provided in <code>extraOperands</code>, and they occupy the start of its input list. <code>indexRemap</code>'s dimensional inputs are expected to correspond to memref's indices, and its symbolic inputs if any should be provided in <code>symbolOperands</code>.</p>
<p><code>domInstFilter</code>, if non-null, restricts the replacement to only those operations that are dominated by the former; similarly, <code>postDomInstFilter</code> restricts replacement to only those operations that are postdominated by it.</p>
<p>'allowNonDereferencingOps', if set, allows replacement of non-dereferencing uses of a memref without any requirement for access index rewrites. The default value of this flag variable is false.</p>
<p>'replaceInDeallocOp', if set, lets DeallocOp, a non-dereferencing user, to also be a candidate for replacement. The default value of this flag is false.</p>
<p>Returns true on success and false if the replacement is not possible, whenever a memref is used as an operand in a non-dereferencing context and 'allowNonDereferencingOps' is false, except for dealloc's on the memref which are left untouched. See comments at function definition for an example. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00220">220</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00240">mlir::Type::cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00578">getElementType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00216">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Operation_8h_source.html#l00120">mlir::Operation::getParentOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00199">mlir::Value::getUsers()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00031">isMemRefDereferencingOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00775">createPrivateMemRef()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00092">isMemRefNormalizable()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00396">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="a9e5a7944174565a109d7a5efe97cd62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5a7944174565a109d7a5efe97cd62e">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonDereferencingOps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">45</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00980">canonicalizeMapAndOperands()</a>, <a class="el" href="Types_8h_source.html#l00240">mlir::Type::cast()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00392">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00393">mlir::OpBuilder::createOperation()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="Operation_8cpp_source.html#l00487">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00839">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00028">mlir::AffineMapAttr::get()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00037">getAffineMapAttrForMemRef()</a>, <a class="el" href="Operation_8h_source.html#l00307">mlir::Operation::getAttrs()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00578">getElementType()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00320">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00216">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="Operation_8h_source.html#l00228">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00554">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Operation_8h_source.html#l00254">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, <a class="el" href="Operation_8h_source.html#l00286">mlir::Operation::getResults()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00031">isMemRefDereferencingOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00256">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00351">isValidSymbol()</a>, <a class="el" href="Operation_8h_source.html#l00250">mlir::Operation::operand_begin()</a>, <a class="el" href="Operation_8h_source.html#l00251">mlir::Operation::operand_end()</a>, <a class="el" href="OperationSupport_8h_source.html#l00392">mlir::OperationState::operands</a>, <a class="el" href="Operation_8h_source.html#l00155">mlir::Operation::replaceAllUsesWith()</a>, <a class="el" href="Operation_8h_source.html#l00233">mlir::Operation::setOperand()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">simplifyAffineMap()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a15a5d204dd78ac563241168e6b2e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5d204dd78ac563241168e6b2e40eb">&#9670;&nbsp;</a></span>replaceAllUsesInRegionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::replaceAllUsesInRegionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all uses of <code>orig</code> within the given region with <code>replacement</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00023">23</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00183">mlir::Value::getUses()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::isAncestor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01975">coalesceLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02030">collapseParallelLoops()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00106">sinkOperationsIntoLaunchOp()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01649">stripmineSink()</a>.</p>

</div>
</div>
<a id="a3e58dea8a192531cbf60dd5238c0ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58dea8a192531cbf60dd5238c0ba8a">&#9670;&nbsp;</a></span>separateFullTiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::separateFullTiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>fullTileNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates full tiles from partial tiles for a perfect nest <code>nest</code> by generating a conditional guard that selects between the full tile version and the partial tile version using an AffineIfOp. </p>
<p>The original loop nest is replaced by this guarded two version form.</p>
<p>affine.if (cond) // full_tile else // partial tile </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l03066">3066</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l03011">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02929">createSeparationCondition()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::end()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="Block_8h_source.html#l00122">mlir::Block::getOperations()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="a3741dc3ccffcfafa71e4540ba59f08c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3741dc3ccffcfafa71e4540ba59f08c0">&#9670;&nbsp;</a></span>shapeRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::shapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>superShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>subShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the multi-dimensional ratio of <code>superShape</code> to <code>subShape</code>. </p>
<p>This is calculated by performing a traversal from minor to major dimensions (i.e. in reverse shape order). If integral division is not possible, returns None. The ArrayRefs are assumed (and enforced) to only contain &gt; 1 values. This constraint comes from the fact that they are meant to be used with VectorTypes, for which the property holds by construction.</p>
<p>Examples:</p><ul>
<li>shapeRatio({3, 4, 5, 8}, {2, 5, 2}) returns {3, 2, 1, 4}</li>
<li>shapeRatio({3, 4, 4, 8}, {2, 5, 2}) returns None</li>
<li>shapeRatio({1, 2, 10, 32}, {2, 5, 2}) returns {1, 1, 2, 16} </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00111">111</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00060">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00192">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00515">generateTransferOpSlices()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00228">getEnclosingforOps()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00233">initUnrolledVectorState()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00124">mlir::vector::UnrollVectorPattern::matchAndRewrite()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00147">shapeRatio()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>.</p>

</div>
</div>
<a id="a937430eb9b6e13bfb05e6ecc5649a816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937430eb9b6e13bfb05e6ecc5649a816">&#9670;&nbsp;</a></span>shapeRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::shapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a>&#160;</td>
          <td class="paramname"><em>superVectorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a>&#160;</td>
          <td class="paramname"><em>subVectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the multi-dimensional ratio of the shapes of <code>superVector</code> to <code>subVector</code>. </p>
<p>If integral division is not possible, returns None. Assumes and enforces that the VectorTypes have the same elemental type. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00147">147</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00336">mlir::VectorType::getShape()</a>, and <a class="el" href="VectorUtils_8cpp_source.html#l00111">shapeRatio()</a>.</p>

</div>
</div>
<a id="acbf369c69cfb613cd018ef4ce188809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf369c69cfb613cd018ef4ce188809c">&#9670;&nbsp;</a></span>simplifyAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::simplifyAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine expression by flattening and some amount of simple analysis. </p>
<p>Simplify the affine expression by flattening it and reconstructing it.</p>
<p>This has complexity linear in the number of nodes in 'expr'. Returns the simplified expression, which is the same as the input expression if it can't be simplified. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01072">1072</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00826">getAffineExprFromFlatForm()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00021">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00160">mlir::AffineExpr::isPureAffine()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00269">mlir::SimpleAffineExprFlattener::localExprs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00254">mlir::SimpleAffineExprFlattener::operandExprStack</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00403">simplifySemiAffine()</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00073">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00764">canonicalizeStridedLayout()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00266">mlir::AffineExpr::cast()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00775">createPrivateMemRef()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00487">getConstDifference()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01571">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00209">mlir::edsc::ops::linalg_generic_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00246">mlir::edsc::ops::linalg_generic_dilated_conv_nhwc()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00788">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00505">mlir::MutableAffineMap::simplify()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a014d8e82c51794d145267690b2b5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d8e82c51794d145267690b2b5bd58">&#9670;&nbsp;</a></span>simplifyAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::simplifyAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">398</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00876">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00177">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00204">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00208">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00221">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01072">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00701">mlir::AffineApplyNormalizer::AffineApplyNormalizer()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02219">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00757">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00237">mlir::MutableAffineMap::getContext()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00466">mlir::linalg::AffineMinSCFCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00099">replaceUnitDims()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00406">substitute()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00285">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="a1cab5a79af53f1bc236af0c5ba5e7b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cab5a79af53f1bc236af0c5ba5e7b54">&#9670;&nbsp;</a></span>simplifyIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::simplifyIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference. </p>
<p>Also, drop any duplicate constraints. Returns the simplified integer set. This method runs in time linear in the number of constraints. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l01089">1089</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02999">mlir::FlatAffineConstraints::getAsIntegerSet()</a>, <a class="el" href="IntegerSet_8h_source.html#l00054">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00965">mlir::FlatAffineConstraints::isEmpty()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02374">mlir::FlatAffineConstraints::removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="a303077ea0260053bc46cb584abb7767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303077ea0260053bc46cb584abb7767f">&#9670;&nbsp;</a></span>simplifyRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::simplifyRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a set of structural simplifications over the given regions. </p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00696">696</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00078">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00620">mergeIdenticalBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00358">runRegionDCE()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a18ae2e212298fb235973e9d43f98849e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae2e212298fb235973e9d43f98849e">&#9670;&nbsp;</a></span>sinkOperationsIntoLaunchOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::sinkOperationsIntoLaunchOp </td>
          <td>(</td>
          <td class="paramtype">gpu::LaunchOp&#160;</td>
          <td class="paramname"><em>launchOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink operations into the <code>launchOp</code> to reduce the number of values that are used within the region of the operation, but defined outside of the region. </p>

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00106">106</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8cpp_source.html#l00463">mlir::OpBuilder::clone()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00076">extractBeneficiaryOps()</a>, <a class="el" href="Operation_8h_source.html#l00286">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00058">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00023">replaceAllUsesInRegionWith()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="KernelOutlining_8cpp_source.html#l00214">convertToLaunchFuncOp()</a>.</p>

</div>
</div>
<a id="ad4e57efabe41ec9f1d263ed7a42c7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e57efabe41ec9f1d263ed7a42c7f15">&#9670;&nbsp;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01568">1568</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01427">checkLoopInterchangeDependences()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00952">getDependenceComponents()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01006">getPerfectlyNestedLoops()</a>, <a class="el" href="namespacemlir_1_1matcher.html#add2d6ea67e8745edd1987358b954a5e6">mlir::matcher::isParallelLoop()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00087">mlir::DependenceComponent::lb</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01498">permuteLoops()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00089">mlir::DependenceComponent::ub</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01044">isFusionProfitable()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00749">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a2320d5e3423bb76edf4048a5674f8f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2320d5e3423bb76edf4048a5674f8f8e">&#9670;&nbsp;</a></span>splitAndProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>originalBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a>&#160;</td>
          <td class="paramname"><em>processChunkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>. </p>
<p>This is used to allow a large number of small independent tests to be put into a single file. </p>

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8cpp_source.html#l00021">21</a> of file <a class="el" href="ToolUtilities_8cpp_source.html">ToolUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>, and <a class="el" href="MlirOptMain_8cpp_source.html#l00086">processBuffer()</a>.</p>

</div>
</div>
<a id="a6f16fcf3a83d26d5a59da3bf0138ca24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f16fcf3a83d26d5a59da3bf0138ca24">&#9670;&nbsp;</a></span>structFuncArgTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to convert function argument types. </p>
<p>Give structFuncArgTypeConverter access to memref-specific functions.</p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="definition">Definition at line <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">59</a> of file <a class="el" href="StandardToLLVM_8cpp_source.html">StandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02387">mlir::TypeConverter::convertType()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="Types_8h_source.html#l00224">mlir::Type::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a57a1cb2e1046f84d6328600b92c99e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1cb2e1046f84d6328600b92c99e52">&#9670;&nbsp;</a></span>succeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::succeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> corresponds to a success value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00040">40</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Success</a>, and <a class="el" href="structmlir_1_1LogicalResult.html#a367e2bef1a5e5122bc9d0484479a353a">mlir::LogicalResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02651">affineDataCopyGenerate()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00240">applyPatternsAndFoldGreedily()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01721">canonicalizeLoopBounds()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00589">collectSymbolScopes()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00727">computeReshapeCollapsedType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00234">convertScalarType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02387">mlir::TypeConverter::convertType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00270">convertVectorType()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00409">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00775">createPrivateMemRef()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00297">deleteDeadness()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00220">mlir::detail::DiagnosticEngineImpl::emit()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00558">extractStrides()</a>, <a class="el" href="Operation_8cpp_source.html#l00574">mlir::Operation::fold()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00846">foldExtractFromShapeCast()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01694">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01675">foldLoopBounds()</a>, <a class="el" href="OpDefinition_8h_source.html#l01419">mlir::op_definition_impl::foldTraitsImpl()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02114">foldTransferMaskAttribute()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00527">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="LoopUnroll_8cpp_source.html#l00077">gatherInnermostLoops()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01417">mlir::linalg::generateLibraryCallName()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00250">generateShiftedLoop()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00089">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="OpDefinition_8h_source.html#l01559">mlir::Op&lt; DmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;::getFromOpaquePointer()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02459">getNewNumDimsSymbols()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01048">mlir::ConvertToLLVMPattern::getStridedElementPtr()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00515">hasSizeMismatch()</a>, <a class="el" href="Ops_8cpp_source.html#l03969">inferTransposeResultType()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00505">initializeAliases()</a>, <a class="el" href="ByteCode_8cpp_source.html#l00699">mlir::detail::PDLByteCode::initializeMutableState()</a>, <a class="el" href="Inliner_8cpp_source.html#l00432">inlineCallsInSCC()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00106">isFusionLegal()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00838">isStrided()</a>, <a class="el" href="Matchers_8h_source.html#l00067">mlir::detail::constant_op_binder&lt; AttrT &gt;::match()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00111">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00173">mlir::RewritePattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02455">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00220">mlir::OpRewritePattern&lt; vector::ContractionOp &gt;::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01432">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01930">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00534">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00598">mlir::ConvertOpToLLVMPattern&lt; gpu::ReturnOp &gt;::matchAndRewrite()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00620">mergeIdenticalBlocks()</a>, <a class="el" href="IR_8cpp_source.html#l00343">mlirOperationVerify()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00088">normalizeAffineFor()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01228">mlir::detail::ConversionPatternRewriterImpl::notifyRegionWasClonedBefore()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01525">parseAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02904">parseAffineParallelOp()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00086">parseAllocateAndAllocator()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00120">parseAnyType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00845">parseAsyncDependencies()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00569">parseAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01189">parseBranchConditionalOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01526">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00171">parseControlAttribute()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00032">parseCreateOperationOp()</a>, <a class="el" href="Async_8cpp_source.html#l00212">parseExecuteOp()</a>, <a class="el" href="SCF_8cpp_source.html#l00178">parseForOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00016">mlir::impl::parseFunctionArgumentList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00095">parseFunctionResultList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00128">mlir::impl::parseFunctionSignature()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00318">parseGenericOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02045">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01150">parseGlobalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01935">parseGlobalVariableOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00602">parseGPUFuncOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00717">parseGroupNonUniformArithmeticOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00871">parseInterfaceVarABIAttr()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00845">parseKeywordList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00517">parseLandingpadOp()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00107">parseListOfOperandsOrIntegers()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00233">parseLoadOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00464">parseLoopOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02451">parseModuleOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01517">parseNamedStructuredOpResults()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00058">parseOperandAndTypeList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00046">parseOperandList()</a>, <a class="el" href="PDL_8cpp_source.html#l00120">parseOperationOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00199">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="Parser_8cpp_source.html#l00098">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01109">parseOptionalKeywordAlternative()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00089">parseOptionalOperand()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00118">parseOptionalOperandAndType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00199">parseParallelOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00143">parserOptionalOperandAndTypeWithPrefix()</a>, <a class="el" href="Ops_8cpp_source.html#l02640">parseSelectOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02767">parseSpecConstantOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00281">parseStoreOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00540">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00604">parseStructType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01014">parseTargetEnvAttr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00772">mlir::OpAsmParser::parseTypeList()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00194">parseUniformType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00491">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02889">parseVariableOp()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01630">printDenseElementsAttrImpl()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01473">printElidedElementsAttr()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00249">mlir::LLVM::LLVMType::setStructTyBody()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00696">simplifyRegions()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02382">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="TypeTranslation_8cpp_source.html#l00194">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01845">tryIsolateBands()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00294">mlir::linalg::vectorizeLinalgOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02285">verify()</a>, <a class="el" href="OpDefinition_8h_source.html#l01486">mlir::op_definition_impl::verifyTraitsImpl()</a>, and <a class="el" href="CAPI_2Support_8h_source.html#l00032">wrap()</a>.</p>

</div>
</div>
<a id="a5f55c06c7c4aeace3f6824dd68f8b1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">&#9670;&nbsp;</a></span>success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::success </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSuccess</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a>. </p>
<p>If isSuccess is true a <code>success</code> result is generated, otherwise a 'failure' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00026">26</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Failure</a>, and <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00540">ableToUpdatePredOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00656">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01743">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00449">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00552">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01834">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00695">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="OpImplementation_8h_source.html#l00848">mlir::OpAsmParser::addTypesToList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00840">mlir::OpAsmParser::addTypeToList()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00305">affineForOpBodySkew()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00044">allocateBuffersForResults()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00615">analyzeProfitability()</a>, <a class="el" href="Ops_8cpp_source.html#l00858">applyCmpPredicate()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00044">applyMapToValues()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00240">applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00316">mlir::linalg::applyStagedPatterns()</a>, <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00300">areAllLLVMTypes()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00088">barePtrFuncArgTypeConverter()</a>, <a class="el" href="Ops_8cpp_source.html#l01283">mlir::ConstantIndexOp::build()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01995">buildAffineLoopNest()</a>, <a class="el" href="Ops_8cpp_source.html#l03544">canFoldIntoConsumerOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02829">mlir::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01721">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00985">canonicalizeSetAndOperands()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00114">checkAffineLoopNestMappable()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00088">checkAffineLoopNestMappableImpl()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00053">mlir::linalg::LinalgMarker::checkAndNotify()</a>, <a class="el" href="UpdateVCEPass_8cpp_source.html#l00070">checkAndUpdateCapabilityRequirements()</a>, <a class="el" href="UpdateVCEPass_8cpp_source.html#l00042">checkAndUpdateExtensionRequirements()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00065">checkCapabilityRequirements()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00210">checkCompatibleReturnType&lt; float &gt;()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00198">checkCompatibleReturnType&lt; int32_t &gt;()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00204">checkCompatibleReturnType&lt; int64_t &gt;()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00837">checkedAddLLVMFnAttribute()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00038">checkExtensionRequirements()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00582">checkIfHyperRectangular()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00356">checkTensorElementType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00506">checkTilingLegality()</a>, <a class="el" href="Ops_8cpp_source.html#l00569">collapseBranch()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00573">collapseReassociationMaps()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00043">collectValidReferencesFor()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00151">compileAndExecute()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00216">compileAndExecuteSingleReturnFunction()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00464">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00536">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00235">mlir::MemRefRegion::compute()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00032">computeConversionSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02916">computeLocalVars()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00598">computeSliceUnion()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00238">mlir::AffineMap::constantFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02085">mlir::FlatAffineConstraints::constantFoldId()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00263">convertAffineLoopNestToGPULaunch()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02502">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00491">mlir::LLVM::ModuleTranslation::convertOmpMaster()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00529">mlir::LLVM::ModuleTranslation::convertOmpOperation()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00394">mlir::LLVM::ModuleTranslation::convertOmpParallel()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00577">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="FrozenRewritePatternList_8cpp_source.html#l00019">convertPDLToPDLInterp()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00085">convertRangeType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02466">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02481">mlir::TypeConverter::convertSignatureArgs()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00285">convertStructType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02387">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02436">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00087">createAffineDataCopyGenerationPass()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03011">createFullTiles()</a>, <a class="el" href="Generalization_8cpp_source.html#l00033">createGenericOpFromNamedOp()</a>, <a class="el" href="DecomposeCallGraphTypes_8cpp_source.html#l00019">mlir::ValueDecomposer::decomposeValue()</a>, <a class="el" href="Promotion_8cpp_source.html#l00134">defaultDeallocBufferCallBack()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00299">mlir::ContractionOpToMatmulOpLowering::defaultFilter()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00340">mlir::ContractionOpToOuterProductOpLowering::defaultFilter()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00384">mlir::ContractionOpToDotLowering::defaultFilter()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00424">mlir::ContractionOpLowering::defaultFilter()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00297">deleteDeadness()</a>, <a class="el" href="Serialization_8cpp_source.html#l00040">encodeInstructionInto()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>, <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00065">mlir::spirv::encodeStringLiteralInto()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00078">eraseUnreachableBlocks()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00048">extractCompositeElement()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00558">extractStrides()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00080">extractValueFromConstOp()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Bufferize_8cpp_source.html#l00153">finalizeBufferAllocation()</a>, <a class="el" href="Operation_8cpp_source.html#l00574">mlir::Operation::fold()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00652">foldExtractOpFromExtractChain()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00675">foldExtractOpFromTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01694">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01675">foldLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01069">foldMemRefCast()</a>, <a class="el" href="OpDefinition_8h_source.html#l01388">mlir::op_definition_impl::foldTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01419">mlir::op_definition_impl::foldTraitsImpl()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02114">foldTransferMaskAttribute()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00877">forwardPassthroughAttributes()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00935">mlir::linalg::fuseTensorOps()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00437">fuseWithReshapeByExpansion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02308">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02851">generateCopyForMemRegion()</a>, <a class="el" href="LocationSnapshot_8cpp_source.html#l00065">generateLocationsFromIR()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00928">genStmt()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00066">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00163">getBase()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00180">getBasePtr()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00115">mlir::DialectAsmParser::getCurrentLocation()</a>, <a class="el" href="OpImplementation_8h_source.html#l00253">mlir::OpAsmParser::getCurrentLocation()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00218">getDefaultABIAttrs()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00604">mlir::spirv::getElementPtr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00070">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00116">getFlattenedAffineExprs()</a>, <a class="el" href="OpDefinition_8h_source.html#l01559">mlir::Op&lt; DmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;::getFromOpaquePointer()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00360">getGenericEffectsImpl()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00206">getIndexedPtrs()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00088">getIndexSet()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00071">getInterfaceVariables()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00099">getKernelGlobalVariables()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00102">getLaunchConfigIndex()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00489">getLLVMAtomicOrdering()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00146">getMemRefAlignment()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00433">getMemRefSizeInBytes()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00219">mlir::detail::PassOptions::getOptionWidth()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00157">mlir::OperationFolder::getOrCreateConstant()</a>, <a class="el" href="Ops_8cpp_source.html#l03316">getOrCreateRanges()</a>, <a class="el" href="SCF_8cpp_source.html#l01012">mlir::scf::getParallelForInductionVarOwner()</a>, <a class="el" href="Serialization_8cpp_source.html#l00093">getPhiIncomingBlock()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00602">getStridesAndOffset()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00290">getTransferOpAdapter()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01606">handleMultidimensionalVectors()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00515">hasSizeMismatch()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00180">hoistAffineIfOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01803">hoistOpsBetween()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00024">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00505">initializeAliases()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00297">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00432">inlineCallsInSCC()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00140">inlineRegion()</a>, <a class="el" href="Interchange_8cpp_source.html#l00035">mlir::linalg::interchangeGenericLinalgOpPrecondition()</a>, <a class="el" href="ExecutionEngine_8cpp_source.html#l00342">mlir::ExecutionEngine::invoke()</a>, <a class="el" href="ConvertLaunchFuncToRuntimeCalls_8cpp_source.html#l00311">isAsyncWithOneDependency()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00069">isContraction()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00018">isElementwiseMappableOpOnRankedTensors()</a>, <a class="el" href="Deserialization_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01361">isIntegerArrayAttrConfinedToRange()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01381">isIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01346">isIntegerArrayAttrSmallerThanShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01404">isSumOfIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00935">isValidExtractOrInsertSlicesType()</a>, <a class="el" href="Ops_8cpp_source.html#l03864">joinShapes()</a>, <a class="el" href="Loops_8cpp_source.html#l00673">mlir::linalg::linalgOpToAffineLoops()</a>, <a class="el" href="Loops_8cpp_source.html#l00680">mlir::linalg::linalgOpToLoops()</a>, <a class="el" href="Loops_8cpp_source.html#l00508">linalgOpToLoopsImpl()</a>, <a class="el" href="Loops_8cpp_source.html#l00686">mlir::linalg::linalgOpToParallelLoops()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00090">logFailure()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00313">lookupSymbolInImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01099">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01284">loopUnrollJamByFactor()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00292">lowerAffineLowerBound()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00107">lowerEntryPointABIAttr()</a>, <a class="el" href="Loops_8cpp_source.html#l00572">lowerLinalgToLoopsImpl()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00025">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00102">mlir::linalg::LinalgOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00040">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="IndexIntrinsicsOpLowering_8h_source.html#l00044">mlir::GPUIndexIntrinsicOpLowering&lt; Op, XOp, YOp, ZOp &gt;::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00119">mlir::linalg::CopyOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00111">mlir::PatternApplicator::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00139">mlir::linalg::CopyTransposeRewrite::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00162">mlir::linalg::IndexedGenericOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00124">mlir::vector::UnrollVectorPattern::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00157">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00173">mlir::RewritePattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02455">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00220">mlir::OpRewritePattern&lt; vector::ContractionOp &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02470">mlir::vector::PointwiseExtractPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01619">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00328">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01685">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01798">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00405">mlir::OpConversionPattern&lt; SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00421">mlir::linalg::LinalgTilingPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01930">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00163">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00249">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00275">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00534">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00302">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00598">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00598">mlir::ConvertOpToLLVMPattern&lt; gpu::ReturnOp &gt;::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00410">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00487">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00466">mlir::linalg::AffineMinSCFCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00535">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02524">TransferReadExtractPattern::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02562">TransferWriteInsertPattern::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00119">mlir::linalg::LinalgBaseTilingPattern::matchAndRewriteBase()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l03752">matchSimpleAtomicOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00216">mlir::TypeConverter::materializeTargetConversion()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00620">mergeIdenticalBlocks()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00151">MlirOptMain()</a>, <a class="el" href="Translation_8cpp_source.html#l00129">mlirTranslateMain()</a>, <a class="el" href="Dialect_2LLVMIR_2IR_2TypeDetail_8h_source.html#l00235">mlir::LLVM::detail::LLVMStructTypeStorage::mutate()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00923">mlir::spirv::detail::StructTypeStorage::mutate()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00396">normalizeMemRef()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01568">mlir::LLVM::detail::oneToOneRewrite()</a>, <a class="el" href="LogicalResult_8h_source.html#l00064">mlir::FailureOr&lt; T &gt;::operator LogicalResult()</a>, <a class="el" href="AsyncRegionRewriter_8cpp_source.html#l00055">GpuAsyncRegionPass::ThreadTokenCallback::operator()()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l00468">outlineExecuteOp()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00788">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01130">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01521">mlir::DmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01680">mlir::DmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01279">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00961">parseAccessChainOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00480">parseAffineApplyOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02049">parseAffineIfOp()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">mlir::detail::Parser::parseAffineMapReference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02904">parseAffineParallelOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02516">parseAffinePrefetchOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00136">parseAllocaOp()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00086">parseAllocateAndAllocator()</a>, <a class="el" href="Shape_8cpp_source.html#l00165">parseAssumingOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01533">parseAtomicBinOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01655">parseAtomicCmpXchgOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01559">parseAtomicOrdering()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01596">parseAtomicRMWOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00043">mlir::detail::Parser::parseAttribute()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00285">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00454">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00246">mlir::detail::Parser::parseAttributeDict()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00569">parseAttributions()</a>, <a class="el" href="Async_8cpp_source.html#l00330">parseAwaitResultType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01434">parseBound()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01189">parseBranchConditionalOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00645">parseCallOp()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00029">mlir::detail::Parser::parseCallSiteLocation()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00062">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00794">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="Parser_8cpp_source.html#l00039">mlir::detail::Parser::parseCommaSeparatedList()</a>, <a class="el" href="Parser_8cpp_source.html#l00059">mlir::detail::Parser::parseCommaSeparatedListUntil()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01526">parseCommonStructuredOpParts()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01363">parseCompositeExtractOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00363">parseConstShapeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00211">parseContractionOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00171">parseControlAttribute()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02991">parseCooperativeMatrixLoadNVOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03045">parseCooperativeMatrixStoreNVOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03178">parseCopyMemoryOp()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00032">parseCreateOperationOp()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00484">mlir::detail::Parser::parseDimensionListRanked()</a>, <a class="el" href="Ops_8cpp_source.html#l01736">parseDynamicTensorFromElementsOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00427">parseElementAttrHexValues()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01614">parseEntryPointOp()</a>, <a class="el" href="ParserUtils_8h_source.html#l00025">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00156">parseEnumKeywordAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00113">parseEnumStrAttr()</a>, <a class="el" href="Async_8cpp_source.html#l00212">parseExecuteOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01675">parseExecutionModeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00749">parseExtractElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00829">parseExtractValueOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01708">parseFenceOp()</a>, <a class="el" href="SCF_8cpp_source.html#l00178">parseForOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00137">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00016">mlir::impl::parseFunctionArgumentList()</a>, <a class="el" href="Shape_8cpp_source.html#l00584">parseFunctionLibraryOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00163">mlir::impl::parseFunctionLikeOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00095">parseFunctionResultList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFunctionResultTypes()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00128">mlir::impl::parseFunctionSignature()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00061">mlir::detail::Parser::parseFusedLocation()</a>, <a class="el" href="Ops_8cpp_source.html#l00518">parseGenericAtomicRMWOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00318">parseGenericOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02045">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01150">parseGlobalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01935">parseGlobalVariableOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00815">parseGPUModuleOp()</a>, <a class="el" href="SCF_8cpp_source.html#l00627">parseIfOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00867">parseInsertElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00911">parseInsertValueOp()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">mlir::detail::Parser::parseIntegerSetReference()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00363">parseInvokeOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00210">mlir::DialectAsmParser::parseKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00362">mlir::OpAsmParser::parseKeyword()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00845">parseKeywordList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00517">parseLandingpadOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00492">parseLaunchFuncOperands()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00107">parseListOfOperandsOrIntegers()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00233">parseLoadOp()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00154">mlir::detail::Parser::parseLocationInstance()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00836">parseLogicalBinaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00824">parseLogicalUnaryOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00464">parseLoopOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00192">parseMemoryAccessAttributes()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02451">parseModuleOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01578">parseNamedStructuredOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01501">parseNamedStructuredOpRegion()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01517">parseNamedStructuredOpResults()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00095">mlir::detail::Parser::parseNameOrFileLineColLocation()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00104">parseOperandAndType()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00058">parseOperandAndTypeList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00046">parseOperandList()</a>, <a class="el" href="PDL_8cpp_source.html#l00120">parseOperationOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00244">parseOptionalArrayStride()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00199">mlir::detail::Parser::parseOptionalAttribute()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00197">mlir::detail::Parser::parseOptionalAttributeWithToken()</a>, <a class="el" href="Parser_8cpp_source.html#l00098">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00150">mlir::DialectAsmParser::parseOptionalInteger()</a>, <a class="el" href="OpImplementation_8h_source.html#l00429">mlir::OpAsmParser::parseOptionalInteger()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01131">parseOptionalLLVMKeyword()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00089">parseOptionalOperand()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l01007">mlir::impl::parseOptionalVisibilityKeyword()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00183">parseParallelOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00470">parsePassPipeline()</a>, <a class="el" href="Ops_8cpp_source.html#l02521">parsePrefetchOp()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00325">mlir::detail::Parser::parsePrettyDialectSymbolName()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00162">parseQuantParams()</a>, <a class="el" href="SCF_8cpp_source.html#l01141">parseReduceOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00155">parseReductionOp()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00030">parseRegions()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00769">parseReturnOp()</a>, <a class="el" href="ROCDLDialect_8cpp_source.html#l00060">parseROCDLMubufStoreOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00853">parseShiftOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00200">parseShuffleOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01260">parseShuffleVectorOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00223">parseSourceMemoryAccessAttributes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03313">parseSpecConstantCompositeOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02767">parseSpecConstantOp()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00281">parseStoreOp()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">mlir::detail::Parser::parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00541">mlir::detail::Parser::parseStrideList()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00540">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02086">parseSubgroupBlockReadINTELOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02129">parseSubgroupBlockWriteINTELOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00547">mlir::OpAsmParser::parseSymbolName()</a>, <a class="el" href="Parser_8cpp_source.html#l00090">mlir::detail::Parser::parseToken()</a>, <a class="el" href="Ops_8cpp_source.html#l04013">parseTransposeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02898">parseTupleGetOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00314">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00755">mlir::OpAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00772">mlir::OpAsmParser::parseTypeList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">mlir::detail::Parser::parseTypeListNoParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">mlir::detail::Parser::parseTypeListParens()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00799">parseUnaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00491">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02889">parseVariableOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00939">parseVerCapExtAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00525">mlir::detail::Parser::parseXInDimensionList()</a>, <a class="el" href="PassRegistry_8h_source.html#l00167">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00189">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00045">performActions()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00258">mlir::vector::PointwiseExtractPattern::PointwiseExtractPattern()</a>, <a class="el" href="Transforms_2Bufferize_8cpp_source.html#l00049">populateBufferizeMaterializationLegality()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00040">populateCallOpTypeConversionPattern()</a>, <a class="el" href="OptUtils_8cpp_source.html#l00065">populatePassManagers()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02100">print()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00676">printGPUFuncOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01414">printLLVMFuncOp()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00377">processParallelLoop()</a>, <a class="el" href="Ops_8cpp_source.html#l03253">produceSubViewErrorMsg()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00153">promoteIfSingleIteration()</a>, <a class="el" href="Promotion_8cpp_source.html#l00367">mlir::linalg::promoteSubviewsPrecondition()</a>, <a class="el" href="LLVMArmNeonIntr_8cpp_source.html#l00046">registerArmNeonToLLVMIRTranslation()</a>, <a class="el" href="LLVMArmSVEIntr_8cpp_source.html#l00046">registerArmSVEToLLVMIRTranslation()</a>, <a class="el" href="LLVMAVX512Intr_8cpp_source.html#l00046">registerAVX512ToLLVMIRTranslation()</a>, <a class="el" href="IR_2Diagnostics_8h_source.html#l00424">mlir::DiagnosticEngine::registerHandler()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00039">registerToLLVMIRTranslation()</a>, <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00100">registerToNVVMIRTranslation()</a>, <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00104">registerToROCDLIRTranslation()</a>, <a class="el" href="Translation_8cpp_source.html#l00060">registerTranslateToMLIRFunction()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01039">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00045">replaceAllMemRefUsesWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00849">replaceAllSymbolUsesImpl()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00151">replaceBlockArgForUnitDimLoops()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00157">replaceBlockArgForUnitDimLoops&lt; IndexedGenericOp &gt;()</a>, <a class="el" href="SCF_8cpp_source.html#l00398">replaceOpWithRegion()</a>, <a class="el" href="SCFToSPIRV_8cpp_source.html#l00091">replaceSCFOutputValue()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00220">replaceTransferOpWithLoadOrStore()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00232">replaceTransferOpWithMasked()</a>, <a class="el" href="VectorToROCDL_8cpp_source.html#l00030">replaceTransferOpWithMubuf()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00247">replaceUnitExtents()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00220">replaceWithLoadOrStore()</a>, <a class="el" href="TosaMakeBroadcastable_8cpp_source.html#l00110">reshapeLowerToHigher()</a>, <a class="el" href="OpImplementation_8h_source.html#l00624">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00111">resolveSourceIndices()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00124">roundTripModule()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00358">runRegionDCE()</a>, <a class="el" href="Inliner_8cpp_source.html#l00286">runTransformOnCGSCCs()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03066">separateFullTiles()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00082">serializeModule()</a>, <a class="el" href="AffineStructures_8h_source.html#l00481">mlir::FlatAffineConstraints::setIdValues()</a>, <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00043">mlir::gpu::setMappingAttr()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00325">mlir::OpPassManager::setNesting()</a>, <a class="el" href="Simplex_8cpp_source.html#l00030">mlir::Simplex::Simplex()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00696">simplifyRegions()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00106">sinkOperationsIntoLaunchOp()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00410">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02382">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02154">mlir::vector::splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">structFuncArgTypeConverter()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00902">tilePerfectlyNested()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00944">tilePerfectlyNestedParametric()</a>, <a class="el" href="CodegenStrategy_8cpp_source.html#l00029">mlir::linalg::CodegenStrategy::transform()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00400">mlir::OpBuilder::tryFold()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01845">tryIsolateBands()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00087">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02789">mlir::FlatAffineConstraints::unionBoundingBox()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00665">mlir::vector::unrollSingleResultVectorOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00634">mlir::vector::unrollTransferWriteOp()</a>, <a class="el" href="CAPI_2Support_8h_source.html#l00038">unwrap()</a>, <a class="el" href="ModuleCombiner_8cpp_source.html#l00046">updateSymbolAndAllUses()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00798">vectorizeAffineForOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00277">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01170">vectorizeLoopNest()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00853">vectorizeLoopsAndLoads()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01097">vectorizeNonTerminals()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01015">vectorizeOneOperation()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00751">vectorizeRootOrTerminal()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01636">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="VectorTransforms_8h_source.html#l00209">mlir::vector::VectorTransferFullPartialRewriter::VectorTransferFullPartialRewriter()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01203">mlir::AffineDmaStartOp::verify()</a>, <a class="el" href="Ops_8cpp_source.html#l01581">mlir::DmaStartOp::verify()</a>, <a class="el" href="OpDefinition_8h_source.html#l00244">mlir::OpState::verify()</a>, <a class="el" href="Ops_8cpp_source.html#l01706">mlir::DmaWaitOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01309">mlir::AffineDmaWaitOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00510">verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02405">verifyAffineMinMaxOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00266">verifyAllocLikeOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00147">verifyAllReduce()</a>, <a class="el" href="Operation_8cpp_source.html#l00738">mlir::OpTrait::impl::verifyAtLeastNOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00825">mlir::OpTrait::impl::verifyAtLeastNRegions()</a>, <a class="el" href="Operation_8cpp_source.html#l00851">mlir::OpTrait::impl::verifyAtLeastNResults()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00699">verifyAtomicUpdateOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00721">verifyAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00479">verifyBlockReadWritePtrAndValTypes()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00452">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyBody()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00048">mlir::detail::verifyBranchSuccessorOperands()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00309">verifyCastOp()</a>, <a class="el" href="Traits_8cpp_source.html#l00189">mlir::OpTrait::impl::verifyCompatibleOperandBroadcast()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00054">verifyCompatibleShape()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00031">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00155">mlir::spirv::InterfaceVarABIAttr::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00043">mlir::ComplexType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00250">mlir::spirv::VerCapExtAttr::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00061">mlir::IntegerType::verifyConstructionInvariants()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00123">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVAttributes_8cpp_source.html#l00331">mlir::spirv::TargetEnvAttr::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00252">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00220">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00211">mlir::OpaqueType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00341">mlir::IntegerAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00256">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00282">mlir::LLVM::LLVMArrayType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00399">mlir::OpaqueAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00310">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00332">mlir::LLVM::LLVMFunctionType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00321">mlir::VectorType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00357">mlir::LLVM::LLVMIntegerType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00387">mlir::LLVM::LLVMPointerType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00370">mlir::quant::CalibratedQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01116">mlir::spirv::MatrixType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00453">mlir::LLVM::LLVMStructType::verifyConstructionInvariants()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00495">mlir::LLVM::LLVMVectorType::verifyConstructionInvariants()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00534">mlir::UnrankedMemRefType::verifyConstructionInvariants()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00115">verifyConvOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03084">verifyCoopMatrixMulAdd()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00092">verifyDependencies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00458">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="Operation_8cpp_source.html#l01095">mlir::OpTrait::impl::verifyElementwiseMappable()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00241">verifyFloatTypeInvariants()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00499">verifyGenericOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00770">verifyGroupNonUniformArithmeticOp()</a>, <a class="el" href="PDL_8cpp_source.html#l00065">verifyHasBindingUseInMatcher()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00140">verifyIndexOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00049">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00330">verifyIntegerTypeInvariants()</a>, <a class="el" href="Operation_8cpp_source.html#l00758">mlir::OpTrait::impl::verifyIsIdempotent()</a>, <a class="el" href="Operation_8cpp_source.html#l00766">mlir::OpTrait::impl::verifyIsInvolution()</a>, <a class="el" href="Operation_8cpp_source.html#l00950">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00464">verifyLoadStorePtrAndValTypes()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00615">verifyLoopOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03276">verifyMatrixTimesMatrix()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03109">verifyMatrixTimesScalar()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00356">verifyMemoryAccessAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02259">verifyMemoryOpIndexing()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00440">verifyMemorySemantics()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01639">verifyNamedStructuredOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00729">mlir::OpTrait::impl::verifyNOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l01070">mlir::OpTrait::impl::verifyNoRegionArguments()</a>, <a class="el" href="Operation_8cpp_source.html#l00818">mlir::OpTrait::impl::verifyNRegions()</a>, <a class="el" href="Operation_8cpp_source.html#l00844">mlir::OpTrait::impl::verifyNResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00723">mlir::OpTrait::impl::verifyOneOperand()</a>, <a class="el" href="Operation_8cpp_source.html#l00812">mlir::OpTrait::impl::verifyOneRegion()</a>, <a class="el" href="Operation_8cpp_source.html#l00838">mlir::OpTrait::impl::verifyOneResult()</a>, <a class="el" href="Operation_8cpp_source.html#l00784">mlir::OpTrait::impl::verifyOperandsAreFloatLike()</a>, <a class="el" href="Operation_8cpp_source.html#l00775">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00121">mlir::Dialect::verifyOperationAttribute()</a>, <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">verifyOpWithOffsetSizesAndStridesPart()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00285">verifyOutputShape()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00118">verifyParallelOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01865">verifyPermutationMap()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03022">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00058">mlir::Dialect::verifyRegionArgAttribute()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l01207">verifyRegionAttribute()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00066">verifyRegionOp()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00067">mlir::Dialect::verifyRegionResultAttribute()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00863">verifyReshapeLikeTypes()</a>, <a class="el" href="Operation_8cpp_source.html#l01002">mlir::OpTrait::impl::verifyResultsAreBoolLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01013">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01022">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike()</a>, <a class="el" href="PDL_8cpp_source.html#l00218">verifyResultTypesAreInferrable()</a>, <a class="el" href="Operation_8cpp_source.html#l00904">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00871">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00928">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00890">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00859">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00793">mlir::OpTrait::impl::verifySameTypeOperands()</a>, <a class="el" href="Shape_8cpp_source.html#l00051">verifyShapeOrExtentTensorOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00877">verifyShiftOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00182">verifyShuffleOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01260">verifySingleInputPoolingOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00039">verifySizeOrIndexOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00400">verifySourceMemoryAccessAttribute()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01212">verifyStrideOrDilation()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00414">mlir::detail::verifySymbol()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00373">mlir::detail::verifySymbolTable()</a>, <a class="el" href="Operation_8cpp_source.html#l00958">verifyTerminatorSuccessors()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00074">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00100">mlir::OpTrait::ReturnLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00109">mlir::OpTrait::linalg::NamedStructuredOpTrait&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00816">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01111">mlir::OpTrait::ConstantLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01134">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01150">mlir::OpTrait::AffineScope&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01166">mlir::OpTrait::AutomaticAllocationScope&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01180">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;::Impl&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l01486">mlir::op_definition_impl::verifyTraitsImpl()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01893">verifyTransferOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03251">verifyTranspose()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00446">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyType()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00086">verifyTypesAlongAllEdges()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00151">mlir::detail::verifyTypesAlongControlFlowEdges()</a>, <a class="el" href="Operation_8cpp_source.html#l01029">verifyValueSizeAttr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03097">verifyVectorMemoryOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02569">verifyVectorShapeCast()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01120">verifyYield()</a>, <a class="el" href="Operation_8cpp_source.html#l00717">mlir::OpTrait::impl::verifyZeroOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00806">mlir::OpTrait::impl::verifyZeroRegion()</a>, <a class="el" href="Operation_8cpp_source.html#l00832">mlir::OpTrait::impl::verifyZeroResult()</a>, <a class="el" href="Operation_8cpp_source.html#l00968">mlir::OpTrait::impl::verifyZeroSuccessor()</a>, <a class="el" href="Serialization_8cpp_source.html#l00065">visitInPrettyBlockOrder()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01271">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a623f987acfe618f9aa4823d6c7aec9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623f987acfe618f9aa4823d6c7aec9d6">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01753">1753</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01740">tileImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01862">extractFixedOuterLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01766">tileImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01786">tilePerfectlyNested()</a>.</p>

</div>
</div>
<a id="ab15bd4c107bb9ea52b7fcc11c283c129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15bd4c107bb9ea52b7fcc11c283c129">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a>, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01758">1758</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01740">tileImpl()</a>.</p>

</div>
</div>
<a id="a8605009295454f6ebebbbaed546f7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8605009295454f6ebebbbaed546f7963">&#9670;&nbsp;</a></span>tile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01775">1775</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01740">tileImpl()</a>.</p>

</div>
</div>
<a id="adb3ac25a4d763e0e5234f6b347c7f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3ac25a4d763e0e5234f6b347c7f17a">&#9670;&nbsp;</a></span>tile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01781">1781</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01740">tileImpl()</a>.</p>

</div>
</div>
<a id="affb0191e64550dc17ce5ec5e35b74882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb0191e64550dc17ce5ec5e35b74882">&#9670;&nbsp;</a></span>tilePerfectlyNested() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>tiledNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00902">902</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00582">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00822">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00542">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01913">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00512">performPreTilingChecks()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00066">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="a76588ffa46e04caaa584360fa5cdde4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76588ffa46e04caaa584360fa5cdde4c">&#9670;&nbsp;</a></span>tilePerfectlyNested() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad5c8735b67af7a64e4deff16477a06eb">Loops</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>rootForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of scf::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes. </p>
<p>Sizes are expected to be strictly positive values at runtime. If more sizes than loops are provided, discard the trailing values in sizes. Assumes the loop nest is permutable. Returns the newly created intra-tile loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01786">1786</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00987">getPerfectlyNestedLoopsImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01753">tile()</a>.</p>

</div>
</div>
<a id="a7722fac9c5c7f3625d6a6fe1e2fbd52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7722fac9c5c7f3625d6a6fe1e2fbd52d">&#9670;&nbsp;</a></span>tilePerfectlyNestedParametric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tilePerfectlyNestedParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>tiledNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00944">944</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00582">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00794">constructParametricallyTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00542">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01913">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00512">performPreTilingChecks()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

</div>
</div>
<a id="a67f5deb263dc3ca56a8c5ae015cba4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f5deb263dc3ca56a8c5ae015cba4af">&#9670;&nbsp;</a></span>topologicalSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SetVector&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>toSort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-root DAG topological sort. </p>
<p>Performs a topological sort of the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within MLIR. ">Operation</a> in the <code>toSort</code> SetVector. Returns a topologically sorted SetVector. </p>

<p class="reference">Referenced by <a class="el" href="ModuleTranslation_8cpp_source.html#l00461">mlir::LLVM::ModuleTranslation::convertOmpOpRegions()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00175">DFSPostorder()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00877">forwardPassthroughAttributes()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00136">getSlice()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01097">vectorizeNonTerminals()</a>.</p>

</div>
</div>
<a id="ae1515f52892c837f5105efe3f5c5c060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1515f52892c837f5105efe3f5c5c060">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00126">126</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00078">getParallelIteratorTypeName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00085">getReductionIteratorTypeName()</a>, <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a98402eecfbcefc336954458a01752131">Parallel</a>, and <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55a9e834f13e35e4edf64863ab414a6217a">Reduction</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00024">mlir::edsc::makeGenericLinalgOp()</a>, and <a class="el" href="Dialect_2Vector_2EDSC_2Builders_8cpp_source.html#l00021">mlir::edsc::ops::vector_contraction()</a>.</p>

</div>
</div>
<a id="ae41497963c69c44476e78ff2043d4651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41497963c69c44476e78ff2043d4651">&#9670;&nbsp;</a></span>translateLLVMIRToModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::translateLLVMIRToModule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;&#160;</td>
          <td class="paramname"><em>llvmModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into MLIR's <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>The <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context is extracted from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>{}</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00838">838</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="Location_8cpp_source.html#l00050">mlir::FileLineColLoc::get()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00079">mlir::MLIRContext::loadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00859">translateLLVMIRToModule()</a>.</p>

</div>
</div>
<a id="a320cb8d8764e198852aed80f389a0fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320cb8d8764e198852aed80f389a0fc7">&#9670;&nbsp;</a></span>translateModuleToLLVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; mlir::translateModuleToLLVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspirv_1_1ModuleOp.html">ModuleOp</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>llvmContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;LLVMDialectModule&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given MLIR module into <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR. </p>
<p>The <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context is extracted from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>nullptr</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00027">27</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00301">emitError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00219">mlir::ExecutionEngine::create()</a>.</p>

</div>
</div>
<a id="ab90c4b2d1ff332cdf4a0b040d53a89be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90c4b2d1ff332cdf4a0b040d53a89be">&#9670;&nbsp;</a></span>translateModuleToNVVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; mlir::translateModuleToNVVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>llvmContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;LLVMDialectModule&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> IR. </p>
<p>This conversion requires the registration of the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect and will extract the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>nullptr</code>. </p>

<p class="reference">Referenced by <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00038">getShflBflyIntrinsicId()</a>, and <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00100">registerToNVVMIRTranslation()</a>.</p>

</div>
</div>
<a id="abab089f0f6a252963ae74f63d293294b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab089f0f6a252963ae74f63d293294b">&#9670;&nbsp;</a></span>translateModuleToROCDLIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; mlir::translateModuleToROCDLIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>llvmContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;LLVMDialectModule&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> IR. </p>
<p>This conversion requires the registration of the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect and will extract the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>nullptr</code>. </p>

<p class="reference">Referenced by <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00044">createDeviceFunctionCall()</a>, and <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00104">registerToROCDLIRTranslation()</a>.</p>

</div>
</div>
<a id="ae4d7280c80aed8b236533289e9d327be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d7280c80aed8b236533289e9d327be">&#9670;&nbsp;</a></span>vectorizeAffineLoopNest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::vectorizeAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest. ">VectorizationStrategy</a> definition). </p>
<p>Loops are provided in a 2D vector container. The first dimension represents the nesting level relative to the loops to be vectorized. The second dimension contains the loops. This means that: a) every loop in 'loops[i]' must have a parent loop in 'loops[i-1]', b) a loop in 'loops[i]' may or may not have a child loop in 'loops[i+1]'.</p>
<p>For example, for the following loop nest:</p>
<p>func (in0: memref&lt;64x128x512xf32&gt;, in1: memref&lt;64x128x128xf32&gt;, out0: memref&lt;64x128x512xf32&gt;, out1: memref&lt;64x128x128xf32&gt;) { affine.for i0 = 0 to 64 { affine.for i1 = 0 to 128 { affine.for i2 = 0 to 512 { ld = affine.load in0[i0, i1, i2] : memref&lt;64x128x512xf32&gt; affine.store ld, out0[i0, i1, i2] : memref&lt;64x128x512xf32&gt; } affine.for i3 = 0 to 128 { ld = affine.load in1[i0, i1, i3] : memref&lt;64x128x128xf32&gt; affine.store ld, out1[i0, i1, i3] : memref&lt;64x128x128xf32&gt; } } } return }</p>
<p>loops = {{i0}, {i2, i3}}, to vectorize the outermost and the two innermost loops; loops = {{i1}, {i2, i3}}, to vectorize the middle and the two innermost loops; loops = {{i2}}, to vectorize only the first innermost loop; loops = {{i3}}, to vectorize only the second innermost loop; loops = {{i1}}, to vectorize only the middle loop. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01419">1419</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01170">vectorizeLoopNest()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01339">verifyLoopNesting()</a>.</p>

</div>
</div>
<a id="ab1ea06720de269b4ecd1ed463263dd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ea06720de269b4ecd1ed463263dd7c">&#9670;&nbsp;</a></span>vectorizeAffineLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vectorizeAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="structllvm_1_1DenseMapInfo.html">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fastestVaryingPattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'. </p>
<p>By default, each vectorization factor is applied inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can be optionally used to provide a different loop vectorization order. </p>

</div>
</div>
<a id="ac235bc6229112b8d5ac18171be7d9d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac235bc6229112b8d5ac18171be7d9d8b">&#9670;&nbsp;</a></span>vectorizeAffineLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vectorizeAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fastestVaryingPattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External utility to vectorize affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'. </p>
<p>By default, each vectorization factor is applied inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can be optionally used to provide a different loop vectorization order. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01375">1375</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01267">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="a8311703578f50c8d610c687db37a8dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8311703578f50c8d610c687db37a8dc4">&#9670;&nbsp;</a></span>verify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations. </p>
<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs.</p>
<p>On error, this reports the error through the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations. ">MLIRContext</a> and returns failure. </p>

<p class="definition">Definition at line <a class="el" href="Verifier_8cpp_source.html#l00294">294</a> of file <a class="el" href="Verifier_8cpp_source.html">Verifier.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00214">mlir::Operation::getContext()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">verify()</a>.</p>

</div>
</div>
<a id="ad9f4c1929cc819247d6e7b515554733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f4c1929cc819247d6e7b515554733f">&#9670;&nbsp;</a></span>verify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verify </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00038">38</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00311">mlir::ShapedType::isDynamic()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00314">mlir::ShapedType::isDynamicStrideOrOffset()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">verifyOpWithOffsetSizesAndStridesPart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01559">mlir::Op&lt; DmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;::getFromOpaquePointer()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00360">getGenericEffectsImpl()</a>, <a class="el" href="Ops_8h_source.html#l00297">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="Ops_8h_source.html#l00233">mlir::DmaStartOp::getOperationName()</a>, <a class="el" href="IR_8cpp_source.html#l00343">mlirOperationVerify()</a>, <a class="el" href="Parser_8cpp_source.html#l00098">mlir::detail::Parser::parseOptionalInteger()</a>, <a class="el" href="Translation_8cpp_source.html#l00060">registerTranslateToMLIRFunction()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00325">mlir::OpPassManager::setNesting()</a>, <a class="el" href="Verifier_8cpp_source.html#l00294">verify()</a>, and <a class="el" href="SCF_8cpp_source.html#l01172">verify()</a>.</p>

</div>
</div>
<a id="acb414ad1d507c2ab841305c273f4deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb414ad1d507c2ab841305c273f4deb8">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two shapes are compatible. </p>
<p>That is, they have the same size and each pair of the elements are equal or one of them is dynamic. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00054">54</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00311">mlir::ShapedType::isDynamic()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l03836">verify()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00073">verifyCompatibleShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00871">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00928">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, and <a class="el" href="Operation_8cpp_source.html#l00859">mlir::OpTrait::impl::verifySameOperandsShape()</a>.</p>

</div>
</div>
<a id="ac54e5e6c31f51ef648f7c03652a29ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54e5e6c31f51ef648f7c03652a29ce6">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two types have compatible shape. </p>
<p>That is, they are both scalars (not shaped), or they are both shaped types and at least one is unranked or they have compatible dimensions. Dimensions are compatible if at least one is dynamic or both are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00073">73</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00234">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">failure()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00288">mlir::ShapedType::getShape()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00244">mlir::ShapedType::hasRank()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00054">verifyCompatibleShape()</a>.</p>

</div>
</div>
<a id="a6b6bf62f92ba677b78bd16aa0f34fd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6bf62f92ba677b78bd16aa0f34fd07">&#9670;&nbsp;</a></span>viewGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::viewGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::GraphProgram::Name&#160;</td>
          <td class="paramname"><em>program</em> = <code>llvm::GraphProgram::DOT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the graph in a window. </p>
<p>This is for use from the debugger and depends on Graphviz to generate the graph. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00153">153</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewRegionGraph_8cpp_source.html#l00057">mlir::Region::viewGraph()</a>.</p>

</div>
</div>
<a id="aeeb01423a036ce7642b34f08a4d39e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb01423a036ce7642b34f08a4d39e8b">&#9670;&nbsp;</a></span>viewGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::viewGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::GraphProgram::Name&#160;</td>
          <td class="paramname"><em>program</em> = <code>llvm::GraphProgram::DOT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the CFG in a window. </p>
<p>This is for use from the debugger and depends on Graphviz to generate the graph. </p>

<p class="definition">Definition at line <a class="el" href="ViewRegionGraph_8cpp_source.html#l00047">47</a> of file <a class="el" href="ViewRegionGraph_8cpp_source.html">ViewRegionGraph.cpp</a>.</p>

</div>
</div>
<a id="ae644ec0854505ef60f12c23b96de595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644ec0854505ef60f12c23b96de595b">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00031">31</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00256">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00046">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::isAncestor()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00250">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00058">getUsedValuesDefinedAbove()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00052">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a036e7ce3c7c3bf73fc0a653cd98bb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00052">52</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00031">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a655db45ed8c23d04d5ed5ee0abe041ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655db45ed8c23d04d5ed5ee0abe041ad">&#9670;&nbsp;</a></span>wouldOpBeTriviallyDead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::wouldOpBeTriviallyDead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation would be dead if unused, and has no side effects on memory that would prevent erasing. </p>
<p>This is equivalent to checking <code>isOpTriviallyDead</code> if <code>op</code> was unused. </p>

<p class="definition">Definition at line <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00093">93</a> of file <a class="el" href="SideEffectInterfaces_8cpp_source.html">SideEffectInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00479">mlir::Operation::isKnownNonTerminator()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00040">wouldOpBeTriviallyDeadImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00032">isOpTriviallyDead()</a>, and <a class="el" href="Ops_8cpp_source.html#l01767">verify()</a>.</p>

</div>
</div>
<a id="a3637269c766005364583ba36db13bacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3637269c766005364583ba36db13bacd">&#9670;&nbsp;</a></span>writeGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::writeGraph </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewRegionGraph_8cpp_source.html#l00052">52</a> of file <a class="el" href="ViewRegionGraph_8cpp_source.html">ViewRegionGraph.cpp</a>.</p>

</div>
</div>
<a id="aa9dab397b212cccb9be9497581485293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dab397b212cccb9be9497581485293">&#9670;&nbsp;</a></span>writeGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::writeGraph </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00158">158</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewRegionGraph_8cpp_source.html#l00060">mlir::Region::viewGraph()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2887883f00b094c5ca61c631d7b093a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2887883f00b094c5ca61c631d7b093a0">&#9670;&nbsp;</a></span>kDeriveIndexBitwidthFromDataLayout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::kDeriveIndexBitwidthFromDataLayout = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> to pass as bitwidth for the index type when the converter is expected to derive the bitwidth from the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> data layout. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00025">25</a> of file <a class="el" href="ConvertStandardToLLVMPass_8h_source.html">ConvertStandardToLLVMPass.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00117">encodeKernelName()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l00104">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="a470c28c68e095c2f94534de768800107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470c28c68e095c2f94534de768800107">&#9670;&nbsp;</a></span>kUnknownNumRegionInvocations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t mlir::kUnknownNumRegionInvocations = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00077">77</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="NumberOfExecutions_8cpp_source.html#l00032">computeRegionBlockNumberOfExecutions()</a>.</p>

</div>
</div>
<a id="a2aeb0828d77d6958e5bc1fabe03734b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeb0828d77d6958e5bc1fabe03734b5">&#9670;&nbsp;</a></span>makeLLVMPassesTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt; mlir::makeLLVMPassesTransformer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes explicitly specified, plus an optional optimization level, Any optimization passes, if present, will be inserted before the pass at position optPassesInsertPos. </p>
<p>If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8h_source.html#l00050">50</a> of file <a class="el" href="OptUtils_8h_source.html">OptUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00246">JitRunnerMain()</a>, and <a class="el" href="OptUtils_8cpp_source.html#l00065">populatePassManagers()</a>.</p>

</div>
</div>
<a id="a159f88d87b78c353731e1661c65a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159f88d87b78c353731e1661c65a0b98">&#9670;&nbsp;</a></span>makeOptimizingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt; mlir::makeOptimizingTransformer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g. </p>
<p>-O2 or -Os). If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8h_source.html#l00040">40</a> of file <a class="el" href="OptUtils_8h_source.html">OptUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OptUtils_8cpp_source.html#l00065">populatePassManagers()</a>.</p>

</div>
</div>
<a id="ae15e265851e534782cef307a4c775b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15e265851e534782cef307a4c775b46">&#9670;&nbsp;</a></span>nullIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int mlir::nullIndex = std::numeric_limits&lt;int&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00016">16</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 16 2020 12:50:40 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
